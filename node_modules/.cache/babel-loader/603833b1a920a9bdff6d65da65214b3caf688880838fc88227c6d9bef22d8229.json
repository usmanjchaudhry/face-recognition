{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2ServerCallStream = exports.ServerDuplexStreamImpl = exports.ServerWritableStreamImpl = exports.ServerReadableStreamImpl = exports.ServerUnaryCallImpl = void 0;\nconst events_1 = require(\"events\");\nconst http2 = require(\"http2\");\nconst stream_1 = require(\"stream\");\nconst zlib = require(\"zlib\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst error_1 = require(\"./error\");\nconst TRACER_NAME = 'server_call';\nconst unzip = (0, util_1.promisify)(zlib.unzip);\nconst inflate = (0, util_1.promisify)(zlib.inflate);\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity'\n};\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto'\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true\n};\nclass ServerUnaryCallImpl extends events_1.EventEmitter {\n  constructor(call, metadata, request) {\n    super();\n    this.call = call;\n    this.metadata = metadata;\n    this.request = request;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerUnaryCallImpl = ServerUnaryCallImpl;\nclass ServerReadableStreamImpl extends stream_1.Readable {\n  constructor(call, metadata, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n  _read(size) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n    this.call.resume();\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n}\nexports.ServerReadableStreamImpl = ServerReadableStreamImpl;\nclass ServerWritableStreamImpl extends stream_1.Writable {\n  constructor(call, metadata, serialize, request) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.request = request;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  _write(chunk, encoding,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  callback) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      this.emit('error', {\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n    callback();\n  }\n  _final(callback) {\n    this.call.sendStatus({\n      code: constants_1.Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata\n    });\n    callback(null);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerWritableStreamImpl = ServerWritableStreamImpl;\nclass ServerDuplexStreamImpl extends stream_1.Duplex {\n  constructor(call, metadata, serialize, deserialize, encoding) {\n    super({\n      objectMode: true\n    });\n    this.call = call;\n    this.metadata = metadata;\n    this.serialize = serialize;\n    this.deserialize = deserialize;\n    this.cancelled = false;\n    this.trailingMetadata = new metadata_1.Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n    this.on('error', err => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n  getPeer() {\n    return this.call.getPeer();\n  }\n  sendMetadata(responseMetadata) {\n    this.call.sendMetadata(responseMetadata);\n  }\n  getDeadline() {\n    return this.call.getDeadline();\n  }\n  getPath() {\n    return this.call.getPath();\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n    return super.end();\n  }\n}\nexports.ServerDuplexStreamImpl = ServerDuplexStreamImpl;\nServerDuplexStreamImpl.prototype._read = ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write = ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final = ServerWritableStreamImpl.prototype._final;\n// Internal class that wraps the HTTP2 request.\nclass Http2ServerCallStream extends events_1.EventEmitter {\n  constructor(stream, handler, options) {\n    super();\n    this.stream = stream;\n    this.handler = handler;\n    this.options = options;\n    this.cancelled = false;\n    this.deadlineTimer = null;\n    this.statusSent = false;\n    this.deadline = Infinity;\n    this.wantTrailers = false;\n    this.metadataSent = false;\n    this.canPush = false;\n    this.isPushPending = false;\n    this.bufferedMessages = [];\n    this.messagesToPush = [];\n    this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n    this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n    this.stream.once('error', err => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n    this.stream.once('close', () => {\n      var _a;\n      trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' stream closed with rstCode ' + this.stream.rstCode);\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: constants_1.Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null\n        });\n      }\n    });\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length'];\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length'];\n    }\n  }\n  checkCancelled() {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n  getDecompressedMessage(message, encoding) {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n    return Promise.reject({\n      code: constants_1.Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`\n    });\n  }\n  sendMetadata(customMetadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.metadataSent) {\n      return;\n    }\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom);\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n  receiveMetadata(headers) {\n    const metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace('Request to ' + this.handler.path + ' received headers ' + JSON.stringify(metadata.toJSON()));\n    }\n    // TODO(cjihrig): Receive compression metadata.\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n      if (match === null) {\n        const err = new Error('Invalid deadline');\n        err.code = constants_1.Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n      const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n  receiveUnaryMessage(encoding, next) {\n    const {\n      stream\n    } = this;\n    let receivedLength = 0;\n    const call = this;\n    const body = [];\n    const limit = this.maxReceiveMessageSize;\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n    function onData(chunk) {\n      receivedLength += chunk.byteLength;\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: constants_1.Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`\n        });\n        return;\n      }\n      body.push(chunk);\n    }\n    function onEnd(err) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n      if (err !== undefined) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: err.message\n        });\n        return;\n      }\n      if (receivedLength === 0) {\n        next({\n          code: constants_1.Status.INTERNAL,\n          details: 'received empty unary message'\n        });\n        return;\n      }\n      call.emit('receiveMessage');\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(requestBytes, compressedMessageEncoding);\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n      decompressedMessage.then(decompressed => call.safeDeserializeMessage(decompressed, next), err => next(err.code ? err : {\n        code: constants_1.Status.INTERNAL,\n        details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`\n      }));\n    }\n  }\n  safeDeserializeMessage(buffer, next) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      next({\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n  }\n  serializeMessage(value) {\n    const messageBuffer = this.handler.serialize(value);\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  deserializeMessage(bytes) {\n    return this.handler.deserialize(bytes);\n  }\n  async sendUnaryMessage(err, value, metadata, flags) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (metadata === undefined) {\n      metadata = null;\n    }\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n    try {\n      const response = this.serializeMessage(value);\n      this.write(response);\n      this.sendStatus({\n        code: constants_1.Status.OK,\n        details: 'OK',\n        metadata\n      });\n    } catch (err) {\n      this.sendError({\n        details: (0, error_1.getErrorMessage)(err),\n        code: constants_1.Status.INTERNAL\n      });\n    }\n  }\n  sendStatus(statusObj) {\n    var _a, _b;\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === constants_1.Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n    trace('Request to method ' + ((_a = this.handler) === null || _a === void 0 ? void 0 : _a.path) + ' ended with status code: ' + constants_1.Status[statusObj.code] + ' details: ' + statusObj.details);\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n    if (this.stream.headersSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          var _a;\n          const trailersToSend = Object.assign({\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n          }, (_a = statusObj.metadata) === null || _a === void 0 ? void 0 : _a.toHttp2Headers());\n          this.stream.sendTrailers(trailersToSend);\n          this.statusSent = true;\n        });\n        this.stream.end();\n      }\n    } else {\n      // Trailers-only response\n      const trailersToSend = Object.assign(Object.assign({\n        [GRPC_STATUS_HEADER]: statusObj.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details)\n      }, defaultResponseHeaders), (_b = statusObj.metadata) === null || _b === void 0 ? void 0 : _b.toHttp2Headers());\n      this.stream.respond(trailersToSend, {\n        endStream: true\n      });\n      this.statusSent = true;\n    }\n  }\n  sendError(error) {\n    const status = {\n      code: constants_1.Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata: 'metadata' in error && error.metadata !== undefined ? error.metadata : null\n    };\n    if ('code' in error && typeof error.code === 'number' && Number.isInteger(error.code)) {\n      status.code = error.code;\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details;\n      }\n    }\n    this.sendStatus(status);\n  }\n  write(chunk) {\n    if (this.checkCancelled()) {\n      return;\n    }\n    if (this.maxSendMessageSize !== -1 && chunk.length > this.maxSendMessageSize) {\n      this.sendError({\n        code: constants_1.Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`\n      });\n      return;\n    }\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n  resume() {\n    this.stream.resume();\n  }\n  setupSurfaceCall(call) {\n    this.once('cancelled', reason => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n    this.once('callEnd', status => call.emit('callEnd', status));\n  }\n  setupReadable(readable, encoding) {\n    const decoder = new stream_decoder_1.StreamDecoder();\n    let readsDone = false;\n    let pendingMessageProcessing = false;\n    let pushedEnd = false;\n    const maybePushEnd = async () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        await this.pushOrBufferMessage(readable, null);\n      }\n    };\n    this.stream.on('data', async data => {\n      const messages = decoder.write(data);\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (this.maxReceiveMessageSize !== -1 && message.length > this.maxReceiveMessageSize) {\n          this.sendError({\n            code: constants_1.Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(message, compressedMessageEncoding);\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n        await this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      await maybePushEnd();\n    });\n    this.stream.once('end', async () => {\n      readsDone = true;\n      await maybePushEnd();\n    });\n  }\n  consumeUnpushedMessages(readable) {\n    this.canPush = true;\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n    return this.canPush;\n  }\n  async pushOrBufferMessage(readable, messageBytes) {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      await this.pushMessage(readable, messageBytes);\n    }\n  }\n  async pushMessage(readable, messageBytes) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n      return;\n    }\n    trace('Received message of length ' + messageBytes.length);\n    this.isPushPending = true;\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      let code = (0, error_1.getErrorCode)(error);\n      if (code === null || code < constants_1.Status.OK || code > constants_1.Status.UNAUTHENTICATED) {\n        code = constants_1.Status.INTERNAL;\n      }\n      readable.emit('error', {\n        details: (0, error_1.getErrorMessage)(error),\n        code: code\n      });\n    }\n    this.isPushPending = false;\n    if (this.bufferedMessages.length > 0) {\n      await this.pushMessage(readable, this.bufferedMessages.shift());\n    }\n  }\n  getPeer() {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n  getDeadline() {\n    return this.deadline;\n  }\n  getPath() {\n    return this.handler.path;\n  }\n}\nexports.Http2ServerCallStream = Http2ServerCallStream;\nfunction handleExpiredDeadline(call) {\n  const err = new Error('Deadline exceeded');\n  err.code = constants_1.Status.DEADLINE_EXCEEDED;\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}","map":{"version":3,"names":["events_1","require","http2","stream_1","zlib","util_1","constants_1","metadata_1","stream_decoder_1","logging","error_1","TRACER_NAME","unzip","promisify","inflate","trace","text","LogVerbosity","DEBUG","GRPC_ACCEPT_ENCODING_HEADER","GRPC_ENCODING_HEADER","GRPC_MESSAGE_HEADER","GRPC_STATUS_HEADER","GRPC_TIMEOUT_HEADER","DEADLINE_REGEX","deadlineUnitsToMs","H","M","S","m","u","n","defaultCompressionHeaders","defaultResponseHeaders","constants","HTTP2_HEADER_STATUS","HTTP_STATUS_OK","HTTP2_HEADER_CONTENT_TYPE","defaultResponseOptions","waitForTrailers","ServerUnaryCallImpl","EventEmitter","constructor","call","metadata","request","cancelled","setupSurfaceCall","getPeer","sendMetadata","responseMetadata","getDeadline","getPath","exports","ServerReadableStreamImpl","Readable","deserialize","encoding","objectMode","setupReadable","_read","size","consumeUnpushedMessages","resume","ServerWritableStreamImpl","Writable","serialize","trailingMetadata","Metadata","on","err","sendError","end","_write","chunk","callback","response","serializeMessage","write","once","emit","details","getErrorMessage","code","Status","INTERNAL","_final","sendStatus","OK","ServerDuplexStreamImpl","Duplex","prototype","Http2ServerCallStream","stream","handler","options","deadlineTimer","statusSent","deadline","Infinity","wantTrailers","metadataSent","canPush","isPushPending","bufferedMessages","messagesToPush","maxSendMessageSize","DEFAULT_MAX_SEND_MESSAGE_LENGTH","maxReceiveMessageSize","DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH","_a","path","rstCode","CANCELLED","checkCancelled","destroyed","closed","getDecompressedMessage","message","subarray","Promise","reject","UNIMPLEMENTED","customMetadata","custom","toHttp2Headers","headers","Object","assign","respond","receiveMetadata","fromHttp2Headers","isTracerEnabled","JSON","stringify","toJSON","timeoutHeader","get","length","match","toString","Error","OUT_OF_RANGE","timeout","now","Date","setMilliseconds","getMilliseconds","setTimeout","handleExpiredDeadline","remove","HTTP2_HEADER_ACCEPT_ENCODING","HTTP2_HEADER_TE","receiveUnaryMessage","next","receivedLength","body","limit","onData","onEnd","byteLength","removeListener","RESOURCE_EXHAUSTED","push","undefined","requestBytes","Buffer","concat","compressed","readUInt8","compressedMessageEncoding","decompressedMessage","isBuffer","safeDeserializeMessage","then","decompressed","buffer","deserializeMessage","value","messageBuffer","output","allocUnsafe","writeUInt8","writeUInt32BE","copy","bytes","sendUnaryMessage","flags","hasOwnProperty","statusObj","clearTimeout","headersSent","trailersToSend","encodeURI","sendTrailers","_b","endStream","error","status","UNKNOWN","Number","isInteger","reason","readable","decoder","StreamDecoder","readsDone","pendingMessageProcessing","pushedEnd","maybePushEnd","pushOrBufferMessage","data","messages","pause","nextMessage","shift","messageBytes","pushMessage","deserialized","getErrorCode","UNAUTHENTICATED","socket","session","remoteAddress","remotePort","DEADLINE_EXCEEDED"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/server-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { EventEmitter } from 'events';\nimport * as http2 from 'http2';\nimport { Duplex, Readable, Writable } from 'stream';\nimport * as zlib from 'zlib';\nimport { promisify } from 'util';\n\nimport {\n  Status,\n  DEFAULT_MAX_SEND_MESSAGE_LENGTH,\n  DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH,\n  LogVerbosity,\n} from './constants';\nimport { Deserialize, Serialize } from './make-client';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport { ObjectReadable, ObjectWritable } from './object-stream';\nimport { ChannelOptions } from './channel-options';\nimport * as logging from './logging';\nimport { StatusObject, PartialStatusObject } from './call-interface';\nimport { Deadline } from './deadline';\nimport { getErrorCode, getErrorMessage } from './error';\n\nconst TRACER_NAME = 'server_call';\nconst unzip = promisify(zlib.unzip);\nconst inflate = promisify(zlib.inflate);\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface DeadlineUnitIndexSignature {\n  [name: string]: number;\n}\n\nconst GRPC_ACCEPT_ENCODING_HEADER = 'grpc-accept-encoding';\nconst GRPC_ENCODING_HEADER = 'grpc-encoding';\nconst GRPC_MESSAGE_HEADER = 'grpc-message';\nconst GRPC_STATUS_HEADER = 'grpc-status';\nconst GRPC_TIMEOUT_HEADER = 'grpc-timeout';\nconst DEADLINE_REGEX = /(\\d{1,8})\\s*([HMSmun])/;\nconst deadlineUnitsToMs: DeadlineUnitIndexSignature = {\n  H: 3600000,\n  M: 60000,\n  S: 1000,\n  m: 1,\n  u: 0.001,\n  n: 0.000001,\n};\nconst defaultCompressionHeaders = {\n  // TODO(cjihrig): Remove these encoding headers from the default response\n  // once compression is integrated.\n  [GRPC_ACCEPT_ENCODING_HEADER]: 'identity,deflate,gzip',\n  [GRPC_ENCODING_HEADER]: 'identity',\n}\nconst defaultResponseHeaders = {\n  [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,\n  [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: 'application/grpc+proto',\n};\nconst defaultResponseOptions = {\n  waitForTrailers: true,\n} as http2.ServerStreamResponseOptions;\n\nexport type ServerStatusResponse = Partial<StatusObject>;\n\nexport type ServerErrorResponse = ServerStatusResponse & Error;\n\nexport type ServerSurfaceCall = {\n  cancelled: boolean;\n  readonly metadata: Metadata;\n  getPeer(): string;\n  sendMetadata(responseMetadata: Metadata): void;\n  getDeadline(): Deadline;\n  getPath(): string;\n} & EventEmitter;\n\nexport type ServerUnaryCall<RequestType, ResponseType> = ServerSurfaceCall & {\n  request: RequestType;\n};\nexport type ServerReadableStream<RequestType, ResponseType> =\n  ServerSurfaceCall & ObjectReadable<RequestType>;\nexport type ServerWritableStream<RequestType, ResponseType> =\n  ServerSurfaceCall &\n    ObjectWritable<ResponseType> & {\n      request: RequestType;\n      end: (metadata?: Metadata) => void;\n    };\nexport type ServerDuplexStream<RequestType, ResponseType> = ServerSurfaceCall &\n  ObjectReadable<RequestType> &\n  ObjectWritable<ResponseType> & { end: (metadata?: Metadata) => void };\n\nexport class ServerUnaryCallImpl<RequestType, ResponseType>\n  extends EventEmitter\n  implements ServerUnaryCall<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public request: RequestType\n  ) {\n    super();\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerReadableStreamImpl<RequestType, ResponseType>\n  extends Readable\n  implements ServerReadableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n  }\n\n  _read(size: number) {\n    if (!this.call.consumeUnpushedMessages(this)) {\n      return;\n    }\n\n    this.call.resume();\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n}\n\nexport class ServerWritableStreamImpl<RequestType, ResponseType>\n  extends Writable\n  implements ServerWritableStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public request: RequestType\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  _write(\n    chunk: ResponseType,\n    encoding: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (...args: any[]) => void\n  ) {\n    try {\n      const response = this.call.serializeMessage(chunk);\n\n      if (!this.call.write(response)) {\n        this.call.once('drain', callback);\n        return;\n      }\n    } catch (err) {\n      this.emit('error', {\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n\n    callback();\n  }\n\n  _final(callback: Function): void {\n    this.call.sendStatus({\n      code: Status.OK,\n      details: 'OK',\n      metadata: this.trailingMetadata,\n    });\n    callback(null);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nexport class ServerDuplexStreamImpl<RequestType, ResponseType>\n  extends Duplex\n  implements ServerDuplexStream<RequestType, ResponseType>\n{\n  cancelled: boolean;\n  private trailingMetadata: Metadata;\n\n  constructor(\n    private call: Http2ServerCallStream<RequestType, ResponseType>,\n    public metadata: Metadata,\n    public serialize: Serialize<ResponseType>,\n    public deserialize: Deserialize<RequestType>,\n    encoding: string\n  ) {\n    super({ objectMode: true });\n    this.cancelled = false;\n    this.trailingMetadata = new Metadata();\n    this.call.setupSurfaceCall(this);\n    this.call.setupReadable(this, encoding);\n\n    this.on('error', (err) => {\n      this.call.sendError(err);\n      this.end();\n    });\n  }\n\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n\n  sendMetadata(responseMetadata: Metadata): void {\n    this.call.sendMetadata(responseMetadata);\n  }\n\n  getDeadline(): Deadline {\n    return this.call.getDeadline();\n  }\n\n  getPath(): string {\n    return this.call.getPath();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  end(metadata?: any) {\n    if (metadata) {\n      this.trailingMetadata = metadata;\n    }\n\n    return super.end();\n  }\n}\n\nServerDuplexStreamImpl.prototype._read =\n  ServerReadableStreamImpl.prototype._read;\nServerDuplexStreamImpl.prototype._write =\n  ServerWritableStreamImpl.prototype._write;\nServerDuplexStreamImpl.prototype._final =\n  ServerWritableStreamImpl.prototype._final;\n\n// Unary response callback signature.\nexport type sendUnaryData<ResponseType> = (\n  error: ServerErrorResponse | ServerStatusResponse | null,\n  value?: ResponseType | null,\n  trailer?: Metadata,\n  flags?: number\n) => void;\n\n// User provided handler for unary calls.\nexport type handleUnaryCall<RequestType, ResponseType> = (\n  call: ServerUnaryCall<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for client streaming calls.\nexport type handleClientStreamingCall<RequestType, ResponseType> = (\n  call: ServerReadableStream<RequestType, ResponseType>,\n  callback: sendUnaryData<ResponseType>\n) => void;\n\n// User provided handler for server streaming calls.\nexport type handleServerStreamingCall<RequestType, ResponseType> = (\n  call: ServerWritableStream<RequestType, ResponseType>\n) => void;\n\n// User provided handler for bidirectional streaming calls.\nexport type handleBidiStreamingCall<RequestType, ResponseType> = (\n  call: ServerDuplexStream<RequestType, ResponseType>\n) => void;\n\nexport type HandleCall<RequestType, ResponseType> =\n  | handleUnaryCall<RequestType, ResponseType>\n  | handleClientStreamingCall<RequestType, ResponseType>\n  | handleServerStreamingCall<RequestType, ResponseType>\n  | handleBidiStreamingCall<RequestType, ResponseType>;\n\nexport interface UnaryHandler<RequestType, ResponseType> {\n  func: handleUnaryCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ClientStreamingHandler<RequestType, ResponseType> {\n  func: handleClientStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface ServerStreamingHandler<RequestType, ResponseType> {\n  func: handleServerStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport interface BidiStreamingHandler<RequestType, ResponseType> {\n  func: handleBidiStreamingCall<RequestType, ResponseType>;\n  serialize: Serialize<ResponseType>;\n  deserialize: Deserialize<RequestType>;\n  type: HandlerType;\n  path: string;\n}\n\nexport type Handler<RequestType, ResponseType> =\n  | UnaryHandler<RequestType, ResponseType>\n  | ClientStreamingHandler<RequestType, ResponseType>\n  | ServerStreamingHandler<RequestType, ResponseType>\n  | BidiStreamingHandler<RequestType, ResponseType>;\n\nexport type HandlerType = 'bidi' | 'clientStream' | 'serverStream' | 'unary';\n\n// Internal class that wraps the HTTP2 request.\nexport class Http2ServerCallStream<\n  RequestType,\n  ResponseType\n> extends EventEmitter {\n  cancelled = false;\n  deadlineTimer: NodeJS.Timer | null = null;\n  private statusSent = false;\n  private deadline: Deadline = Infinity;\n  private wantTrailers = false;\n  private metadataSent = false;\n  private canPush = false;\n  private isPushPending = false;\n  private bufferedMessages: Array<Buffer | null> = [];\n  private messagesToPush: Array<RequestType | null> = [];\n  private maxSendMessageSize: number = DEFAULT_MAX_SEND_MESSAGE_LENGTH;\n  private maxReceiveMessageSize: number = DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;\n\n  constructor(\n    private stream: http2.ServerHttp2Stream,\n    private handler: Handler<RequestType, ResponseType>,\n    private options: ChannelOptions\n  ) {\n    super();\n\n    this.stream.once('error', (err: ServerErrorResponse) => {\n      /* We need an error handler to avoid uncaught error event exceptions, but\n       * there is nothing we can reasonably do here. Any error event should\n       * have a corresponding close event, which handles emitting the cancelled\n       * event. And the stream is now in a bad state, so we can't reasonably\n       * expect to be able to send an error over it. */\n    });\n\n    this.stream.once('close', () => {\n      trace(\n        'Request to method ' +\n          this.handler?.path +\n          ' stream closed with rstCode ' +\n          this.stream.rstCode\n      );\n\n      if (!this.statusSent) {\n        this.cancelled = true;\n        this.emit('cancelled', 'cancelled');\n        this.emit('streamEnd', false);\n        this.sendStatus({\n          code: Status.CANCELLED,\n          details: 'Cancelled by client',\n          metadata: null,\n        });\n      }\n    });\n\n    this.stream.on('drain', () => {\n      this.emit('drain');\n    });\n\n    if ('grpc.max_send_message_length' in options) {\n      this.maxSendMessageSize = options['grpc.max_send_message_length']!;\n    }\n    if ('grpc.max_receive_message_length' in options) {\n      this.maxReceiveMessageSize = options['grpc.max_receive_message_length']!;\n    }\n  }\n\n  private checkCancelled(): boolean {\n    /* In some cases the stream can become destroyed before the close event\n     * fires. That creates a race condition that this check works around */\n    if (this.stream.destroyed || this.stream.closed) {\n      this.cancelled = true;\n    }\n    return this.cancelled;\n  }\n\n  private getDecompressedMessage(\n    message: Buffer,\n    encoding: string\n  ): Buffer | Promise<Buffer> {\n    if (encoding === 'deflate') {\n      return inflate(message.subarray(5));\n    } else if (encoding === 'gzip') {\n      return unzip(message.subarray(5));\n    } else if (encoding === 'identity') {\n      return message.subarray(5);\n    }\n\n    return Promise.reject({\n      code: Status.UNIMPLEMENTED,\n      details: `Received message compressed with unsupported encoding \"${encoding}\"`,\n    });\n  }\n\n  sendMetadata(customMetadata?: Metadata) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (this.metadataSent) {\n      return;\n    }\n\n    this.metadataSent = true;\n    const custom = customMetadata ? customMetadata.toHttp2Headers() : null;\n    // TODO(cjihrig): Include compression headers.\n    const headers = { ...defaultResponseHeaders, ...defaultCompressionHeaders, ...custom };\n    this.stream.respond(headers, defaultResponseOptions);\n  }\n\n  receiveMetadata(headers: http2.IncomingHttpHeaders) {\n    const metadata = Metadata.fromHttp2Headers(headers);\n\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      trace(\n        'Request to ' +\n          this.handler.path +\n          ' received headers ' +\n          JSON.stringify(metadata.toJSON())\n      );\n    }\n\n    // TODO(cjihrig): Receive compression metadata.\n\n    const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);\n\n    if (timeoutHeader.length > 0) {\n      const match = timeoutHeader[0].toString().match(DEADLINE_REGEX);\n\n      if (match === null) {\n        const err = new Error('Invalid deadline') as ServerErrorResponse;\n        err.code = Status.OUT_OF_RANGE;\n        this.sendError(err);\n        return metadata;\n      }\n\n      const timeout = (+match[1] * deadlineUnitsToMs[match[2]]) | 0;\n\n      const now = new Date();\n      this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);\n      this.deadlineTimer = setTimeout(handleExpiredDeadline, timeout, this);\n      metadata.remove(GRPC_TIMEOUT_HEADER);\n    }\n\n    // Remove several headers that should not be propagated to the application\n    metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);\n    metadata.remove(http2.constants.HTTP2_HEADER_TE);\n    metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);\n    metadata.remove('grpc-accept-encoding');\n\n    return metadata;\n  }\n\n  receiveUnaryMessage(\n    encoding: string,\n    next: (\n      err: Partial<ServerStatusResponse> | null,\n      request?: RequestType\n    ) => void\n  ): void {\n    const { stream } = this;\n\n    let receivedLength = 0;\n    const call = this;\n    const body: Buffer[] = [];\n    const limit = this.maxReceiveMessageSize;\n\n    stream.on('data', onData);\n    stream.on('end', onEnd);\n    stream.on('error', onEnd);\n\n    function onData(chunk: Buffer) {\n      receivedLength += chunk.byteLength;\n\n      if (limit !== -1 && receivedLength > limit) {\n        stream.removeListener('data', onData);\n        stream.removeListener('end', onEnd);\n        stream.removeListener('error', onEnd);\n        next({\n          code: Status.RESOURCE_EXHAUSTED,\n          details: `Received message larger than max (${receivedLength} vs. ${limit})`,\n        });\n        return;\n      }\n\n      body.push(chunk);\n    }\n\n    function onEnd(err?: Error) {\n      stream.removeListener('data', onData);\n      stream.removeListener('end', onEnd);\n      stream.removeListener('error', onEnd);\n\n      if (err !== undefined) {\n        next({ code: Status.INTERNAL, details: err.message });\n        return;\n      }\n\n      if (receivedLength === 0) {\n        next({ code: Status.INTERNAL, details: 'received empty unary message' })\n        return;\n      }\n\n      call.emit('receiveMessage');\n\n      const requestBytes = Buffer.concat(body, receivedLength);\n      const compressed = requestBytes.readUInt8(0) === 1;\n      const compressedMessageEncoding = compressed ? encoding : 'identity';\n      const decompressedMessage = call.getDecompressedMessage(\n        requestBytes,\n        compressedMessageEncoding\n      );\n\n      if (Buffer.isBuffer(decompressedMessage)) {\n        call.safeDeserializeMessage(decompressedMessage, next);\n        return;\n      }\n\n      decompressedMessage.then(\n        (decompressed) => call.safeDeserializeMessage(decompressed, next),\n        (err: any) => next(\n          err.code\n            ? err\n            : {\n                code: Status.INTERNAL,\n                details: `Received \"grpc-encoding\" header \"${encoding}\" but ${encoding} decompression failed`,\n              }\n        )\n      )\n    }\n  }\n\n  private safeDeserializeMessage(\n    buffer: Buffer,\n    next: (err: Partial<ServerStatusResponse> | null, request?: RequestType) => void\n  ) {\n    try {\n      next(null, this.deserializeMessage(buffer));\n    } catch (err) {\n      next({\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n  }\n\n  serializeMessage(value: ResponseType) {\n    const messageBuffer = this.handler.serialize(value);\n\n    // TODO(cjihrig): Call compression aware serializeMessage().\n    const byteLength = messageBuffer.byteLength;\n    const output = Buffer.allocUnsafe(byteLength + 5);\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(byteLength, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n\n  deserializeMessage(bytes: Buffer) {\n    return this.handler.deserialize(bytes);\n  }\n\n  async sendUnaryMessage(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    metadata?: Metadata | null,\n    flags?: number\n  ) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (metadata === undefined) {\n      metadata = null;\n    }\n\n    if (err) {\n      if (!Object.prototype.hasOwnProperty.call(err, 'metadata') && metadata) {\n        err.metadata = metadata;\n      }\n      this.sendError(err);\n      return;\n    }\n\n    try {\n      const response = this.serializeMessage(value!);\n\n      this.write(response);\n      this.sendStatus({ code: Status.OK, details: 'OK', metadata });\n    } catch (err) {\n      this.sendError({\n        details: getErrorMessage(err),\n        code: Status.INTERNAL\n      });\n    }\n  }\n\n  sendStatus(statusObj: PartialStatusObject) {\n    this.emit('callEnd', statusObj.code);\n    this.emit('streamEnd', statusObj.code === Status.OK);\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    trace(\n      'Request to method ' +\n        this.handler?.path +\n        ' ended with status code: ' +\n        Status[statusObj.code] +\n        ' details: ' +\n        statusObj.details\n    );\n\n    if (this.deadlineTimer) clearTimeout(this.deadlineTimer);\n\n    if (this.stream.headersSent) {\n      if (!this.wantTrailers) {\n        this.wantTrailers = true;\n        this.stream.once('wantTrailers', () => {\n          const trailersToSend = {\n            [GRPC_STATUS_HEADER]: statusObj.code,\n            [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n            ...statusObj.metadata?.toHttp2Headers(),\n          };\n  \n          this.stream.sendTrailers(trailersToSend);\n          this.statusSent = true;\n        });\n        this.stream.end();\n      }\n    } else {\n      // Trailers-only response\n      const trailersToSend = {\n        [GRPC_STATUS_HEADER]: statusObj.code,\n        [GRPC_MESSAGE_HEADER]: encodeURI(statusObj.details),\n        ...defaultResponseHeaders,\n        ...statusObj.metadata?.toHttp2Headers(),\n      };\n      this.stream.respond(trailersToSend, {endStream: true});\n      this.statusSent = true;\n    }\n  }\n\n  sendError(error: ServerErrorResponse | ServerStatusResponse) {\n    const status: PartialStatusObject = {\n      code: Status.UNKNOWN,\n      details: 'message' in error ? error.message : 'Unknown Error',\n      metadata:\n        'metadata' in error && error.metadata !== undefined\n          ? error.metadata\n          : null,\n    };\n\n    if (\n      'code' in error &&\n      typeof error.code === 'number' &&\n      Number.isInteger(error.code)\n    ) {\n      status.code = error.code;\n\n      if ('details' in error && typeof error.details === 'string') {\n        status.details = error.details!;\n      }\n    }\n\n    this.sendStatus(status);\n  }\n\n  write(chunk: Buffer) {\n    if (this.checkCancelled()) {\n      return;\n    }\n\n    if (\n      this.maxSendMessageSize !== -1 &&\n      chunk.length > this.maxSendMessageSize\n    ) {\n      this.sendError({\n        code: Status.RESOURCE_EXHAUSTED,\n        details: `Sent message larger than max (${chunk.length} vs. ${this.maxSendMessageSize})`,\n      });\n      return;\n    }\n\n    this.sendMetadata();\n    this.emit('sendMessage');\n    return this.stream.write(chunk);\n  }\n\n  resume() {\n    this.stream.resume();\n  }\n\n  setupSurfaceCall(call: ServerSurfaceCall) {\n    this.once('cancelled', (reason) => {\n      call.cancelled = true;\n      call.emit('cancelled', reason);\n    });\n\n    this.once('callEnd', (status) => call.emit('callEnd', status));\n  }\n\n  setupReadable(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    encoding: string\n  ) {\n    const decoder = new StreamDecoder();\n\n    let readsDone = false;\n\n    let pendingMessageProcessing = false;\n\n    let pushedEnd = false;\n\n    const maybePushEnd = async () => {\n      if (!pushedEnd && readsDone && !pendingMessageProcessing) {\n        pushedEnd = true;\n        await this.pushOrBufferMessage(readable, null);\n      }\n    };\n\n    this.stream.on('data', async (data: Buffer) => {\n      const messages = decoder.write(data);\n\n      pendingMessageProcessing = true;\n      this.stream.pause();\n      for (const message of messages) {\n        if (\n          this.maxReceiveMessageSize !== -1 &&\n          message.length > this.maxReceiveMessageSize\n        ) {\n          this.sendError({\n            code: Status.RESOURCE_EXHAUSTED,\n            details: `Received message larger than max (${message.length} vs. ${this.maxReceiveMessageSize})`,\n          });\n          return;\n        }\n        this.emit('receiveMessage');\n\n        const compressed = message.readUInt8(0) === 1;\n        const compressedMessageEncoding = compressed ? encoding : 'identity';\n        const decompressedMessage = await this.getDecompressedMessage(\n          message,\n          compressedMessageEncoding\n        );\n\n        // Encountered an error with decompression; it'll already have been propogated back\n        // Just return early\n        if (!decompressedMessage) return;\n\n        await this.pushOrBufferMessage(readable, decompressedMessage);\n      }\n      pendingMessageProcessing = false;\n      this.stream.resume();\n      await maybePushEnd();\n    });\n\n    this.stream.once('end', async () => {\n      readsDone = true;\n      await maybePushEnd();\n    });\n  }\n\n  consumeUnpushedMessages(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>\n  ): boolean {\n    this.canPush = true;\n\n    while (this.messagesToPush.length > 0) {\n      const nextMessage = this.messagesToPush.shift();\n      const canPush = readable.push(nextMessage);\n\n      if (nextMessage === null || canPush === false) {\n        this.canPush = false;\n        break;\n      }\n    }\n\n    return this.canPush;\n  }\n\n  private async pushOrBufferMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ): Promise<void> {\n    if (this.isPushPending) {\n      this.bufferedMessages.push(messageBytes);\n    } else {\n      await this.pushMessage(readable, messageBytes);\n    }\n  }\n\n  private async pushMessage(\n    readable:\n      | ServerReadableStream<RequestType, ResponseType>\n      | ServerDuplexStream<RequestType, ResponseType>,\n    messageBytes: Buffer | null\n  ) {\n    if (messageBytes === null) {\n      trace('Received end of stream');\n      if (this.canPush) {\n        readable.push(null);\n      } else {\n        this.messagesToPush.push(null);\n      }\n\n      return;\n    }\n\n    trace('Received message of length ' + messageBytes.length);\n\n    this.isPushPending = true;\n\n    try {\n      const deserialized = await this.deserializeMessage(messageBytes);\n\n      if (this.canPush) {\n        if (!readable.push(deserialized)) {\n          this.canPush = false;\n          this.stream.pause();\n        }\n      } else {\n        this.messagesToPush.push(deserialized);\n      }\n    } catch (error) {\n      // Ignore any remaining messages when errors occur.\n      this.bufferedMessages.length = 0;\n      let code = getErrorCode(error);\n      if (code === null || code < Status.OK || code > Status.UNAUTHENTICATED) {\n        code = Status.INTERNAL\n      }\n\n      readable.emit('error', {\n        details: getErrorMessage(error),\n        code: code\n      });\n    }\n\n    this.isPushPending = false;\n\n    if (this.bufferedMessages.length > 0) {\n      await this.pushMessage(\n        readable,\n        this.bufferedMessages.shift() as Buffer | null\n      );\n    }\n  }\n\n  getPeer(): string {\n    const socket = this.stream.session.socket;\n    if (socket.remoteAddress) {\n      if (socket.remotePort) {\n        return `${socket.remoteAddress}:${socket.remotePort}`;\n      } else {\n        return socket.remoteAddress;\n      }\n    } else {\n      return 'unknown';\n    }\n  }\n\n  getDeadline(): Deadline {\n    return this.deadline;\n  }\n\n  getPath(): string {\n    return this.handler.path;\n  }\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedServerCall = Http2ServerCallStream<any, any>;\n\nfunction handleExpiredDeadline(call: UntypedServerCall) {\n  const err = new Error('Deadline exceeded') as ServerErrorResponse;\n  err.code = Status.DEADLINE_EXCEEDED;\n\n  call.sendError(err);\n  call.cancelled = true;\n  call.emit('cancelled', 'deadline');\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,KAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,IAAA,GAAAH,OAAA;AACA,MAAAI,MAAA,GAAAJ,OAAA;AAEA,MAAAK,WAAA,GAAAL,OAAA;AAOA,MAAAM,UAAA,GAAAN,OAAA;AACA,MAAAO,gBAAA,GAAAP,OAAA;AAGA,MAAAQ,OAAA,GAAAR,OAAA;AAGA,MAAAS,OAAA,GAAAT,OAAA;AAEA,MAAMU,WAAW,GAAG,aAAa;AACjC,MAAMC,KAAK,GAAG,IAAAP,MAAA,CAAAQ,SAAS,EAACT,IAAI,CAACQ,KAAK,CAAC;AACnC,MAAME,OAAO,GAAG,IAAAT,MAAA,CAAAQ,SAAS,EAACT,IAAI,CAACU,OAAO,CAAC;AAEvC,SAASC,KAAKA,CAACC,IAAY;EACzBP,OAAO,CAACM,KAAK,CAACT,WAAA,CAAAW,YAAY,CAACC,KAAK,EAAEP,WAAW,EAAEK,IAAI,CAAC;AACtD;AAMA,MAAMG,2BAA2B,GAAG,sBAAsB;AAC1D,MAAMC,oBAAoB,GAAG,eAAe;AAC5C,MAAMC,mBAAmB,GAAG,cAAc;AAC1C,MAAMC,kBAAkB,GAAG,aAAa;AACxC,MAAMC,mBAAmB,GAAG,cAAc;AAC1C,MAAMC,cAAc,GAAG,wBAAwB;AAC/C,MAAMC,iBAAiB,GAA+B;EACpDC,CAAC,EAAE,OAAO;EACVC,CAAC,EAAE,KAAK;EACRC,CAAC,EAAE,IAAI;EACPC,CAAC,EAAE,CAAC;EACJC,CAAC,EAAE,KAAK;EACRC,CAAC,EAAE;CACJ;AACD,MAAMC,yBAAyB,GAAG;EAChC;EACA;EACA,CAACb,2BAA2B,GAAG,uBAAuB;EACtD,CAACC,oBAAoB,GAAG;CACzB;AACD,MAAMa,sBAAsB,GAAG;EAC7B,CAAC/B,KAAK,CAACgC,SAAS,CAACC,mBAAmB,GAAGjC,KAAK,CAACgC,SAAS,CAACE,cAAc;EACrE,CAAClC,KAAK,CAACgC,SAAS,CAACG,yBAAyB,GAAG;CAC9C;AACD,MAAMC,sBAAsB,GAAG;EAC7BC,eAAe,EAAE;CACmB;AA8BtC,MAAaC,mBACX,SAAQxC,QAAA,CAAAyC,YAAY;EAKpBC,YACUC,IAAsD,EACvDC,QAAkB,EAClBC,OAAoB;IAE3B,KAAK,EAAE;IAJC,KAAAF,IAAI,GAAJA,IAAI;IACL,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAC,OAAO,GAAPA,OAAO;IAGd,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACH,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC;EAClC;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACL,IAAI,CAACK,OAAO,EAAE;EAC5B;EAEAC,YAAYA,CAACC,gBAA0B;IACrC,IAAI,CAACP,IAAI,CAACM,YAAY,CAACC,gBAAgB,CAAC;EAC1C;EAEAC,WAAWA,CAAA;IACT,OAAO,IAAI,CAACR,IAAI,CAACQ,WAAW,EAAE;EAChC;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACT,IAAI,CAACS,OAAO,EAAE;EAC5B;;AA9BFC,OAAA,CAAAb,mBAAA,GAAAA,mBAAA;AAiCA,MAAac,wBACX,SAAQnD,QAAA,CAAAoD,QAAQ;EAKhBb,YACUC,IAAsD,EACvDC,QAAkB,EAClBY,WAAqC,EAC5CC,QAAgB;IAEhB,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAI,CAAE,CAAC;IALnB,KAAAf,IAAI,GAAJA,IAAI;IACL,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAY,WAAW,GAAXA,WAAW;IAIlB,IAAI,CAACV,SAAS,GAAG,KAAK;IACtB,IAAI,CAACH,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC;IAChC,IAAI,CAACJ,IAAI,CAACgB,aAAa,CAAC,IAAI,EAAEF,QAAQ,CAAC;EACzC;EAEAG,KAAKA,CAACC,IAAY;IAChB,IAAI,CAAC,IAAI,CAAClB,IAAI,CAACmB,uBAAuB,CAAC,IAAI,CAAC,EAAE;MAC5C;;IAGF,IAAI,CAACnB,IAAI,CAACoB,MAAM,EAAE;EACpB;EAEAf,OAAOA,CAAA;IACL,OAAO,IAAI,CAACL,IAAI,CAACK,OAAO,EAAE;EAC5B;EAEAC,YAAYA,CAACC,gBAA0B;IACrC,IAAI,CAACP,IAAI,CAACM,YAAY,CAACC,gBAAgB,CAAC;EAC1C;EAEAC,WAAWA,CAAA;IACT,OAAO,IAAI,CAACR,IAAI,CAACQ,WAAW,EAAE;EAChC;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACT,IAAI,CAACS,OAAO,EAAE;EAC5B;;AAxCFC,OAAA,CAAAC,wBAAA,GAAAA,wBAAA;AA2CA,MAAaU,wBACX,SAAQ7D,QAAA,CAAA8D,QAAQ;EAMhBvB,YACUC,IAAsD,EACvDC,QAAkB,EAClBsB,SAAkC,EAClCrB,OAAoB;IAE3B,KAAK,CAAC;MAAEa,UAAU,EAAE;IAAI,CAAE,CAAC;IALnB,KAAAf,IAAI,GAAJA,IAAI;IACL,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAsB,SAAS,GAATA,SAAS;IACT,KAAArB,OAAO,GAAPA,OAAO;IAGd,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB,IAAI,CAACqB,gBAAgB,GAAG,IAAI5D,UAAA,CAAA6D,QAAQ,EAAE;IACtC,IAAI,CAACzB,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC;IAEhC,IAAI,CAACsB,EAAE,CAAC,OAAO,EAAGC,GAAG,IAAI;MACvB,IAAI,CAAC3B,IAAI,CAAC4B,SAAS,CAACD,GAAG,CAAC;MACxB,IAAI,CAACE,GAAG,EAAE;IACZ,CAAC,CAAC;EACJ;EAEAxB,OAAOA,CAAA;IACL,OAAO,IAAI,CAACL,IAAI,CAACK,OAAO,EAAE;EAC5B;EAEAC,YAAYA,CAACC,gBAA0B;IACrC,IAAI,CAACP,IAAI,CAACM,YAAY,CAACC,gBAAgB,CAAC;EAC1C;EAEAC,WAAWA,CAAA;IACT,OAAO,IAAI,CAACR,IAAI,CAACQ,WAAW,EAAE;EAChC;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACT,IAAI,CAACS,OAAO,EAAE;EAC5B;EAEAqB,MAAMA,CACJC,KAAmB,EACnBjB,QAAgB;EAChB;EACAkB,QAAkC;IAElC,IAAI;MACF,MAAMC,QAAQ,GAAG,IAAI,CAACjC,IAAI,CAACkC,gBAAgB,CAACH,KAAK,CAAC;MAElD,IAAI,CAAC,IAAI,CAAC/B,IAAI,CAACmC,KAAK,CAACF,QAAQ,CAAC,EAAE;QAC9B,IAAI,CAACjC,IAAI,CAACoC,IAAI,CAAC,OAAO,EAAEJ,QAAQ,CAAC;QACjC;;KAEH,CAAC,OAAOL,GAAG,EAAE;MACZ,IAAI,CAACU,IAAI,CAAC,OAAO,EAAE;QACjBC,OAAO,EAAE,IAAAvE,OAAA,CAAAwE,eAAe,EAACZ,GAAG,CAAC;QAC7Ba,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC;OACd,CAAC;;IAGJV,QAAQ,EAAE;EACZ;EAEAW,MAAMA,CAACX,QAAkB;IACvB,IAAI,CAAChC,IAAI,CAAC4C,UAAU,CAAC;MACnBJ,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACI,EAAE;MACfP,OAAO,EAAE,IAAI;MACbrC,QAAQ,EAAE,IAAI,CAACuB;KAChB,CAAC;IACFQ,QAAQ,CAAC,IAAI,CAAC;EAChB;EAEA;EACAH,GAAGA,CAAC5B,QAAc;IAChB,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACuB,gBAAgB,GAAGvB,QAAQ;;IAGlC,OAAO,KAAK,CAAC4B,GAAG,EAAE;EACpB;;AA/EFnB,OAAA,CAAAW,wBAAA,GAAAA,wBAAA;AAkFA,MAAayB,sBACX,SAAQtF,QAAA,CAAAuF,MAAM;EAMdhD,YACUC,IAAsD,EACvDC,QAAkB,EAClBsB,SAAkC,EAClCV,WAAqC,EAC5CC,QAAgB;IAEhB,KAAK,CAAC;MAAEC,UAAU,EAAE;IAAI,CAAE,CAAC;IANnB,KAAAf,IAAI,GAAJA,IAAI;IACL,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAsB,SAAS,GAATA,SAAS;IACT,KAAAV,WAAW,GAAXA,WAAW;IAIlB,IAAI,CAACV,SAAS,GAAG,KAAK;IACtB,IAAI,CAACqB,gBAAgB,GAAG,IAAI5D,UAAA,CAAA6D,QAAQ,EAAE;IACtC,IAAI,CAACzB,IAAI,CAACI,gBAAgB,CAAC,IAAI,CAAC;IAChC,IAAI,CAACJ,IAAI,CAACgB,aAAa,CAAC,IAAI,EAAEF,QAAQ,CAAC;IAEvC,IAAI,CAACY,EAAE,CAAC,OAAO,EAAGC,GAAG,IAAI;MACvB,IAAI,CAAC3B,IAAI,CAAC4B,SAAS,CAACD,GAAG,CAAC;MACxB,IAAI,CAACE,GAAG,EAAE;IACZ,CAAC,CAAC;EACJ;EAEAxB,OAAOA,CAAA;IACL,OAAO,IAAI,CAACL,IAAI,CAACK,OAAO,EAAE;EAC5B;EAEAC,YAAYA,CAACC,gBAA0B;IACrC,IAAI,CAACP,IAAI,CAACM,YAAY,CAACC,gBAAgB,CAAC;EAC1C;EAEAC,WAAWA,CAAA;IACT,OAAO,IAAI,CAACR,IAAI,CAACQ,WAAW,EAAE;EAChC;EAEAC,OAAOA,CAAA;IACL,OAAO,IAAI,CAACT,IAAI,CAACS,OAAO,EAAE;EAC5B;EAEA;EACAoB,GAAGA,CAAC5B,QAAc;IAChB,IAAIA,QAAQ,EAAE;MACZ,IAAI,CAACuB,gBAAgB,GAAGvB,QAAQ;;IAGlC,OAAO,KAAK,CAAC4B,GAAG,EAAE;EACpB;;AAjDFnB,OAAA,CAAAoC,sBAAA,GAAAA,sBAAA;AAoDAA,sBAAsB,CAACE,SAAS,CAAC/B,KAAK,GACpCN,wBAAwB,CAACqC,SAAS,CAAC/B,KAAK;AAC1C6B,sBAAsB,CAACE,SAAS,CAAClB,MAAM,GACrCT,wBAAwB,CAAC2B,SAAS,CAAClB,MAAM;AAC3CgB,sBAAsB,CAACE,SAAS,CAACL,MAAM,GACrCtB,wBAAwB,CAAC2B,SAAS,CAACL,MAAM;AA8E3C;AACA,MAAaM,qBAGX,SAAQ5F,QAAA,CAAAyC,YAAY;EAcpBC,YACUmD,MAA+B,EAC/BC,OAA2C,EAC3CC,OAAuB;IAE/B,KAAK,EAAE;IAJC,KAAAF,MAAM,GAANA,MAAM;IACN,KAAAC,OAAO,GAAPA,OAAO;IACP,KAAAC,OAAO,GAAPA,OAAO;IAhBjB,KAAAjD,SAAS,GAAG,KAAK;IACjB,KAAAkD,aAAa,GAAwB,IAAI;IACjC,KAAAC,UAAU,GAAG,KAAK;IAClB,KAAAC,QAAQ,GAAaC,QAAQ;IAC7B,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,YAAY,GAAG,KAAK;IACpB,KAAAC,OAAO,GAAG,KAAK;IACf,KAAAC,aAAa,GAAG,KAAK;IACrB,KAAAC,gBAAgB,GAAyB,EAAE;IAC3C,KAAAC,cAAc,GAA8B,EAAE;IAC9C,KAAAC,kBAAkB,GAAWpG,WAAA,CAAAqG,+BAA+B;IAC5D,KAAAC,qBAAqB,GAAWtG,WAAA,CAAAuG,kCAAkC;IASxE,IAAI,CAAChB,MAAM,CAACd,IAAI,CAAC,OAAO,EAAGT,GAAwB,IAAI;MACrD;;;;;IAAA,CAKD,CAAC;IAEF,IAAI,CAACuB,MAAM,CAACd,IAAI,CAAC,OAAO,EAAE,MAAK;;MAC7BhE,KAAK,CACH,oBAAoB,IAClB,CAAA+F,EAAA,OAAI,CAAChB,OAAO,cAAAgB,EAAA,uBAAAA,EAAA,CAAEC,IAAI,IAClB,8BAA8B,GAC9B,IAAI,CAAClB,MAAM,CAACmB,OAAO,CACtB;MAED,IAAI,CAAC,IAAI,CAACf,UAAU,EAAE;QACpB,IAAI,CAACnD,SAAS,GAAG,IAAI;QACrB,IAAI,CAACkC,IAAI,CAAC,WAAW,EAAE,WAAW,CAAC;QACnC,IAAI,CAACA,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC;QAC7B,IAAI,CAACO,UAAU,CAAC;UACdJ,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAAC6B,SAAS;UACtBhC,OAAO,EAAE,qBAAqB;UAC9BrC,QAAQ,EAAE;SACX,CAAC;;IAEN,CAAC,CAAC;IAEF,IAAI,CAACiD,MAAM,CAACxB,EAAE,CAAC,OAAO,EAAE,MAAK;MAC3B,IAAI,CAACW,IAAI,CAAC,OAAO,CAAC;IACpB,CAAC,CAAC;IAEF,IAAI,8BAA8B,IAAIe,OAAO,EAAE;MAC7C,IAAI,CAACW,kBAAkB,GAAGX,OAAO,CAAC,8BAA8B,CAAE;;IAEpE,IAAI,iCAAiC,IAAIA,OAAO,EAAE;MAChD,IAAI,CAACa,qBAAqB,GAAGb,OAAO,CAAC,iCAAiC,CAAE;;EAE5E;EAEQmB,cAAcA,CAAA;IACpB;;IAEA,IAAI,IAAI,CAACrB,MAAM,CAACsB,SAAS,IAAI,IAAI,CAACtB,MAAM,CAACuB,MAAM,EAAE;MAC/C,IAAI,CAACtE,SAAS,GAAG,IAAI;;IAEvB,OAAO,IAAI,CAACA,SAAS;EACvB;EAEQuE,sBAAsBA,CAC5BC,OAAe,EACf7D,QAAgB;IAEhB,IAAIA,QAAQ,KAAK,SAAS,EAAE;MAC1B,OAAO3C,OAAO,CAACwG,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;KACpC,MAAM,IAAI9D,QAAQ,KAAK,MAAM,EAAE;MAC9B,OAAO7C,KAAK,CAAC0G,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC,CAAC;KAClC,MAAM,IAAI9D,QAAQ,KAAK,UAAU,EAAE;MAClC,OAAO6D,OAAO,CAACC,QAAQ,CAAC,CAAC,CAAC;;IAG5B,OAAOC,OAAO,CAACC,MAAM,CAAC;MACpBtC,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACsC,aAAa;MAC1BzC,OAAO,EAAE,0DAA0DxB,QAAQ;KAC5E,CAAC;EACJ;EAEAR,YAAYA,CAAC0E,cAAyB;IACpC,IAAI,IAAI,CAACT,cAAc,EAAE,EAAE;MACzB;;IAGF,IAAI,IAAI,CAACb,YAAY,EAAE;MACrB;;IAGF,IAAI,CAACA,YAAY,GAAG,IAAI;IACxB,MAAMuB,MAAM,GAAGD,cAAc,GAAGA,cAAc,CAACE,cAAc,EAAE,GAAG,IAAI;IACtE;IACA,MAAMC,OAAO,GAAAC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAQ/F,sBAAsB,GAAKD,yBAAyB,GAAK4F,MAAM,CAAE;IACtF,IAAI,CAAC/B,MAAM,CAACoC,OAAO,CAACH,OAAO,EAAExF,sBAAsB,CAAC;EACtD;EAEA4F,eAAeA,CAACJ,OAAkC;IAChD,MAAMlF,QAAQ,GAAGrC,UAAA,CAAA6D,QAAQ,CAAC+D,gBAAgB,CAACL,OAAO,CAAC;IAEnD,IAAIrH,OAAO,CAAC2H,eAAe,CAACzH,WAAW,CAAC,EAAE;MACxCI,KAAK,CACH,aAAa,GACX,IAAI,CAAC+E,OAAO,CAACiB,IAAI,GACjB,oBAAoB,GACpBsB,IAAI,CAACC,SAAS,CAAC1F,QAAQ,CAAC2F,MAAM,EAAE,CAAC,CACpC;;IAGH;IAEA,MAAMC,aAAa,GAAG5F,QAAQ,CAAC6F,GAAG,CAAClH,mBAAmB,CAAC;IAEvD,IAAIiH,aAAa,CAACE,MAAM,GAAG,CAAC,EAAE;MAC5B,MAAMC,KAAK,GAAGH,aAAa,CAAC,CAAC,CAAC,CAACI,QAAQ,EAAE,CAACD,KAAK,CAACnH,cAAc,CAAC;MAE/D,IAAImH,KAAK,KAAK,IAAI,EAAE;QAClB,MAAMrE,GAAG,GAAG,IAAIuE,KAAK,CAAC,kBAAkB,CAAwB;QAChEvE,GAAG,CAACa,IAAI,GAAG7E,WAAA,CAAA8E,MAAM,CAAC0D,YAAY;QAC9B,IAAI,CAACvE,SAAS,CAACD,GAAG,CAAC;QACnB,OAAO1B,QAAQ;;MAGjB,MAAMmG,OAAO,GAAI,CAACJ,KAAK,CAAC,CAAC,CAAC,GAAGlH,iBAAiB,CAACkH,KAAK,CAAC,CAAC,CAAC,CAAC,GAAI,CAAC;MAE7D,MAAMK,GAAG,GAAG,IAAIC,IAAI,EAAE;MACtB,IAAI,CAAC/C,QAAQ,GAAG8C,GAAG,CAACE,eAAe,CAACF,GAAG,CAACG,eAAe,EAAE,GAAGJ,OAAO,CAAC;MACpE,IAAI,CAAC/C,aAAa,GAAGoD,UAAU,CAACC,qBAAqB,EAAEN,OAAO,EAAE,IAAI,CAAC;MACrEnG,QAAQ,CAAC0G,MAAM,CAAC/H,mBAAmB,CAAC;;IAGtC;IACAqB,QAAQ,CAAC0G,MAAM,CAACpJ,KAAK,CAACgC,SAAS,CAACqH,4BAA4B,CAAC;IAC7D3G,QAAQ,CAAC0G,MAAM,CAACpJ,KAAK,CAACgC,SAAS,CAACsH,eAAe,CAAC;IAChD5G,QAAQ,CAAC0G,MAAM,CAACpJ,KAAK,CAACgC,SAAS,CAACG,yBAAyB,CAAC;IAC1DO,QAAQ,CAAC0G,MAAM,CAAC,sBAAsB,CAAC;IAEvC,OAAO1G,QAAQ;EACjB;EAEA6G,mBAAmBA,CACjBhG,QAAgB,EAChBiG,IAGS;IAET,MAAM;MAAE7D;IAAM,CAAE,GAAG,IAAI;IAEvB,IAAI8D,cAAc,GAAG,CAAC;IACtB,MAAMhH,IAAI,GAAG,IAAI;IACjB,MAAMiH,IAAI,GAAa,EAAE;IACzB,MAAMC,KAAK,GAAG,IAAI,CAACjD,qBAAqB;IAExCf,MAAM,CAACxB,EAAE,CAAC,MAAM,EAAEyF,MAAM,CAAC;IACzBjE,MAAM,CAACxB,EAAE,CAAC,KAAK,EAAE0F,KAAK,CAAC;IACvBlE,MAAM,CAACxB,EAAE,CAAC,OAAO,EAAE0F,KAAK,CAAC;IAEzB,SAASD,MAAMA,CAACpF,KAAa;MAC3BiF,cAAc,IAAIjF,KAAK,CAACsF,UAAU;MAElC,IAAIH,KAAK,KAAK,CAAC,CAAC,IAAIF,cAAc,GAAGE,KAAK,EAAE;QAC1ChE,MAAM,CAACoE,cAAc,CAAC,MAAM,EAAEH,MAAM,CAAC;QACrCjE,MAAM,CAACoE,cAAc,CAAC,KAAK,EAAEF,KAAK,CAAC;QACnClE,MAAM,CAACoE,cAAc,CAAC,OAAO,EAAEF,KAAK,CAAC;QACrCL,IAAI,CAAC;UACHvE,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAAC8E,kBAAkB;UAC/BjF,OAAO,EAAE,qCAAqC0E,cAAc,QAAQE,KAAK;SAC1E,CAAC;QACF;;MAGFD,IAAI,CAACO,IAAI,CAACzF,KAAK,CAAC;IAClB;IAEA,SAASqF,KAAKA,CAACzF,GAAW;MACxBuB,MAAM,CAACoE,cAAc,CAAC,MAAM,EAAEH,MAAM,CAAC;MACrCjE,MAAM,CAACoE,cAAc,CAAC,KAAK,EAAEF,KAAK,CAAC;MACnClE,MAAM,CAACoE,cAAc,CAAC,OAAO,EAAEF,KAAK,CAAC;MAErC,IAAIzF,GAAG,KAAK8F,SAAS,EAAE;QACrBV,IAAI,CAAC;UAAEvE,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC,QAAQ;UAAEJ,OAAO,EAAEX,GAAG,CAACgD;QAAO,CAAE,CAAC;QACrD;;MAGF,IAAIqC,cAAc,KAAK,CAAC,EAAE;QACxBD,IAAI,CAAC;UAAEvE,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC,QAAQ;UAAEJ,OAAO,EAAE;QAA8B,CAAE,CAAC;QACxE;;MAGFtC,IAAI,CAACqC,IAAI,CAAC,gBAAgB,CAAC;MAE3B,MAAMqF,YAAY,GAAGC,MAAM,CAACC,MAAM,CAACX,IAAI,EAAED,cAAc,CAAC;MACxD,MAAMa,UAAU,GAAGH,YAAY,CAACI,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC;MAClD,MAAMC,yBAAyB,GAAGF,UAAU,GAAG/G,QAAQ,GAAG,UAAU;MACpE,MAAMkH,mBAAmB,GAAGhI,IAAI,CAAC0E,sBAAsB,CACrDgD,YAAY,EACZK,yBAAyB,CAC1B;MAED,IAAIJ,MAAM,CAACM,QAAQ,CAACD,mBAAmB,CAAC,EAAE;QACxChI,IAAI,CAACkI,sBAAsB,CAACF,mBAAmB,EAAEjB,IAAI,CAAC;QACtD;;MAGFiB,mBAAmB,CAACG,IAAI,CACrBC,YAAY,IAAKpI,IAAI,CAACkI,sBAAsB,CAACE,YAAY,EAAErB,IAAI,CAAC,EAChEpF,GAAQ,IAAKoF,IAAI,CAChBpF,GAAG,CAACa,IAAI,GACJb,GAAG,GACH;QACEa,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC,QAAQ;QACrBJ,OAAO,EAAE,oCAAoCxB,QAAQ,SAASA,QAAQ;OACvE,CACN,CACF;IACH;EACF;EAEQoH,sBAAsBA,CAC5BG,MAAc,EACdtB,IAAgF;IAEhF,IAAI;MACFA,IAAI,CAAC,IAAI,EAAE,IAAI,CAACuB,kBAAkB,CAACD,MAAM,CAAC,CAAC;KAC5C,CAAC,OAAO1G,GAAG,EAAE;MACZoF,IAAI,CAAC;QACHzE,OAAO,EAAE,IAAAvE,OAAA,CAAAwE,eAAe,EAACZ,GAAG,CAAC;QAC7Ba,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC;OACd,CAAC;;EAEN;EAEAR,gBAAgBA,CAACqG,KAAmB;IAClC,MAAMC,aAAa,GAAG,IAAI,CAACrF,OAAO,CAAC5B,SAAS,CAACgH,KAAK,CAAC;IAEnD;IACA,MAAMlB,UAAU,GAAGmB,aAAa,CAACnB,UAAU;IAC3C,MAAMoB,MAAM,GAAGd,MAAM,CAACe,WAAW,CAACrB,UAAU,GAAG,CAAC,CAAC;IACjDoB,MAAM,CAACE,UAAU,CAAC,CAAC,EAAE,CAAC,CAAC;IACvBF,MAAM,CAACG,aAAa,CAACvB,UAAU,EAAE,CAAC,CAAC;IACnCmB,aAAa,CAACK,IAAI,CAACJ,MAAM,EAAE,CAAC,CAAC;IAC7B,OAAOA,MAAM;EACf;EAEAH,kBAAkBA,CAACQ,KAAa;IAC9B,OAAO,IAAI,CAAC3F,OAAO,CAACtC,WAAW,CAACiI,KAAK,CAAC;EACxC;EAEA,MAAMC,gBAAgBA,CACpBpH,GAAsD,EACtD4G,KAA2B,EAC3BtI,QAA0B,EAC1B+I,KAAc;IAEd,IAAI,IAAI,CAACzE,cAAc,EAAE,EAAE;MACzB;;IAGF,IAAItE,QAAQ,KAAKwH,SAAS,EAAE;MAC1BxH,QAAQ,GAAG,IAAI;;IAGjB,IAAI0B,GAAG,EAAE;MACP,IAAI,CAACyD,MAAM,CAACpC,SAAS,CAACiG,cAAc,CAACjJ,IAAI,CAAC2B,GAAG,EAAE,UAAU,CAAC,IAAI1B,QAAQ,EAAE;QACtE0B,GAAG,CAAC1B,QAAQ,GAAGA,QAAQ;;MAEzB,IAAI,CAAC2B,SAAS,CAACD,GAAG,CAAC;MACnB;;IAGF,IAAI;MACF,MAAMM,QAAQ,GAAG,IAAI,CAACC,gBAAgB,CAACqG,KAAM,CAAC;MAE9C,IAAI,CAACpG,KAAK,CAACF,QAAQ,CAAC;MACpB,IAAI,CAACW,UAAU,CAAC;QAAEJ,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACI,EAAE;QAAEP,OAAO,EAAE,IAAI;QAAErC;MAAQ,CAAE,CAAC;KAC9D,CAAC,OAAO0B,GAAG,EAAE;MACZ,IAAI,CAACC,SAAS,CAAC;QACbU,OAAO,EAAE,IAAAvE,OAAA,CAAAwE,eAAe,EAACZ,GAAG,CAAC;QAC7Ba,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACC;OACd,CAAC;;EAEN;EAEAE,UAAUA,CAACsG,SAA8B;;IACvC,IAAI,CAAC7G,IAAI,CAAC,SAAS,EAAE6G,SAAS,CAAC1G,IAAI,CAAC;IACpC,IAAI,CAACH,IAAI,CAAC,WAAW,EAAE6G,SAAS,CAAC1G,IAAI,KAAK7E,WAAA,CAAA8E,MAAM,CAACI,EAAE,CAAC;IACpD,IAAI,IAAI,CAAC0B,cAAc,EAAE,EAAE;MACzB;;IAGFnG,KAAK,CACH,oBAAoB,IAClB,CAAA+F,EAAA,OAAI,CAAChB,OAAO,cAAAgB,EAAA,uBAAAA,EAAA,CAAEC,IAAI,IAClB,2BAA2B,GAC3BzG,WAAA,CAAA8E,MAAM,CAACyG,SAAS,CAAC1G,IAAI,CAAC,GACtB,YAAY,GACZ0G,SAAS,CAAC5G,OAAO,CACpB;IAED,IAAI,IAAI,CAACe,aAAa,EAAE8F,YAAY,CAAC,IAAI,CAAC9F,aAAa,CAAC;IAExD,IAAI,IAAI,CAACH,MAAM,CAACkG,WAAW,EAAE;MAC3B,IAAI,CAAC,IAAI,CAAC3F,YAAY,EAAE;QACtB,IAAI,CAACA,YAAY,GAAG,IAAI;QACxB,IAAI,CAACP,MAAM,CAACd,IAAI,CAAC,cAAc,EAAE,MAAK;;UACpC,MAAMiH,cAAc,GAAAjE,MAAA,CAAAC,MAAA;YAClB,CAAC1G,kBAAkB,GAAGuK,SAAS,CAAC1G,IAAI;YACpC,CAAC9D,mBAAmB,GAAG4K,SAAS,CAACJ,SAAS,CAAC5G,OAAO;UAAC,GAChD,CAAA6B,EAAA,GAAA+E,SAAS,CAACjJ,QAAQ,cAAAkE,EAAA,uBAAAA,EAAA,CAAEe,cAAc,EAAE,CACxC;UAED,IAAI,CAAChC,MAAM,CAACqG,YAAY,CAACF,cAAc,CAAC;UACxC,IAAI,CAAC/F,UAAU,GAAG,IAAI;QACxB,CAAC,CAAC;QACF,IAAI,CAACJ,MAAM,CAACrB,GAAG,EAAE;;KAEpB,MAAM;MACL;MACA,MAAMwH,cAAc,GAAAjE,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA;QAClB,CAAC1G,kBAAkB,GAAGuK,SAAS,CAAC1G,IAAI;QACpC,CAAC9D,mBAAmB,GAAG4K,SAAS,CAACJ,SAAS,CAAC5G,OAAO;MAAC,GAChDhD,sBAAsB,GACtB,CAAAkK,EAAA,GAAAN,SAAS,CAACjJ,QAAQ,cAAAuJ,EAAA,uBAAAA,EAAA,CAAEtE,cAAc,EAAE,CACxC;MACD,IAAI,CAAChC,MAAM,CAACoC,OAAO,CAAC+D,cAAc,EAAE;QAACI,SAAS,EAAE;MAAI,CAAC,CAAC;MACtD,IAAI,CAACnG,UAAU,GAAG,IAAI;;EAE1B;EAEA1B,SAASA,CAAC8H,KAAiD;IACzD,MAAMC,MAAM,GAAwB;MAClCnH,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAACmH,OAAO;MACpBtH,OAAO,EAAE,SAAS,IAAIoH,KAAK,GAAGA,KAAK,CAAC/E,OAAO,GAAG,eAAe;MAC7D1E,QAAQ,EACN,UAAU,IAAIyJ,KAAK,IAAIA,KAAK,CAACzJ,QAAQ,KAAKwH,SAAS,GAC/CiC,KAAK,CAACzJ,QAAQ,GACd;KACP;IAED,IACE,MAAM,IAAIyJ,KAAK,IACf,OAAOA,KAAK,CAAClH,IAAI,KAAK,QAAQ,IAC9BqH,MAAM,CAACC,SAAS,CAACJ,KAAK,CAAClH,IAAI,CAAC,EAC5B;MACAmH,MAAM,CAACnH,IAAI,GAAGkH,KAAK,CAAClH,IAAI;MAExB,IAAI,SAAS,IAAIkH,KAAK,IAAI,OAAOA,KAAK,CAACpH,OAAO,KAAK,QAAQ,EAAE;QAC3DqH,MAAM,CAACrH,OAAO,GAAGoH,KAAK,CAACpH,OAAQ;;;IAInC,IAAI,CAACM,UAAU,CAAC+G,MAAM,CAAC;EACzB;EAEAxH,KAAKA,CAACJ,KAAa;IACjB,IAAI,IAAI,CAACwC,cAAc,EAAE,EAAE;MACzB;;IAGF,IACE,IAAI,CAACR,kBAAkB,KAAK,CAAC,CAAC,IAC9BhC,KAAK,CAACgE,MAAM,GAAG,IAAI,CAAChC,kBAAkB,EACtC;MACA,IAAI,CAACnC,SAAS,CAAC;QACbY,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAAC8E,kBAAkB;QAC/BjF,OAAO,EAAE,iCAAiCP,KAAK,CAACgE,MAAM,QAAQ,IAAI,CAAChC,kBAAkB;OACtF,CAAC;MACF;;IAGF,IAAI,CAACzD,YAAY,EAAE;IACnB,IAAI,CAAC+B,IAAI,CAAC,aAAa,CAAC;IACxB,OAAO,IAAI,CAACa,MAAM,CAACf,KAAK,CAACJ,KAAK,CAAC;EACjC;EAEAX,MAAMA,CAAA;IACJ,IAAI,CAAC8B,MAAM,CAAC9B,MAAM,EAAE;EACtB;EAEAhB,gBAAgBA,CAACJ,IAAuB;IACtC,IAAI,CAACoC,IAAI,CAAC,WAAW,EAAG2H,MAAM,IAAI;MAChC/J,IAAI,CAACG,SAAS,GAAG,IAAI;MACrBH,IAAI,CAACqC,IAAI,CAAC,WAAW,EAAE0H,MAAM,CAAC;IAChC,CAAC,CAAC;IAEF,IAAI,CAAC3H,IAAI,CAAC,SAAS,EAAGuH,MAAM,IAAK3J,IAAI,CAACqC,IAAI,CAAC,SAAS,EAAEsH,MAAM,CAAC,CAAC;EAChE;EAEA3I,aAAaA,CACXgJ,QAEiD,EACjDlJ,QAAgB;IAEhB,MAAMmJ,OAAO,GAAG,IAAIpM,gBAAA,CAAAqM,aAAa,EAAE;IAEnC,IAAIC,SAAS,GAAG,KAAK;IAErB,IAAIC,wBAAwB,GAAG,KAAK;IAEpC,IAAIC,SAAS,GAAG,KAAK;IAErB,MAAMC,YAAY,GAAG,MAAAA,CAAA,KAAW;MAC9B,IAAI,CAACD,SAAS,IAAIF,SAAS,IAAI,CAACC,wBAAwB,EAAE;QACxDC,SAAS,GAAG,IAAI;QAChB,MAAM,IAAI,CAACE,mBAAmB,CAACP,QAAQ,EAAE,IAAI,CAAC;;IAElD,CAAC;IAED,IAAI,CAAC9G,MAAM,CAACxB,EAAE,CAAC,MAAM,EAAE,MAAO8I,IAAY,IAAI;MAC5C,MAAMC,QAAQ,GAAGR,OAAO,CAAC9H,KAAK,CAACqI,IAAI,CAAC;MAEpCJ,wBAAwB,GAAG,IAAI;MAC/B,IAAI,CAAClH,MAAM,CAACwH,KAAK,EAAE;MACnB,KAAK,MAAM/F,OAAO,IAAI8F,QAAQ,EAAE;QAC9B,IACE,IAAI,CAACxG,qBAAqB,KAAK,CAAC,CAAC,IACjCU,OAAO,CAACoB,MAAM,GAAG,IAAI,CAAC9B,qBAAqB,EAC3C;UACA,IAAI,CAACrC,SAAS,CAAC;YACbY,IAAI,EAAE7E,WAAA,CAAA8E,MAAM,CAAC8E,kBAAkB;YAC/BjF,OAAO,EAAE,qCAAqCqC,OAAO,CAACoB,MAAM,QAAQ,IAAI,CAAC9B,qBAAqB;WAC/F,CAAC;UACF;;QAEF,IAAI,CAAC5B,IAAI,CAAC,gBAAgB,CAAC;QAE3B,MAAMwF,UAAU,GAAGlD,OAAO,CAACmD,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC;QAC7C,MAAMC,yBAAyB,GAAGF,UAAU,GAAG/G,QAAQ,GAAG,UAAU;QACpE,MAAMkH,mBAAmB,GAAG,MAAM,IAAI,CAACtD,sBAAsB,CAC3DC,OAAO,EACPoD,yBAAyB,CAC1B;QAED;QACA;QACA,IAAI,CAACC,mBAAmB,EAAE;QAE1B,MAAM,IAAI,CAACuC,mBAAmB,CAACP,QAAQ,EAAEhC,mBAAmB,CAAC;;MAE/DoC,wBAAwB,GAAG,KAAK;MAChC,IAAI,CAAClH,MAAM,CAAC9B,MAAM,EAAE;MACpB,MAAMkJ,YAAY,EAAE;IACtB,CAAC,CAAC;IAEF,IAAI,CAACpH,MAAM,CAACd,IAAI,CAAC,KAAK,EAAE,YAAW;MACjC+H,SAAS,GAAG,IAAI;MAChB,MAAMG,YAAY,EAAE;IACtB,CAAC,CAAC;EACJ;EAEAnJ,uBAAuBA,CACrB6I,QAEiD;IAEjD,IAAI,CAACrG,OAAO,GAAG,IAAI;IAEnB,OAAO,IAAI,CAACG,cAAc,CAACiC,MAAM,GAAG,CAAC,EAAE;MACrC,MAAM4E,WAAW,GAAG,IAAI,CAAC7G,cAAc,CAAC8G,KAAK,EAAE;MAC/C,MAAMjH,OAAO,GAAGqG,QAAQ,CAACxC,IAAI,CAACmD,WAAW,CAAC;MAE1C,IAAIA,WAAW,KAAK,IAAI,IAAIhH,OAAO,KAAK,KAAK,EAAE;QAC7C,IAAI,CAACA,OAAO,GAAG,KAAK;QACpB;;;IAIJ,OAAO,IAAI,CAACA,OAAO;EACrB;EAEQ,MAAM4G,mBAAmBA,CAC/BP,QAEiD,EACjDa,YAA2B;IAE3B,IAAI,IAAI,CAACjH,aAAa,EAAE;MACtB,IAAI,CAACC,gBAAgB,CAAC2D,IAAI,CAACqD,YAAY,CAAC;KACzC,MAAM;MACL,MAAM,IAAI,CAACC,WAAW,CAACd,QAAQ,EAAEa,YAAY,CAAC;;EAElD;EAEQ,MAAMC,WAAWA,CACvBd,QAEiD,EACjDa,YAA2B;IAE3B,IAAIA,YAAY,KAAK,IAAI,EAAE;MACzBzM,KAAK,CAAC,wBAAwB,CAAC;MAC/B,IAAI,IAAI,CAACuF,OAAO,EAAE;QAChBqG,QAAQ,CAACxC,IAAI,CAAC,IAAI,CAAC;OACpB,MAAM;QACL,IAAI,CAAC1D,cAAc,CAAC0D,IAAI,CAAC,IAAI,CAAC;;MAGhC;;IAGFpJ,KAAK,CAAC,6BAA6B,GAAGyM,YAAY,CAAC9E,MAAM,CAAC;IAE1D,IAAI,CAACnC,aAAa,GAAG,IAAI;IAEzB,IAAI;MACF,MAAMmH,YAAY,GAAG,MAAM,IAAI,CAACzC,kBAAkB,CAACuC,YAAY,CAAC;MAEhE,IAAI,IAAI,CAAClH,OAAO,EAAE;QAChB,IAAI,CAACqG,QAAQ,CAACxC,IAAI,CAACuD,YAAY,CAAC,EAAE;UAChC,IAAI,CAACpH,OAAO,GAAG,KAAK;UACpB,IAAI,CAACT,MAAM,CAACwH,KAAK,EAAE;;OAEtB,MAAM;QACL,IAAI,CAAC5G,cAAc,CAAC0D,IAAI,CAACuD,YAAY,CAAC;;KAEzC,CAAC,OAAOrB,KAAK,EAAE;MACd;MACA,IAAI,CAAC7F,gBAAgB,CAACkC,MAAM,GAAG,CAAC;MAChC,IAAIvD,IAAI,GAAG,IAAAzE,OAAA,CAAAiN,YAAY,EAACtB,KAAK,CAAC;MAC9B,IAAIlH,IAAI,KAAK,IAAI,IAAIA,IAAI,GAAG7E,WAAA,CAAA8E,MAAM,CAACI,EAAE,IAAIL,IAAI,GAAG7E,WAAA,CAAA8E,MAAM,CAACwI,eAAe,EAAE;QACtEzI,IAAI,GAAG7E,WAAA,CAAA8E,MAAM,CAACC,QAAQ;;MAGxBsH,QAAQ,CAAC3H,IAAI,CAAC,OAAO,EAAE;QACrBC,OAAO,EAAE,IAAAvE,OAAA,CAAAwE,eAAe,EAACmH,KAAK,CAAC;QAC/BlH,IAAI,EAAEA;OACP,CAAC;;IAGJ,IAAI,CAACoB,aAAa,GAAG,KAAK;IAE1B,IAAI,IAAI,CAACC,gBAAgB,CAACkC,MAAM,GAAG,CAAC,EAAE;MACpC,MAAM,IAAI,CAAC+E,WAAW,CACpBd,QAAQ,EACR,IAAI,CAACnG,gBAAgB,CAAC+G,KAAK,EAAmB,CAC/C;;EAEL;EAEAvK,OAAOA,CAAA;IACL,MAAM6K,MAAM,GAAG,IAAI,CAAChI,MAAM,CAACiI,OAAO,CAACD,MAAM;IACzC,IAAIA,MAAM,CAACE,aAAa,EAAE;MACxB,IAAIF,MAAM,CAACG,UAAU,EAAE;QACrB,OAAO,GAAGH,MAAM,CAACE,aAAa,IAAIF,MAAM,CAACG,UAAU,EAAE;OACtD,MAAM;QACL,OAAOH,MAAM,CAACE,aAAa;;KAE9B,MAAM;MACL,OAAO,SAAS;;EAEpB;EAEA5K,WAAWA,CAAA;IACT,OAAO,IAAI,CAAC+C,QAAQ;EACtB;EAEA9C,OAAOA,CAAA;IACL,OAAO,IAAI,CAAC0C,OAAO,CAACiB,IAAI;EAC1B;;AA1jBF1D,OAAA,CAAAuC,qBAAA,GAAAA,qBAAA;AAgkBA,SAASyD,qBAAqBA,CAAC1G,IAAuB;EACpD,MAAM2B,GAAG,GAAG,IAAIuE,KAAK,CAAC,mBAAmB,CAAwB;EACjEvE,GAAG,CAACa,IAAI,GAAG7E,WAAA,CAAA8E,MAAM,CAAC6I,iBAAiB;EAEnCtL,IAAI,CAAC4B,SAAS,CAACD,GAAG,CAAC;EACnB3B,IAAI,CAACG,SAAS,GAAG,IAAI;EACrBH,IAAI,CAACqC,IAAI,CAAC,WAAW,EAAE,UAAU,CAAC;AACpC"},"metadata":{},"sourceType":"script","externalDependencies":[]}