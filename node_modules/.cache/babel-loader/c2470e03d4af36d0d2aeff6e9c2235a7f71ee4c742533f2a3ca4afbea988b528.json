{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.RoundRobinLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'round_robin';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'round_robin';\nclass RoundRobinLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\nclass RoundRobinPicker {\n  constructor(subchannelList) {\n    let nextIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.subchannelList = subchannelList;\n    this.nextIndex = nextIndex;\n  }\n  pick(pickArgs) {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel() {\n    return this.subchannelList[this.nextIndex];\n  }\n}\nclass RoundRobinLoadBalancer {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.subchannels = [];\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentReadyPicker = null;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n      if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE || newState === connectivity_state_1.ConnectivityState.IDLE) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n  calculateAndUpdateState() {\n    if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(subchannel => subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(this.currentReadyPicker.peekNextSubchannel());\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readySubchannels, index));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    } else {\n      this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    }\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (newState === connectivity_state_1.ConnectivityState.READY) {\n      this.currentReadyPicker = picker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n  }\n  updateAddressList(addressList, lbConfig) {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + addressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)));\n    this.subchannels = addressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n  exitIdle() {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.RoundRobinLoadBalancer = RoundRobinLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);\n}\nexports.setup = setup;","map":{"version":3,"names":["load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","RoundRobinLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","RoundRobinPicker","subchannelList","nextIndex","arguments","length","undefined","pick","pickArgs","pickedSubchannel","pickResultType","PickResultType","COMPLETE","subchannel","status","onCallStarted","onCallEnded","peekNextSubchannel","RoundRobinLoadBalancer","channelControlHelper","subchannels","currentState","ConnectivityState","IDLE","currentReadyPicker","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","calculateAndUpdateState","requestReresolution","startConnecting","readySubchannels","filter","getConnectivityState","index","indexOf","updateState","QueuePicker","UnavailablePicker","picker","resetSubchannelList","removeConnectivityStateListener","unref","removeChannelzChild","getChannelzRef","updateAddressList","addressList","lbConfig","map","address","subchannelAddressToString","createSubchannel","ref","addConnectivityStateListener","addChannelzChild","subchannelState","exitIdle","resetBackoff","destroy","getTypeName","exports","setup","registerLoadBalancerType"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/load-balancer-round-robin.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ConnectivityStateListener, SubchannelInterface } from './subchannel-interface';\n\nconst TRACER_NAME = 'round_robin';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'round_robin';\n\nclass RoundRobinLoadBalancingConfig implements LoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new RoundRobinLoadBalancingConfig();\n  }\n}\n\nclass RoundRobinPicker implements Picker {\n  constructor(\n    private readonly subchannelList: SubchannelInterface[],\n    private nextIndex = 0\n  ) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    const pickedSubchannel = this.subchannelList[this.nextIndex];\n    this.nextIndex = (this.nextIndex + 1) % this.subchannelList.length;\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: pickedSubchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n\n  /**\n   * Check what the next subchannel returned would be. Used by the load\n   * balancer implementation to preserve this part of the picker state if\n   * possible when a subchannel connects or disconnects.\n   */\n  peekNextSubchannel(): SubchannelInterface {\n    return this.subchannelList[this.nextIndex];\n  }\n}\n\ninterface ConnectivityStateCounts {\n  [ConnectivityState.CONNECTING]: number;\n  [ConnectivityState.IDLE]: number;\n  [ConnectivityState.READY]: number;\n  [ConnectivityState.SHUTDOWN]: number;\n  [ConnectivityState.TRANSIENT_FAILURE]: number;\n}\n\nexport class RoundRobinLoadBalancer implements LoadBalancer {\n  private subchannels: SubchannelInterface[] = [];\n\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n\n  private subchannelStateListener: ConnectivityStateListener;\n\n  private subchannelStateCounts: ConnectivityStateCounts;\n\n  private currentReadyPicker: RoundRobinPicker | null = null;\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      this.calculateAndUpdateState();\n\n      if (\n        newState === ConnectivityState.TRANSIENT_FAILURE ||\n        newState === ConnectivityState.IDLE\n      ) {\n        this.channelControlHelper.requestReresolution();\n        subchannel.startConnecting();\n      }\n    };\n  }\n\n  private calculateAndUpdateState() {\n    if (this.subchannelStateCounts[ConnectivityState.READY] > 0) {\n      const readySubchannels = this.subchannels.filter(\n        (subchannel) =>\n          subchannel.getConnectivityState() === ConnectivityState.READY\n      );\n      let index = 0;\n      if (this.currentReadyPicker !== null) {\n        index = readySubchannels.indexOf(\n          this.currentReadyPicker.peekNextSubchannel()\n        );\n        if (index < 0) {\n          index = 0;\n        }\n      }\n      this.updateState(\n        ConnectivityState.READY,\n        new RoundRobinPicker(readySubchannels, index)\n      );\n    } else if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    } else if (\n      this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] > 0\n    ) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker()\n      );\n    } else {\n      this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    }\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (newState === ConnectivityState.READY) {\n      this.currentReadyPicker = picker as RoundRobinPicker;\n    } else {\n      this.currentReadyPicker = null;\n    }\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList() {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannels = [];\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    this.resetSubchannelList();\n    trace(\n      'Connect to address list ' +\n        addressList.map((address) => subchannelAddressToString(address))\n    );\n    this.subchannels = addressList.map((address) =>\n      this.channelControlHelper.createSubchannel(address, {})\n    );\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n      const subchannelState = subchannel.getConnectivityState();\n      this.subchannelStateCounts[subchannelState] += 1;\n      if (\n        subchannelState === ConnectivityState.IDLE ||\n        subchannelState === ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        subchannel.startConnecting();\n      }\n    }\n    this.calculateAndUpdateState();\n  }\n\n  exitIdle(): void {\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n  }\n  resetBackoff(): void {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy(): void {\n    this.resetSubchannelList();\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup() {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    RoundRobinLoadBalancer,\n    RoundRobinLoadBalancingConfig\n  );\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}