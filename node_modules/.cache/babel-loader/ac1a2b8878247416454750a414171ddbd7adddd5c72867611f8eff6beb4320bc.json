{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getProxiedConnection = exports.mapProxyName = void 0;\nconst logging_1 = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst resolver_1 = require(\"./resolver\");\nconst http = require(\"http\");\nconst tls = require(\"tls\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst url_1 = require(\"url\");\nconst TRACER_NAME = 'proxy';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nfunction getProxyInfo() {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl;\n  try {\n    proxyUrl = new url_1.URL(proxyEnv);\n  } catch (e) {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`);\n    return {};\n  }\n  let userCred = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      (0, logging_1.log)(constants_1.LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result = {\n    address: `${hostname}:${port}`\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace('Proxy server ' + result.address + ' set by environment variable ' + envVar);\n  return result;\n}\nfunction getNoProxyHostList() {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\nfunction mapProxyName(target, options) {\n  var _a;\n  const noProxyResult = {\n    target: target,\n    extraOptions: {}\n  };\n  if (((_a = options['grpc.enable_http_proxy']) !== null && _a !== void 0 ? _a : 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = (0, uri_parser_1.splitHostPort)(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace('Not using proxy for target in no_proxy list: ' + (0, uri_parser_1.uriToString)(target));\n      return noProxyResult;\n    }\n  }\n  const extraOptions = {\n    'grpc.http_connect_target': (0, uri_parser_1.uriToString)(target)\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address\n    },\n    extraOptions: extraOptions\n  };\n}\nexports.mapProxyName = mapProxyName;\nfunction getProxiedConnection(address, channelOptions, connectionOptions) {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'];\n  const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve({});\n  }\n  const options = {\n    method: 'CONNECT',\n    path: parsedTarget.path\n  };\n  const headers = {\n    Host: parsedTarget.path\n  };\n  // Connect to the subchannel address as a proxy\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(channelOptions['grpc.http_connect_creds']).toString('base64');\n  }\n  options.headers = headers;\n  const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      var _a;\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace('Successfully connected to ' + options.path + ' through proxy ' + proxyAddressString);\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          const remoteHost = (_a = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _a !== void 0 ? _a : targetPath;\n          const cts = tls.connect(Object.assign({\n            host: remoteHost,\n            servername: remoteHost,\n            socket: socket\n          }, connectionOptions), () => {\n            trace('Successfully established a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString);\n            resolve({\n              socket: cts,\n              realTarget: parsedTarget\n            });\n          });\n          cts.on('error', error => {\n            trace('Failed to establish a TLS connection to ' + options.path + ' through proxy ' + proxyAddressString + ' with error ' + error.message);\n            reject();\n          });\n        } else {\n          trace('Successfully established a plaintext connection to ' + options.path + ' through proxy ' + proxyAddressString);\n          resolve({\n            socket,\n            realTarget: parsedTarget\n          });\n        }\n      } else {\n        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to ' + options.path + ' through proxy ' + proxyAddressString + ' with status ' + res.statusCode);\n        reject();\n      }\n    });\n    request.once('error', err => {\n      request.removeAllListeners();\n      (0, logging_1.log)(constants_1.LogVerbosity.ERROR, 'Failed to connect to proxy ' + proxyAddressString + ' with error ' + err.message);\n      reject();\n    });\n    request.end();\n  });\n}\nexports.getProxiedConnection = getProxiedConnection;","map":{"version":3,"names":["logging_1","require","constants_1","resolver_1","http","tls","logging","subchannel_address_1","uri_parser_1","url_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","getProxyInfo","proxyEnv","envVar","process","env","grpc_proxy","https_proxy","http_proxy","proxyUrl","URL","e","log","ERROR","protocol","userCred","username","password","INFO","hostname","port","result","address","creds","getNoProxyHostList","noProxyStr","no_grpc_proxy","no_proxy","split","mapProxyName","target","options","noProxyResult","extraOptions","_a","scheme","proxyInfo","hostPort","splitHostPort","path","serverHost","host","uriToString","exports","getProxiedConnection","channelOptions","connectionOptions","Promise","resolve","realTarget","parsedTarget","parseUri","method","headers","Host","isTcpSubchannelAddress","socketPath","Buffer","from","toString","proxyAddressString","subchannelAddressToString","reject","request","once","res","socket","head","removeAllListeners","statusCode","targetPath","getDefaultAuthority","remoteHost","cts","connect","Object","assign","servername","on","error","message","err","end"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/http_proxy.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { log } from './logging';\nimport { LogVerbosity } from './constants';\nimport { getDefaultAuthority } from './resolver';\nimport { Socket } from 'net';\nimport * as http from 'http';\nimport * as tls from 'tls';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { URL } from 'url';\n\nconst TRACER_NAME = 'proxy';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\ninterface ProxyInfo {\n  address?: string;\n  creds?: string;\n}\n\nfunction getProxyInfo(): ProxyInfo {\n  let proxyEnv = '';\n  let envVar = '';\n  /* Prefer using 'grpc_proxy'. Fallback on 'http_proxy' if it is not set.\n   * Also prefer using 'https_proxy' with fallback on 'http_proxy'. The\n   * fallback behavior can be removed if there's a demand for it.\n   */\n  if (process.env.grpc_proxy) {\n    envVar = 'grpc_proxy';\n    proxyEnv = process.env.grpc_proxy;\n  } else if (process.env.https_proxy) {\n    envVar = 'https_proxy';\n    proxyEnv = process.env.https_proxy;\n  } else if (process.env.http_proxy) {\n    envVar = 'http_proxy';\n    proxyEnv = process.env.http_proxy;\n  } else {\n    return {};\n  }\n  let proxyUrl: URL;\n  try {\n    proxyUrl = new URL(proxyEnv);\n  } catch (e) {\n    log(LogVerbosity.ERROR, `cannot parse value of \"${envVar}\" env var`);\n    return {};\n  }\n  if (proxyUrl.protocol !== 'http:') {\n    log(\n      LogVerbosity.ERROR,\n      `\"${proxyUrl.protocol}\" scheme not supported in proxy URI`\n    );\n    return {};\n  }\n  let userCred: string | null = null;\n  if (proxyUrl.username) {\n    if (proxyUrl.password) {\n      log(LogVerbosity.INFO, 'userinfo found in proxy URI');\n      userCred = `${proxyUrl.username}:${proxyUrl.password}`;\n    } else {\n      userCred = proxyUrl.username;\n    }\n  }\n  const hostname = proxyUrl.hostname;\n  let port = proxyUrl.port;\n  /* The proxy URL uses the scheme \"http:\", which has a default port number of\n   * 80. We need to set that explicitly here if it is omitted because otherwise\n   * it will use gRPC's default port 443. */\n  if (port === '') {\n    port = '80';\n  }\n  const result: ProxyInfo = {\n    address: `${hostname}:${port}`,\n  };\n  if (userCred) {\n    result.creds = userCred;\n  }\n  trace(\n    'Proxy server ' + result.address + ' set by environment variable ' + envVar\n  );\n  return result;\n}\n\nfunction getNoProxyHostList(): string[] {\n  /* Prefer using 'no_grpc_proxy'. Fallback on 'no_proxy' if it is not set. */\n  let noProxyStr: string | undefined = process.env.no_grpc_proxy;\n  let envVar = 'no_grpc_proxy';\n  if (!noProxyStr) {\n    noProxyStr = process.env.no_proxy;\n    envVar = 'no_proxy';\n  }\n  if (noProxyStr) {\n    trace('No proxy server list set by environment variable ' + envVar);\n    return noProxyStr.split(',');\n  } else {\n    return [];\n  }\n}\n\nexport interface ProxyMapResult {\n  target: GrpcUri;\n  extraOptions: ChannelOptions;\n}\n\nexport function mapProxyName(\n  target: GrpcUri,\n  options: ChannelOptions\n): ProxyMapResult {\n  const noProxyResult: ProxyMapResult = {\n    target: target,\n    extraOptions: {},\n  };\n  if ((options['grpc.enable_http_proxy'] ?? 1) === 0) {\n    return noProxyResult;\n  }\n  if (target.scheme === 'unix') {\n    return noProxyResult;\n  }\n  const proxyInfo = getProxyInfo();\n  if (!proxyInfo.address) {\n    return noProxyResult;\n  }\n  const hostPort = splitHostPort(target.path);\n  if (!hostPort) {\n    return noProxyResult;\n  }\n  const serverHost = hostPort.host;\n  for (const host of getNoProxyHostList()) {\n    if (host === serverHost) {\n      trace(\n        'Not using proxy for target in no_proxy list: ' + uriToString(target)\n      );\n      return noProxyResult;\n    }\n  }\n  const extraOptions: ChannelOptions = {\n    'grpc.http_connect_target': uriToString(target),\n  };\n  if (proxyInfo.creds) {\n    extraOptions['grpc.http_connect_creds'] = proxyInfo.creds;\n  }\n  return {\n    target: {\n      scheme: 'dns',\n      path: proxyInfo.address,\n    },\n    extraOptions: extraOptions,\n  };\n}\n\nexport interface ProxyConnectionResult {\n  socket?: Socket;\n  realTarget?: GrpcUri;\n}\n\nexport function getProxiedConnection(\n  address: SubchannelAddress,\n  channelOptions: ChannelOptions,\n  connectionOptions: tls.ConnectionOptions\n): Promise<ProxyConnectionResult> {\n  if (!('grpc.http_connect_target' in channelOptions)) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const realTarget = channelOptions['grpc.http_connect_target'] as string;\n  const parsedTarget = parseUri(realTarget);\n  if (parsedTarget === null) {\n    return Promise.resolve<ProxyConnectionResult>({});\n  }\n  const options: http.RequestOptions = {\n    method: 'CONNECT',\n    path: parsedTarget.path,\n  };\n  const headers: http.OutgoingHttpHeaders = {\n    Host: parsedTarget.path,\n  };\n  // Connect to the subchannel address as a proxy\n  if (isTcpSubchannelAddress(address)) {\n    options.host = address.host;\n    options.port = address.port;\n  } else {\n    options.socketPath = address.path;\n  }\n  if ('grpc.http_connect_creds' in channelOptions) {\n    headers['Proxy-Authorization'] =\n      'Basic ' +\n      Buffer.from(\n        channelOptions['grpc.http_connect_creds'] as string\n      ).toString('base64');\n  }\n  options.headers = headers\n  const proxyAddressString = subchannelAddressToString(address);\n  trace('Using proxy ' + proxyAddressString + ' to connect to ' + options.path);\n  return new Promise<ProxyConnectionResult>((resolve, reject) => {\n    const request = http.request(options);\n    request.once('connect', (res, socket, head) => {\n      request.removeAllListeners();\n      socket.removeAllListeners();\n      if (res.statusCode === 200) {\n        trace(\n          'Successfully connected to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString\n        );\n        if ('secureContext' in connectionOptions) {\n          /* The proxy is connecting to a TLS server, so upgrade this socket\n           * connection to a TLS connection.\n           * This is a workaround for https://github.com/nodejs/node/issues/32922\n           * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n          const targetPath = getDefaultAuthority(parsedTarget);\n          const hostPort = splitHostPort(targetPath);\n          const remoteHost = hostPort?.host ?? targetPath;\n\n          const cts = tls.connect(\n            {\n              host: remoteHost,\n              servername: remoteHost,\n              socket: socket,\n              ...connectionOptions,\n            },\n            () => {\n              trace(\n                'Successfully established a TLS connection to ' +\n                  options.path +\n                  ' through proxy ' +\n                  proxyAddressString\n              );\n              resolve({ socket: cts, realTarget: parsedTarget });\n            }\n          );\n          cts.on('error', (error: Error) => {\n            trace('Failed to establish a TLS connection to ' +\n                    options.path +\n                    ' through proxy ' +\n                    proxyAddressString +\n                    ' with error ' +\n                    error.message);\n            reject();\n          });\n        } else {\n          trace(\n            'Successfully established a plaintext connection to ' +\n              options.path +\n              ' through proxy ' +\n              proxyAddressString\n          );\n          resolve({\n            socket,\n            realTarget: parsedTarget,\n          });\n        }\n      } else {\n        log(\n          LogVerbosity.ERROR,\n          'Failed to connect to ' +\n            options.path +\n            ' through proxy ' +\n            proxyAddressString +\n            ' with status ' +\n            res.statusCode\n        );\n        reject();\n      }\n    });\n    request.once('error', (err) => {\n      request.removeAllListeners();\n      log(\n        LogVerbosity.ERROR,\n        'Failed to connect to proxy ' +\n          proxyAddressString +\n          ' with error ' +\n          err.message\n      );\n      reject();\n    });\n    request.end();\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}