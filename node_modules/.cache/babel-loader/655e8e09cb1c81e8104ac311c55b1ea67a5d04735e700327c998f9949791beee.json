{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResolvingLoadBalancer = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst service_config_1 = require(\"./service-config\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst resolver_1 = require(\"./resolver\");\nconst picker_1 = require(\"./picker\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst load_balancer_child_handler_1 = require(\"./load-balancer-child-handler\");\nconst TRACER_NAME = 'resolving_load_balancer';\nfunction trace(text) {\n  logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\nfunction getDefaultConfigSelector(serviceConfig) {\n  return function defaultConfigSelector(methodName, metadata) {\n    var _a, _b;\n    const splitName = methodName.split('/').filter(x => x.length > 0);\n    const service = (_a = splitName[0]) !== null && _a !== void 0 ? _a : '';\n    const method = (_b = splitName[1]) !== null && _b !== void 0 ? _b : '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (name.service === service && (name.method === undefined || name.method === method)) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: constants_1.Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n    return {\n      methodConfig: {\n        name: []\n      },\n      pickInformation: {},\n      status: constants_1.Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\nclass ResolvingLoadBalancer {\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(target, channelControlHelper, channelOptions, onSuccessfulResolution, onFailedResolution) {\n    this.target = target;\n    this.channelControlHelper = channelControlHelper;\n    this.channelOptions = channelOptions;\n    this.onSuccessfulResolution = onSuccessfulResolution;\n    this.onFailedResolution = onFailedResolution;\n    this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;\n    this.latestChildPicker = new picker_1.QueuePicker(this);\n    /**\n     * This resolving load balancer's current connectivity state.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The service config object from the last successful resolution, if\n     * available. A value of null indicates that we have not yet received a valid\n     * service config from the resolver.\n     */\n    this.previousServiceConfig = null;\n    /**\n     * Indicates whether we should attempt to resolve again after the backoff\n     * timer runs out.\n     */\n    this.continueResolving = false;\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions['grpc.service_config']));\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: []\n      };\n    }\n    this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n    this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState, picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)\n    });\n    this.innerResolver = (0, resolver_1.createResolver)(target, {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError, configSelector, attributes) => {\n        var _a;\n        let workingServiceConfig = null;\n        /* This first group of conditionals implements the algorithm described\n         * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n         * in the section called \"Behavior on receiving a new gRPC Config\".\n         */\n        if (serviceConfig === null) {\n          // Step 4 and 5\n          if (serviceConfigError === null) {\n            // Step 5\n            this.previousServiceConfig = null;\n            workingServiceConfig = this.defaultServiceConfig;\n          } else {\n            // Step 4\n            if (this.previousServiceConfig === null) {\n              // Step 4.ii\n              this.handleResolutionFailure(serviceConfigError);\n            } else {\n              // Step 4.i\n              workingServiceConfig = this.previousServiceConfig;\n            }\n          }\n        } else {\n          // Step 3\n          workingServiceConfig = serviceConfig;\n          this.previousServiceConfig = serviceConfig;\n        }\n        const workingConfigList = (_a = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a !== void 0 ? _a : [];\n        const loadBalancingConfig = (0, load_balancer_1.getFirstUsableConfig)(workingConfigList, true);\n        if (loadBalancingConfig === null) {\n          // There were load balancing configs but none are supported. This counts as a resolution failure\n          this.handleResolutionFailure({\n            code: constants_1.Status.UNAVAILABLE,\n            details: 'All load balancer options in service config are not compatible',\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.childLoadBalancer.updateAddressList(addressList, loadBalancingConfig, attributes);\n        const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;\n        this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));\n      },\n      onError: error => {\n        this.handleResolutionFailure(error);\n      }\n    }, channelOptions);\n    const backoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n  updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n    }\n    this.backoffTimeout.runOnce();\n  }\n  updateState(connectivityState, picker) {\n    trace((0, uri_parser_1.uriToString)(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[connectivityState]);\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {\n      picker = new picker_1.QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n  handleResolutionFailure(error) {\n    if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));\n      this.onFailedResolution(error);\n    }\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n    }\n    this.childLoadBalancer.exitIdle();\n  }\n  updateAddressList(addressList, lbConfig) {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN, new picker_1.UnavailablePicker());\n  }\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\nexports.ResolvingLoadBalancer = ResolvingLoadBalancer;","map":{"version":3,"names":["load_balancer_1","require","service_config_1","connectivity_state_1","resolver_1","picker_1","backoff_timeout_1","constants_1","metadata_1","logging","constants_2","uri_parser_1","load_balancer_child_handler_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","DEFAULT_LOAD_BALANCER_NAME","getDefaultConfigSelector","serviceConfig","defaultConfigSelector","methodName","metadata","splitName","split","filter","x","length","service","_a","method","_b","methodConfig","name","undefined","pickInformation","status","Status","OK","dynamicFilterFactories","ResolvingLoadBalancer","constructor","target","channelControlHelper","channelOptions","onSuccessfulResolution","onFailedResolution","latestChildState","ConnectivityState","IDLE","latestChildPicker","QueuePicker","currentState","previousServiceConfig","continueResolving","defaultServiceConfig","validateServiceConfig","JSON","parse","loadBalancingConfig","updateState","childLoadBalancer","ChildLoadBalancerHandler","createSubchannel","bind","requestReresolution","backoffTimeout","isRunning","updateResolution","newState","picker","addChannelzChild","removeChannelzChild","innerResolver","createResolver","addressList","serviceConfigError","configSelector","attributes","workingServiceConfig","handleResolutionFailure","workingConfigList","getFirstUsableConfig","code","UNAVAILABLE","details","Metadata","updateAddressList","finalServiceConfig","onError","error","backoffOptions","initialDelay","maxDelay","BackoffTimeout","unref","CONNECTING","runOnce","connectivityState","uriToString","TRANSIENT_FAILURE","UnavailablePicker","exitIdle","lbConfig","Error","resetBackoff","reset","destroy","SHUTDOWN","getTypeName","exports"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/resolving-load-balancer.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  ChannelControlHelper,\n  LoadBalancer,\n  LoadBalancingConfig,\n  getFirstUsableConfig,\n} from './load-balancer';\nimport { ServiceConfig, validateServiceConfig } from './service-config';\nimport { ConnectivityState } from './connectivity-state';\nimport { ConfigSelector, createResolver, Resolver } from './resolver';\nimport { ServiceError } from './call';\nimport { Picker, UnavailablePicker, QueuePicker } from './picker';\nimport { BackoffOptions, BackoffTimeout } from './backoff-timeout';\nimport { Status } from './constants';\nimport { StatusObject } from './call-interface';\nimport { Metadata } from './metadata';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChildLoadBalancerHandler } from './load-balancer-child-handler';\nimport { ChannelOptions } from './channel-options';\nimport { PickFirstLoadBalancingConfig } from './load-balancer-pick-first';\n\nconst TRACER_NAME = 'resolving_load_balancer';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst DEFAULT_LOAD_BALANCER_NAME = 'pick_first';\n\nfunction getDefaultConfigSelector(\n  serviceConfig: ServiceConfig | null\n): ConfigSelector {\n  return function defaultConfigSelector(\n    methodName: string,\n    metadata: Metadata\n  ) {\n    const splitName = methodName.split('/').filter((x) => x.length > 0);\n    const service = splitName[0] ?? '';\n    const method = splitName[1] ?? '';\n    if (serviceConfig && serviceConfig.methodConfig) {\n      for (const methodConfig of serviceConfig.methodConfig) {\n        for (const name of methodConfig.name) {\n          if (\n            name.service === service &&\n            (name.method === undefined || name.method === method)\n          ) {\n            return {\n              methodConfig: methodConfig,\n              pickInformation: {},\n              status: Status.OK,\n              dynamicFilterFactories: []\n            };\n          }\n        }\n      }\n    }\n    return {\n      methodConfig: { name: [] },\n      pickInformation: {},\n      status: Status.OK,\n      dynamicFilterFactories: []\n    };\n  };\n}\n\nexport interface ResolutionCallback {\n  (serviceConfig: ServiceConfig, configSelector: ConfigSelector): void;\n}\n\nexport interface ResolutionFailureCallback {\n  (status: StatusObject): void;\n}\n\nexport class ResolvingLoadBalancer implements LoadBalancer {\n  /**\n   * The resolver class constructed for the target address.\n   */\n  private innerResolver: Resolver;\n\n  private childLoadBalancer: ChildLoadBalancerHandler;\n  private latestChildState: ConnectivityState = ConnectivityState.IDLE;\n  private latestChildPicker: Picker = new QueuePicker(this);\n  /**\n   * This resolving load balancer's current connectivity state.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  private readonly defaultServiceConfig: ServiceConfig;\n  /**\n   * The service config object from the last successful resolution, if\n   * available. A value of null indicates that we have not yet received a valid\n   * service config from the resolver.\n   */\n  private previousServiceConfig: ServiceConfig | null = null;\n\n  /**\n   * The backoff timer for handling name resolution failures.\n   */\n  private readonly backoffTimeout: BackoffTimeout;\n\n  /**\n   * Indicates whether we should attempt to resolve again after the backoff\n   * timer runs out.\n   */\n  private continueResolving = false;\n\n  /**\n   * Wrapper class that behaves like a `LoadBalancer` and also handles name\n   * resolution internally.\n   * @param target The address of the backend to connect to.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   * @param defaultServiceConfig The default service configuration to be used\n   *     if none is provided by the name resolver. A `null` value indicates\n   *     that the default behavior should be the default unconfigured behavior.\n   *     In practice, that means using the \"pick first\" load balancer\n   *     implmentation\n   */\n  constructor(\n    private readonly target: GrpcUri,\n    private readonly channelControlHelper: ChannelControlHelper,\n    private readonly channelOptions: ChannelOptions,\n    private readonly onSuccessfulResolution: ResolutionCallback,\n    private readonly onFailedResolution: ResolutionFailureCallback\n  ) {\n    if (channelOptions['grpc.service_config']) {\n      this.defaultServiceConfig = validateServiceConfig(\n        JSON.parse(channelOptions['grpc.service_config']!)\n      );\n    } else {\n      this.defaultServiceConfig = {\n        loadBalancingConfig: [],\n        methodConfig: [],\n      };\n    }\n    this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n    this.childLoadBalancer = new ChildLoadBalancerHandler({\n      createSubchannel: channelControlHelper.createSubchannel.bind(\n        channelControlHelper\n      ),\n      requestReresolution: () => {\n        /* If the backoffTimeout is running, we're still backing off from\n         * making resolve requests, so we shouldn't make another one here.\n         * In that case, the backoff timer callback will call\n         * updateResolution */\n        if (this.backoffTimeout.isRunning()) {\n          this.continueResolving = true;\n        } else {\n          this.updateResolution();\n        }\n      },\n      updateState: (newState: ConnectivityState, picker: Picker) => {\n        this.latestChildState = newState;\n        this.latestChildPicker = picker;\n        this.updateState(newState, picker);\n      },\n      addChannelzChild: channelControlHelper.addChannelzChild.bind(\n        channelControlHelper\n      ),\n      removeChannelzChild: channelControlHelper.removeChannelzChild.bind(\n        channelControlHelper\n      )\n    });\n    this.innerResolver = createResolver(\n      target,\n      {\n        onSuccessfulResolution: (\n          addressList: SubchannelAddress[],\n          serviceConfig: ServiceConfig | null,\n          serviceConfigError: ServiceError | null,\n          configSelector: ConfigSelector | null,\n          attributes: { [key: string]: unknown }\n        ) => {\n          let workingServiceConfig: ServiceConfig | null = null;\n          /* This first group of conditionals implements the algorithm described\n           * in https://github.com/grpc/proposal/blob/master/A21-service-config-error-handling.md\n           * in the section called \"Behavior on receiving a new gRPC Config\".\n           */\n          if (serviceConfig === null) {\n            // Step 4 and 5\n            if (serviceConfigError === null) {\n              // Step 5\n              this.previousServiceConfig = null;\n              workingServiceConfig = this.defaultServiceConfig;\n            } else {\n              // Step 4\n              if (this.previousServiceConfig === null) {\n                // Step 4.ii\n                this.handleResolutionFailure(serviceConfigError);\n              } else {\n                // Step 4.i\n                workingServiceConfig = this.previousServiceConfig;\n              }\n            }\n          } else {\n            // Step 3\n            workingServiceConfig = serviceConfig;\n            this.previousServiceConfig = serviceConfig;\n          }\n          const workingConfigList =\n            workingServiceConfig?.loadBalancingConfig ?? [];\n          const loadBalancingConfig = getFirstUsableConfig(\n            workingConfigList,\n            true\n          );\n          if (loadBalancingConfig === null) {\n            // There were load balancing configs but none are supported. This counts as a resolution failure\n            this.handleResolutionFailure({\n              code: Status.UNAVAILABLE,\n              details:\n                'All load balancer options in service config are not compatible',\n              metadata: new Metadata(),\n            });\n            return;\n          }\n          this.childLoadBalancer.updateAddressList(\n            addressList,\n            loadBalancingConfig,\n            attributes\n          );\n          const finalServiceConfig =\n            workingServiceConfig ?? this.defaultServiceConfig;\n          this.onSuccessfulResolution(\n            finalServiceConfig,\n            configSelector ?? getDefaultConfigSelector(finalServiceConfig)\n          );\n        },\n        onError: (error: StatusObject) => {\n          this.handleResolutionFailure(error);\n        },\n      },\n      channelOptions\n    );\n    const backoffOptions: BackoffOptions = {\n      initialDelay: channelOptions['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: channelOptions['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      if (this.continueResolving) {\n        this.updateResolution();\n        this.continueResolving = false;\n      } else {\n        this.updateState(this.latestChildState, this.latestChildPicker);\n      }\n    }, backoffOptions);\n    this.backoffTimeout.unref();\n  }\n\n  private updateResolution() {\n    this.innerResolver.updateResolution();\n    if (this.currentState === ConnectivityState.IDLE) {\n      this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n    }\n    this.backoffTimeout.runOnce();\n  }\n\n  private updateState(connectivityState: ConnectivityState, picker: Picker) {\n    trace(\n      uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[connectivityState]\n    );\n    // Ensure that this.exitIdle() is called by the picker\n    if (connectivityState === ConnectivityState.IDLE) {\n      picker = new QueuePicker(this);\n    }\n    this.currentState = connectivityState;\n    this.channelControlHelper.updateState(connectivityState, picker);\n  }\n\n  private handleResolutionFailure(error: StatusObject) {\n    if (this.latestChildState === ConnectivityState.IDLE) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker(error)\n      );\n      this.onFailedResolution(error);\n    }\n  }\n\n  exitIdle() {\n    if (this.currentState === ConnectivityState.IDLE || this.currentState === ConnectivityState.TRANSIENT_FAILURE) {\n      if (this.backoffTimeout.isRunning()) {\n        this.continueResolving = true;\n      } else {\n        this.updateResolution();\n      }\n    }\n    this.childLoadBalancer.exitIdle();\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig | null\n  ): never {\n    throw new Error('updateAddressList not supported on ResolvingLoadBalancer');\n  }\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.childLoadBalancer.resetBackoff();\n  }\n\n  destroy() {\n    this.childLoadBalancer.destroy();\n    this.innerResolver.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN, new UnavailablePicker());\n  }\n\n  getTypeName() {\n    return 'resolving_load_balancer';\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAAA,eAAA,GAAAC,OAAA;AAMA,MAAAC,gBAAA,GAAAD,OAAA;AACA,MAAAE,oBAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AAEA,MAAAI,QAAA,GAAAJ,OAAA;AACA,MAAAK,iBAAA,GAAAL,OAAA;AACA,MAAAM,WAAA,GAAAN,OAAA;AAEA,MAAAO,UAAA,GAAAP,OAAA;AACA,MAAAQ,OAAA,GAAAR,OAAA;AACA,MAAAS,WAAA,GAAAT,OAAA;AAEA,MAAAU,YAAA,GAAAV,OAAA;AACA,MAAAW,6BAAA,GAAAX,OAAA;AAIA,MAAMY,WAAW,GAAG,yBAAyB;AAE7C,SAASC,KAAKA,CAACC,IAAY;EACzBN,OAAO,CAACK,KAAK,CAACJ,WAAA,CAAAM,YAAY,CAACC,KAAK,EAAEJ,WAAW,EAAEE,IAAI,CAAC;AACtD;AAEA,MAAMG,0BAA0B,GAAG,YAAY;AAE/C,SAASC,wBAAwBA,CAC/BC,aAAmC;EAEnC,OAAO,SAASC,qBAAqBA,CACnCC,UAAkB,EAClBC,QAAkB;;IAElB,MAAMC,SAAS,GAAGF,UAAU,CAACG,KAAK,CAAC,GAAG,CAAC,CAACC,MAAM,CAAEC,CAAC,IAAKA,CAAC,CAACC,MAAM,GAAG,CAAC,CAAC;IACnE,MAAMC,OAAO,GAAG,CAAAC,EAAA,GAAAN,SAAS,CAAC,CAAC,CAAC,cAAAM,EAAA,cAAAA,EAAA,GAAI,EAAE;IAClC,MAAMC,MAAM,GAAG,CAAAC,EAAA,GAAAR,SAAS,CAAC,CAAC,CAAC,cAAAQ,EAAA,cAAAA,EAAA,GAAI,EAAE;IACjC,IAAIZ,aAAa,IAAIA,aAAa,CAACa,YAAY,EAAE;MAC/C,KAAK,MAAMA,YAAY,IAAIb,aAAa,CAACa,YAAY,EAAE;QACrD,KAAK,MAAMC,IAAI,IAAID,YAAY,CAACC,IAAI,EAAE;UACpC,IACEA,IAAI,CAACL,OAAO,KAAKA,OAAO,KACvBK,IAAI,CAACH,MAAM,KAAKI,SAAS,IAAID,IAAI,CAACH,MAAM,KAAKA,MAAM,CAAC,EACrD;YACA,OAAO;cACLE,YAAY,EAAEA,YAAY;cAC1BG,eAAe,EAAE,EAAE;cACnBC,MAAM,EAAE9B,WAAA,CAAA+B,MAAM,CAACC,EAAE;cACjBC,sBAAsB,EAAE;aACzB;;;;;IAKT,OAAO;MACLP,YAAY,EAAE;QAAEC,IAAI,EAAE;MAAE,CAAE;MAC1BE,eAAe,EAAE,EAAE;MACnBC,MAAM,EAAE9B,WAAA,CAAA+B,MAAM,CAACC,EAAE;MACjBC,sBAAsB,EAAE;KACzB;EACH,CAAC;AACH;AAUA,MAAaC,qBAAqB;EAgChC;;;;;;;;;;;;EAYAC,YACmBC,MAAe,EACfC,oBAA0C,EAC1CC,cAA8B,EAC9BC,sBAA0C,EAC1CC,kBAA6C;IAJ7C,KAAAJ,MAAM,GAANA,MAAM;IACN,KAAAC,oBAAoB,GAApBA,oBAAoB;IACpB,KAAAC,cAAc,GAAdA,cAAc;IACd,KAAAC,sBAAsB,GAAtBA,sBAAsB;IACtB,KAAAC,kBAAkB,GAAlBA,kBAAkB;IA1C7B,KAAAC,gBAAgB,GAAsB7C,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI;IAC5D,KAAAC,iBAAiB,GAAW,IAAI9C,QAAA,CAAA+C,WAAW,CAAC,IAAI,CAAC;IACzD;;;IAGQ,KAAAC,YAAY,GAAsBlD,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI;IAEhE;;;;;IAKQ,KAAAI,qBAAqB,GAAyB,IAAI;IAO1D;;;;IAIQ,KAAAC,iBAAiB,GAAG,KAAK;IAqB/B,IAAIV,cAAc,CAAC,qBAAqB,CAAC,EAAE;MACzC,IAAI,CAACW,oBAAoB,GAAG,IAAAtD,gBAAA,CAAAuD,qBAAqB,EAC/CC,IAAI,CAACC,KAAK,CAACd,cAAc,CAAC,qBAAqB,CAAE,CAAC,CACnD;KACF,MAAM;MACL,IAAI,CAACW,oBAAoB,GAAG;QAC1BI,mBAAmB,EAAE,EAAE;QACvB3B,YAAY,EAAE;OACf;;IAEH,IAAI,CAAC4B,WAAW,CAAC1D,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI,EAAE,IAAI7C,QAAA,CAAA+C,WAAW,CAAC,IAAI,CAAC,CAAC;IAC/D,IAAI,CAACU,iBAAiB,GAAG,IAAIlD,6BAAA,CAAAmD,wBAAwB,CAAC;MACpDC,gBAAgB,EAAEpB,oBAAoB,CAACoB,gBAAgB,CAACC,IAAI,CAC1DrB,oBAAoB,CACrB;MACDsB,mBAAmB,EAAEA,CAAA,KAAK;QACxB;;;;QAIA,IAAI,IAAI,CAACC,cAAc,CAACC,SAAS,EAAE,EAAE;UACnC,IAAI,CAACb,iBAAiB,GAAG,IAAI;SAC9B,MAAM;UACL,IAAI,CAACc,gBAAgB,EAAE;;MAE3B,CAAC;MACDR,WAAW,EAAEA,CAACS,QAA2B,EAAEC,MAAc,KAAI;QAC3D,IAAI,CAACvB,gBAAgB,GAAGsB,QAAQ;QAChC,IAAI,CAACnB,iBAAiB,GAAGoB,MAAM;QAC/B,IAAI,CAACV,WAAW,CAACS,QAAQ,EAAEC,MAAM,CAAC;MACpC,CAAC;MACDC,gBAAgB,EAAE5B,oBAAoB,CAAC4B,gBAAgB,CAACP,IAAI,CAC1DrB,oBAAoB,CACrB;MACD6B,mBAAmB,EAAE7B,oBAAoB,CAAC6B,mBAAmB,CAACR,IAAI,CAChErB,oBAAoB;KAEvB,CAAC;IACF,IAAI,CAAC8B,aAAa,GAAG,IAAAtE,UAAA,CAAAuE,cAAc,EACjChC,MAAM,EACN;MACEG,sBAAsB,EAAEA,CACtB8B,WAAgC,EAChCxD,aAAmC,EACnCyD,kBAAuC,EACvCC,cAAqC,EACrCC,UAAsC,KACpC;;QACF,IAAIC,oBAAoB,GAAyB,IAAI;QACrD;;;;QAIA,IAAI5D,aAAa,KAAK,IAAI,EAAE;UAC1B;UACA,IAAIyD,kBAAkB,KAAK,IAAI,EAAE;YAC/B;YACA,IAAI,CAACvB,qBAAqB,GAAG,IAAI;YACjC0B,oBAAoB,GAAG,IAAI,CAACxB,oBAAoB;WACjD,MAAM;YACL;YACA,IAAI,IAAI,CAACF,qBAAqB,KAAK,IAAI,EAAE;cACvC;cACA,IAAI,CAAC2B,uBAAuB,CAACJ,kBAAkB,CAAC;aACjD,MAAM;cACL;cACAG,oBAAoB,GAAG,IAAI,CAAC1B,qBAAqB;;;SAGtD,MAAM;UACL;UACA0B,oBAAoB,GAAG5D,aAAa;UACpC,IAAI,CAACkC,qBAAqB,GAAGlC,aAAa;;QAE5C,MAAM8D,iBAAiB,GACrB,CAAApD,EAAA,GAAAkD,oBAAoB,aAApBA,oBAAoB,uBAApBA,oBAAoB,CAAEpB,mBAAmB,cAAA9B,EAAA,cAAAA,EAAA,GAAI,EAAE;QACjD,MAAM8B,mBAAmB,GAAG,IAAA5D,eAAA,CAAAmF,oBAAoB,EAC9CD,iBAAiB,EACjB,IAAI,CACL;QACD,IAAItB,mBAAmB,KAAK,IAAI,EAAE;UAChC;UACA,IAAI,CAACqB,uBAAuB,CAAC;YAC3BG,IAAI,EAAE7E,WAAA,CAAA+B,MAAM,CAAC+C,WAAW;YACxBC,OAAO,EACL,gEAAgE;YAClE/D,QAAQ,EAAE,IAAIf,UAAA,CAAA+E,QAAQ;WACvB,CAAC;UACF;;QAEF,IAAI,CAACzB,iBAAiB,CAAC0B,iBAAiB,CACtCZ,WAAW,EACXhB,mBAAmB,EACnBmB,UAAU,CACX;QACD,MAAMU,kBAAkB,GACtBT,oBAAoB,aAApBA,oBAAoB,cAApBA,oBAAoB,GAAI,IAAI,CAACxB,oBAAoB;QACnD,IAAI,CAACV,sBAAsB,CACzB2C,kBAAkB,EAClBX,cAAc,aAAdA,cAAc,cAAdA,cAAc,GAAI3D,wBAAwB,CAACsE,kBAAkB,CAAC,CAC/D;MACH,CAAC;MACDC,OAAO,EAAGC,KAAmB,IAAI;QAC/B,IAAI,CAACV,uBAAuB,CAACU,KAAK,CAAC;MACrC;KACD,EACD9C,cAAc,CACf;IACD,MAAM+C,cAAc,GAAmB;MACrCC,YAAY,EAAEhD,cAAc,CAAC,mCAAmC,CAAC;MACjEiD,QAAQ,EAAEjD,cAAc,CAAC,+BAA+B;KACzD;IACD,IAAI,CAACsB,cAAc,GAAG,IAAI7D,iBAAA,CAAAyF,cAAc,CAAC,MAAK;MAC5C,IAAI,IAAI,CAACxC,iBAAiB,EAAE;QAC1B,IAAI,CAACc,gBAAgB,EAAE;QACvB,IAAI,CAACd,iBAAiB,GAAG,KAAK;OAC/B,MAAM;QACL,IAAI,CAACM,WAAW,CAAC,IAAI,CAACb,gBAAgB,EAAE,IAAI,CAACG,iBAAiB,CAAC;;IAEnE,CAAC,EAAEyC,cAAc,CAAC;IAClB,IAAI,CAACzB,cAAc,CAAC6B,KAAK,EAAE;EAC7B;EAEQ3B,gBAAgBA,CAAA;IACtB,IAAI,CAACK,aAAa,CAACL,gBAAgB,EAAE;IACrC,IAAI,IAAI,CAAChB,YAAY,KAAKlD,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI,EAAE;MAChD,IAAI,CAACW,WAAW,CAAC1D,oBAAA,CAAA8C,iBAAiB,CAACgD,UAAU,EAAE,IAAI5F,QAAA,CAAA+C,WAAW,CAAC,IAAI,CAAC,CAAC;;IAEvE,IAAI,CAACe,cAAc,CAAC+B,OAAO,EAAE;EAC/B;EAEQrC,WAAWA,CAACsC,iBAAoC,EAAE5B,MAAc;IACtEzD,KAAK,CACH,IAAAH,YAAA,CAAAyF,WAAW,EAAC,IAAI,CAACzD,MAAM,CAAC,GACtB,GAAG,GACHxC,oBAAA,CAAA8C,iBAAiB,CAAC,IAAI,CAACI,YAAY,CAAC,GACpC,MAAM,GACNlD,oBAAA,CAAA8C,iBAAiB,CAACkD,iBAAiB,CAAC,CACvC;IACD;IACA,IAAIA,iBAAiB,KAAKhG,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI,EAAE;MAChDqB,MAAM,GAAG,IAAIlE,QAAA,CAAA+C,WAAW,CAAC,IAAI,CAAC;;IAEhC,IAAI,CAACC,YAAY,GAAG8C,iBAAiB;IACrC,IAAI,CAACvD,oBAAoB,CAACiB,WAAW,CAACsC,iBAAiB,EAAE5B,MAAM,CAAC;EAClE;EAEQU,uBAAuBA,CAACU,KAAmB;IACjD,IAAI,IAAI,CAAC3C,gBAAgB,KAAK7C,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI,EAAE;MACpD,IAAI,CAACW,WAAW,CACd1D,oBAAA,CAAA8C,iBAAiB,CAACoD,iBAAiB,EACnC,IAAIhG,QAAA,CAAAiG,iBAAiB,CAACX,KAAK,CAAC,CAC7B;MACD,IAAI,CAAC5C,kBAAkB,CAAC4C,KAAK,CAAC;;EAElC;EAEAY,QAAQA,CAAA;IACN,IAAI,IAAI,CAAClD,YAAY,KAAKlD,oBAAA,CAAA8C,iBAAiB,CAACC,IAAI,IAAI,IAAI,CAACG,YAAY,KAAKlD,oBAAA,CAAA8C,iBAAiB,CAACoD,iBAAiB,EAAE;MAC7G,IAAI,IAAI,CAAClC,cAAc,CAACC,SAAS,EAAE,EAAE;QACnC,IAAI,CAACb,iBAAiB,GAAG,IAAI;OAC9B,MAAM;QACL,IAAI,CAACc,gBAAgB,EAAE;;;IAG3B,IAAI,CAACP,iBAAiB,CAACyC,QAAQ,EAAE;EACnC;EAEAf,iBAAiBA,CACfZ,WAAgC,EAChC4B,QAAoC;IAEpC,MAAM,IAAIC,KAAK,CAAC,0DAA0D,CAAC;EAC7E;EAEAC,YAAYA,CAAA;IACV,IAAI,CAACvC,cAAc,CAACwC,KAAK,EAAE;IAC3B,IAAI,CAAC7C,iBAAiB,CAAC4C,YAAY,EAAE;EACvC;EAEAE,OAAOA,CAAA;IACL,IAAI,CAAC9C,iBAAiB,CAAC8C,OAAO,EAAE;IAChC,IAAI,CAAClC,aAAa,CAACkC,OAAO,EAAE;IAC5B,IAAI,CAAC/C,WAAW,CAAC1D,oBAAA,CAAA8C,iBAAiB,CAAC4D,QAAQ,EAAE,IAAIxG,QAAA,CAAAiG,iBAAiB,EAAE,CAAC;EACvE;EAEAQ,WAAWA,CAAA;IACT,OAAO,yBAAyB;EAClC;;AA/OFC,OAAA,CAAAtE,qBAAA,GAAAA,qBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}