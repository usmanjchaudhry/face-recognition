{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelCall = void 0;\nconst http2 = require(\"http2\");\nconst os = require(\"os\");\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst stream_decoder_1 = require(\"./stream-decoder\");\nconst logging = require(\"./logging\");\nconst constants_2 = require(\"./constants\");\nconst TRACER_NAME = 'subchannel_call';\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL\n} = http2.constants;\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno) {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\nclass Http2SubchannelCall {\n  constructor(http2Stream, callEventTracker, listener, transport, callId) {\n    this.http2Stream = http2Stream;\n    this.callEventTracker = callEventTracker;\n    this.listener = listener;\n    this.transport = transport;\n    this.callId = callId;\n    this.decoder = new stream_decoder_1.StreamDecoder();\n    this.isReadFilterPending = false;\n    this.isPushPending = false;\n    this.canPush = false;\n    /**\n     * Indicates that an 'end' event has come from the http2 stream, so there\n     * will be no more data events.\n     */\n    this.readsClosed = false;\n    this.statusOutput = false;\n    this.unpushedReadMessages = [];\n    // Status code mapped from :status. To be used if grpc-status is not received\n    this.mappedStatusCode = constants_1.Status.UNKNOWN;\n    // This is populated (non-null) if and only if the call has ended\n    this.finalStatus = null;\n    this.internalError = null;\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = constants_1.Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = constants_1.Status.UNKNOWN;\n      }\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata;\n        try {\n          metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: constants_1.Status.UNKNOWN,\n            details: error.message,\n            metadata: new metadata_1.Metadata()\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', headers => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', data => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        var _a;\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n          return;\n        }\n        let code;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = constants_1.Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = constants_1.Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = constants_1.Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = constants_1.Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = constants_1.Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = constants_1.Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = constants_1.Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({\n          code,\n          details,\n          metadata: new metadata_1.Metadata(),\n          rstCode: http2Stream.rstCode\n        });\n      });\n    });\n    http2Stream.on('error', err => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace('Node error event: message=' + err.message + ' code=' + err.code + ' errno=' + getSystemErrorName(err.errno) + ' syscall=' + err.syscall);\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n  onDisconnect() {\n    this.endCall({\n      code: constants_1.Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace('ended with status: code=' + this.finalStatus.code + ' details=\"' + this.finalStatus.details + '\"');\n      this.callEventTracker.onCallEnd(this.finalStatus);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n  trace(text) {\n    logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callId + '] ' + text);\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  endCall(status) {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n  maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {\n        this.outputStatus();\n      }\n    }\n  }\n  push(message) {\n    this.trace('pushing to reader message of length ' + (message instanceof Buffer ? message.length : null));\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n  tryPush(messageBytes) {\n    if (this.canPush) {\n      this.http2Stream.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace('unpushedReadMessages.push message of length ' + messageBytes.length);\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n  handleTrailers(headers) {\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata;\n    try {\n      metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new metadata_1.Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code = this.mappedStatusCode;\n    if (code === constants_1.Status.UNKNOWN && typeof metadataMap['grpc-status'] === 'string') {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in constants_1.Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace('received status details string \"' + details + '\" from server');\n    }\n    const status = {\n      code,\n      details,\n      metadata\n    };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n  destroyHttp2Stream() {\n    var _a;\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code;\n      if (((_a = this.finalStatus) === null || _a === void 0 ? void 0 : _a.code) === constants_1.Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.endCall({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n  }\n  getStatus() {\n    return this.finalStatus;\n  }\n  getPeer() {\n    return this.transport.getPeerName();\n  }\n  getCallNumber() {\n    return this.callId;\n  }\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage = this.unpushedReadMessages.shift();\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb = error => {\n      var _a;\n      let code = constants_1.Status.UNAVAILABLE;\n      if ((error === null || error === void 0 ? void 0 : error.code) === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = constants_1.Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: constants_1.Status.UNAVAILABLE,\n        details: `Write failed with error ${error.message}`,\n        metadata: new metadata_1.Metadata()\n      });\n    }\n  }\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\nexports.Http2SubchannelCall = Http2SubchannelCall;","map":{"version":3,"names":["http2","require","os","constants_1","metadata_1","stream_decoder_1","logging","constants_2","TRACER_NAME","HTTP2_HEADER_STATUS","HTTP2_HEADER_CONTENT_TYPE","NGHTTP2_CANCEL","constants","getSystemErrorName","errno","name","num","Object","entries","Http2SubchannelCall","constructor","http2Stream","callEventTracker","listener","transport","callId","decoder","StreamDecoder","isReadFilterPending","isPushPending","canPush","readsClosed","statusOutput","unpushedReadMessages","mappedStatusCode","Status","UNKNOWN","finalStatus","internalError","on","headers","flags","headersString","header","keys","trace","INTERNAL","UNAUTHENTICATED","PERMISSION_DENIED","UNIMPLEMENTED","UNAVAILABLE","NGHTTP2_FLAG_END_STREAM","handleTrailers","metadata","Metadata","fromHttp2Headers","error","endCall","code","details","message","onReceiveMetadata","data","length","messages","write","addMessageReceived","tryPush","maybeOutputStatus","process","nextTick","rstCode","_a","OK","NGHTTP2_NO_ERROR","NGHTTP2_REFUSED_STREAM","CANCELLED","NGHTTP2_ENHANCE_YOUR_CALM","RESOURCE_EXHAUSTED","NGHTTP2_INADEQUATE_SECURITY","NGHTTP2_INTERNAL_ERROR","err","syscall","onStreamEnd","onDisconnect","outputStatus","onCallEnd","onReceiveStatus","resume","text","LogVerbosity","DEBUG","status","destroyHttp2Stream","push","Buffer","onReceiveMessage","messageBytes","pause","e","metadataMap","getMap","receivedStatus","Number","remove","decodeURI","destroyed","close","cancelWithStatus","getStatus","getPeer","getPeerName","getCallNumber","startRead","nextMessage","shift","sendMessageWithContext","context","cb","callback","call","addMessageSent","halfClose","end","exports"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/subchannel-call.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport * as os from 'os';\n\nimport { Status } from './constants';\nimport { Metadata } from './metadata';\nimport { StreamDecoder } from './stream-decoder';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { ServerSurfaceCall } from './server-call';\nimport { Deadline } from './deadline';\nimport { InterceptingListener, MessageContext, StatusObject, WriteCallback } from './call-interface';\nimport { CallEventTracker, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel_call';\n\nconst {\n  HTTP2_HEADER_STATUS,\n  HTTP2_HEADER_CONTENT_TYPE,\n  NGHTTP2_CANCEL,\n} = http2.constants;\n\n/**\n * https://nodejs.org/api/errors.html#errors_class_systemerror\n */\ninterface SystemError extends Error {\n  address?: string;\n  code: string;\n  dest?: string;\n  errno: number;\n  info?: object;\n  message: string;\n  path?: string;\n  port?: number;\n  syscall: string;\n}\n\n/**\n * Should do approximately the same thing as util.getSystemErrorName but the\n * TypeScript types don't have that function for some reason so I just made my\n * own.\n * @param errno\n */\nfunction getSystemErrorName(errno: number): string {\n  for (const [name, num] of Object.entries(os.constants.errno)) {\n    if (num === errno) {\n      return name;\n    }\n  }\n  return 'Unknown system error ' + errno;\n}\n\nexport interface SubchannelCall {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  sendMessageWithContext(context: MessageContext, message: Buffer): void;\n  startRead(): void;\n  halfClose(): void;\n  getCallNumber(): number;\n}\n\nexport interface StatusObjectWithRstCode extends StatusObject {\n  rstCode?: number;\n}\n\nexport interface SubchannelCallInterceptingListener extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithRstCode): void;\n}\n\nexport class Http2SubchannelCall implements SubchannelCall {\n  private decoder = new StreamDecoder();\n\n  private isReadFilterPending = false;\n  private isPushPending = false;\n  private canPush = false;\n  /**\n   * Indicates that an 'end' event has come from the http2 stream, so there\n   * will be no more data events.\n   */\n  private readsClosed = false;\n\n  private statusOutput = false;\n\n  private unpushedReadMessages: Buffer[] = [];\n\n  // Status code mapped from :status. To be used if grpc-status is not received\n  private mappedStatusCode: Status = Status.UNKNOWN;\n\n  // This is populated (non-null) if and only if the call has ended\n  private finalStatus: StatusObject | null = null;\n\n  private internalError: SystemError | null = null;\n\n  constructor(\n    private readonly http2Stream: http2.ClientHttp2Stream,\n    private readonly callEventTracker: CallEventTracker,\n    private readonly listener: SubchannelCallInterceptingListener,\n    private readonly transport: Transport,\n    private readonly callId: number\n  ) {\n    http2Stream.on('response', (headers, flags) => {\n      let headersString = '';\n      for (const header of Object.keys(headers)) {\n        headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n      }\n      this.trace('Received server headers:\\n' + headersString);\n      switch (headers[':status']) {\n        // TODO(murgatroid99): handle 100 and 101\n        case 400:\n          this.mappedStatusCode = Status.INTERNAL;\n          break;\n        case 401:\n          this.mappedStatusCode = Status.UNAUTHENTICATED;\n          break;\n        case 403:\n          this.mappedStatusCode = Status.PERMISSION_DENIED;\n          break;\n        case 404:\n          this.mappedStatusCode = Status.UNIMPLEMENTED;\n          break;\n        case 429:\n        case 502:\n        case 503:\n        case 504:\n          this.mappedStatusCode = Status.UNAVAILABLE;\n          break;\n        default:\n          this.mappedStatusCode = Status.UNKNOWN;\n      }\n\n      if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n        this.handleTrailers(headers);\n      } else {\n        let metadata: Metadata;\n        try {\n          metadata = Metadata.fromHttp2Headers(headers);\n        } catch (error) {\n          this.endCall({\n            code: Status.UNKNOWN,\n            details: (error as Error).message,\n            metadata: new Metadata(),\n          });\n          return;\n        }\n        this.listener.onReceiveMetadata(metadata);\n      }\n    });\n    http2Stream.on('trailers', (headers: http2.IncomingHttpHeaders) => {\n      this.handleTrailers(headers);\n    });\n    http2Stream.on('data', (data: Buffer) => {\n      /* If the status has already been output, allow the http2 stream to\n       * drain without processing the data. */\n      if (this.statusOutput) {\n        return;\n      }\n      this.trace('receive HTTP/2 data frame of length ' + data.length);\n      const messages = this.decoder.write(data);\n\n      for (const message of messages) {\n        this.trace('parsed message of length ' + message.length);\n        this.callEventTracker!.addMessageReceived();\n        this.tryPush(message);\n      }\n    });\n    http2Stream.on('end', () => {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n    });\n    http2Stream.on('close', () => {\n      /* Use process.next tick to ensure that this code happens after any\n       * \"error\" event that may be emitted at about the same time, so that\n       * we can bubble up the error message from that event. */\n      process.nextTick(() => {\n        this.trace('HTTP/2 stream closed with code ' + http2Stream.rstCode);\n        /* If we have a final status with an OK status code, that means that\n         * we have received all of the messages and we have processed the\n         * trailers and the call completed successfully, so it doesn't matter\n         * how the stream ends after that */\n        if (this.finalStatus?.code === Status.OK) {\n          return;\n        }\n        let code: Status;\n        let details = '';\n        switch (http2Stream.rstCode) {\n          case http2.constants.NGHTTP2_NO_ERROR:\n            /* If we get a NO_ERROR code and we already have a status, the\n             * stream completed properly and we just haven't fully processed\n             * it yet */\n            if (this.finalStatus !== null) {\n              return;\n            }\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n            break;\n          case http2.constants.NGHTTP2_REFUSED_STREAM:\n            code = Status.UNAVAILABLE;\n            details = 'Stream refused by server';\n            break;\n          case http2.constants.NGHTTP2_CANCEL:\n            code = Status.CANCELLED;\n            details = 'Call cancelled';\n            break;\n          case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:\n            code = Status.RESOURCE_EXHAUSTED;\n            details = 'Bandwidth exhausted or memory limit exceeded';\n            break;\n          case http2.constants.NGHTTP2_INADEQUATE_SECURITY:\n            code = Status.PERMISSION_DENIED;\n            details = 'Protocol not secure enough';\n            break;\n          case http2.constants.NGHTTP2_INTERNAL_ERROR:\n            code = Status.INTERNAL;\n            if (this.internalError === null) {\n              /* This error code was previously handled in the default case, and\n               * there are several instances of it online, so I wanted to\n               * preserve the original error message so that people find existing\n               * information in searches, but also include the more recognizable\n               * \"Internal server error\" message. */\n              details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;\n            } else {\n              if (this.internalError.code === 'ECONNRESET' || this.internalError.code === 'ETIMEDOUT') {\n                code = Status.UNAVAILABLE;\n                details = this.internalError.message;\n              } else {\n                /* The \"Received RST_STREAM with code ...\" error is preserved\n                 * here for continuity with errors reported online, but the\n                 * error message at the end will probably be more relevant in\n                 * most cases. */\n                details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;\n              }\n            }\n            break;\n          default:\n            code = Status.INTERNAL;\n            details = `Received RST_STREAM with code ${http2Stream.rstCode}`;\n        }\n        // This is a no-op if trailers were received at all.\n        // This is OK, because status codes emitted here correspond to more\n        // catastrophic issues that prevent us from receiving trailers in the\n        // first place.\n        this.endCall({ code, details, metadata: new Metadata(), rstCode: http2Stream.rstCode });\n      });\n    });\n    http2Stream.on('error', (err: SystemError) => {\n      /* We need an error handler here to stop \"Uncaught Error\" exceptions\n       * from bubbling up. However, errors here should all correspond to\n       * \"close\" events, where we will handle the error more granularly */\n      /* Specifically looking for stream errors that were *not* constructed\n       * from a RST_STREAM response here:\n       * https://github.com/nodejs/node/blob/8b8620d580314050175983402dfddf2674e8e22a/lib/internal/http2/core.js#L2267\n       */\n      if (err.code !== 'ERR_HTTP2_STREAM_ERROR') {\n        this.trace(\n          'Node error event: message=' +\n            err.message +\n            ' code=' +\n            err.code +\n            ' errno=' +\n            getSystemErrorName(err.errno) +\n            ' syscall=' +\n            err.syscall\n        );\n        this.internalError = err;\n      }\n      this.callEventTracker.onStreamEnd(false);\n    });\n  }\n\n  public onDisconnect() {\n    this.endCall({\n      code: Status.UNAVAILABLE,\n      details: 'Connection dropped',\n      metadata: new Metadata(),\n    });\n  }\n\n  private outputStatus() {\n    /* Precondition: this.finalStatus !== null */\n    if (!this.statusOutput) {\n      this.statusOutput = true;\n      this.trace(\n        'ended with status: code=' +\n          this.finalStatus!.code +\n          ' details=\"' +\n          this.finalStatus!.details +\n          '\"'\n      );\n      this.callEventTracker.onCallEnd(this.finalStatus!);\n      /* We delay the actual action of bubbling up the status to insulate the\n       * cleanup code in this class from any errors that may be thrown in the\n       * upper layers as a result of bubbling up the status. In particular,\n       * if the status is not OK, the \"error\" event may be emitted\n       * synchronously at the top level, which will result in a thrown error if\n       * the user does not handle that event. */\n      process.nextTick(() => {\n        this.listener.onReceiveStatus(this.finalStatus!);\n      });\n      /* Leave the http2 stream in flowing state to drain incoming messages, to\n       * ensure that the stream closure completes. The call stream already does\n       * not push more messages after the status is output, so the messages go\n       * nowhere either way. */\n      this.http2Stream.resume();\n    }\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callId + '] ' + text\n    );\n  }\n\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n  private endCall(status: StatusObjectWithRstCode): void {\n    /* If the status is OK and a new status comes in (e.g. from a\n     * deserialization failure), that new status takes priority */\n    if (this.finalStatus === null || this.finalStatus.code === Status.OK) {\n      this.finalStatus = status;\n      this.maybeOutputStatus();\n    }\n    this.destroyHttp2Stream();\n  }\n\n  private maybeOutputStatus() {\n    if (this.finalStatus !== null) {\n      /* The combination check of readsClosed and that the two message buffer\n       * arrays are empty checks that there all incoming data has been fully\n       * processed */\n      if (\n        this.finalStatus.code !== Status.OK ||\n        (this.readsClosed &&\n          this.unpushedReadMessages.length === 0 &&\n          !this.isReadFilterPending &&\n          !this.isPushPending)\n      ) {\n        this.outputStatus();\n      }\n    }\n  }\n\n  private push(message: Buffer): void {\n    this.trace(\n      'pushing to reader message of length ' +\n        (message instanceof Buffer ? message.length : null)\n    );\n    this.canPush = false;\n    this.isPushPending = true;\n    process.nextTick(() => {\n      this.isPushPending = false;\n      /* If we have already output the status any later messages should be\n       * ignored, and can cause out-of-order operation errors higher up in the\n       * stack. Checking as late as possible here to avoid any race conditions.\n       */\n      if (this.statusOutput) {\n        return;\n      }\n      this.listener.onReceiveMessage(message);\n      this.maybeOutputStatus();\n    });\n  }\n\n  private tryPush(messageBytes: Buffer): void {\n    if (this.canPush) {\n      this.http2Stream!.pause();\n      this.push(messageBytes);\n    } else {\n      this.trace(\n        'unpushedReadMessages.push message of length ' + messageBytes.length\n      );\n      this.unpushedReadMessages.push(messageBytes);\n    }\n  }\n\n  private handleTrailers(headers: http2.IncomingHttpHeaders) {\n    this.callEventTracker.onStreamEnd(true);\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    this.trace('Received server trailers:\\n' + headersString);\n    let metadata: Metadata;\n    try {\n      metadata = Metadata.fromHttp2Headers(headers);\n    } catch (e) {\n      metadata = new Metadata();\n    }\n    const metadataMap = metadata.getMap();\n    let code: Status = this.mappedStatusCode;\n    if (\n      code === Status.UNKNOWN &&\n      typeof metadataMap['grpc-status'] === 'string'\n    ) {\n      const receivedStatus = Number(metadataMap['grpc-status']);\n      if (receivedStatus in Status) {\n        code = receivedStatus;\n        this.trace('received status code ' + receivedStatus + ' from server');\n      }\n      metadata.remove('grpc-status');\n    }\n    let details = '';\n    if (typeof metadataMap['grpc-message'] === 'string') {\n      try {\n        details = decodeURI(metadataMap['grpc-message']);\n      } catch (e) {\n        details = metadataMap['grpc-message'];\n      }\n      metadata.remove('grpc-message');\n      this.trace(\n        'received status details string \"' + details + '\" from server'\n      );\n    }\n    const status: StatusObject = { code, details, metadata };\n    // This is a no-op if the call was already ended when handling headers.\n    this.endCall(status);\n  }\n\n  private destroyHttp2Stream() {\n    // The http2 stream could already have been destroyed if cancelWithStatus\n    // is called in response to an internal http2 error.\n    if (!this.http2Stream.destroyed) {\n      /* If the call has ended with an OK status, communicate that when closing\n       * the stream, partly to avoid a situation in which we detect an error\n       * RST_STREAM as a result after we have the status */\n      let code: number;\n      if (this.finalStatus?.code === Status.OK) {\n        code = http2.constants.NGHTTP2_NO_ERROR;\n      } else {\n        code = http2.constants.NGHTTP2_CANCEL;\n      }\n      this.trace('close http2 stream with code ' + code);\n      this.http2Stream.close(code);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace(\n      'cancelWithStatus code: ' + status + ' details: \"' + details + '\"'\n    );\n    this.endCall({ code: status, details, metadata: new Metadata() });\n  }\n\n  getStatus(): StatusObject | null {\n    return this.finalStatus;\n  }\n\n  getPeer(): string {\n    return this.transport.getPeerName();\n  }\n\n  getCallNumber(): number {\n    return this.callId;\n  }\n\n  startRead() {\n    /* If the stream has ended with an error, we should not emit any more\n     * messages and we should communicate that the stream has ended */\n    if (this.finalStatus !== null && this.finalStatus.code !== Status.OK) {\n      this.readsClosed = true;\n      this.maybeOutputStatus();\n      return;\n    }\n    this.canPush = true;\n    if (this.unpushedReadMessages.length > 0) {\n      const nextMessage: Buffer = this.unpushedReadMessages.shift()!;\n      this.push(nextMessage);\n      return;\n    }\n    /* Only resume reading from the http2Stream if we don't have any pending\n      * messages to emit */\n    this.http2Stream.resume();\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer) {\n    this.trace('write() called with message of length ' + message.length);\n    const cb: WriteCallback = (error?: Error | null) => {\n      let code: Status = Status.UNAVAILABLE;\n      if ((error as NodeJS.ErrnoException)?.code === 'ERR_STREAM_WRITE_AFTER_END') {\n        code = Status.INTERNAL;\n      }\n      if (error) {\n        this.cancelWithStatus(code, `Write error: ${error.message}`);\n      }\n      context.callback?.();\n    };\n    this.trace('sending data chunk of length ' + message.length);\n    this.callEventTracker.addMessageSent();\n    try {\n      this.http2Stream!.write(message, cb);\n    } catch (error) {\n      this.endCall({\n        code: Status.UNAVAILABLE,\n        details: `Write failed with error ${(error as Error).message}`,\n        metadata: new Metadata()\n      });\n    }\n  }\n\n  halfClose() {\n    this.trace('end() called');\n    this.trace('calling end() on HTTP/2 stream');\n    this.http2Stream.end();\n  }\n}\n"],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;AAiBA,MAAAA,KAAA,GAAAC,OAAA;AACA,MAAAC,EAAA,GAAAD,OAAA;AAEA,MAAAE,WAAA,GAAAF,OAAA;AACA,MAAAG,UAAA,GAAAH,OAAA;AACA,MAAAI,gBAAA,GAAAJ,OAAA;AACA,MAAAK,OAAA,GAAAL,OAAA;AACA,MAAAM,WAAA,GAAAN,OAAA;AAMA,MAAMO,WAAW,GAAG,iBAAiB;AAErC,MAAM;EACJC,mBAAmB;EACnBC,yBAAyB;EACzBC;AAAc,CACf,GAAGX,KAAK,CAACY,SAAS;AAiBnB;;;;;;AAMA,SAASC,kBAAkBA,CAACC,KAAa;EACvC,KAAK,MAAM,CAACC,IAAI,EAAEC,GAAG,CAAC,IAAIC,MAAM,CAACC,OAAO,CAAChB,EAAE,CAACU,SAAS,CAACE,KAAK,CAAC,EAAE;IAC5D,IAAIE,GAAG,KAAKF,KAAK,EAAE;MACjB,OAAOC,IAAI;;;EAGf,OAAO,uBAAuB,GAAGD,KAAK;AACxC;AAmBA,MAAaK,mBAAmB;EAwB9BC,YACmBC,WAAoC,EACpCC,gBAAkC,EAClCC,QAA4C,EAC5CC,SAAoB,EACpBC,MAAc;IAJd,KAAAJ,WAAW,GAAXA,WAAW;IACX,KAAAC,gBAAgB,GAAhBA,gBAAgB;IAChB,KAAAC,QAAQ,GAARA,QAAQ;IACR,KAAAC,SAAS,GAATA,SAAS;IACT,KAAAC,MAAM,GAANA,MAAM;IA5BjB,KAAAC,OAAO,GAAG,IAAIrB,gBAAA,CAAAsB,aAAa,EAAE;IAE7B,KAAAC,mBAAmB,GAAG,KAAK;IAC3B,KAAAC,aAAa,GAAG,KAAK;IACrB,KAAAC,OAAO,GAAG,KAAK;IACvB;;;;IAIQ,KAAAC,WAAW,GAAG,KAAK;IAEnB,KAAAC,YAAY,GAAG,KAAK;IAEpB,KAAAC,oBAAoB,GAAa,EAAE;IAE3C;IACQ,KAAAC,gBAAgB,GAAW/B,WAAA,CAAAgC,MAAM,CAACC,OAAO;IAEjD;IACQ,KAAAC,WAAW,GAAwB,IAAI;IAEvC,KAAAC,aAAa,GAAuB,IAAI;IAS9CjB,WAAW,CAACkB,EAAE,CAAC,UAAU,EAAE,CAACC,OAAO,EAAEC,KAAK,KAAI;MAC5C,IAAIC,aAAa,GAAG,EAAE;MACtB,KAAK,MAAMC,MAAM,IAAI1B,MAAM,CAAC2B,IAAI,CAACJ,OAAO,CAAC,EAAE;QACzCE,aAAa,IAAI,MAAM,GAAGC,MAAM,GAAG,IAAI,GAAGH,OAAO,CAACG,MAAM,CAAC,GAAG,IAAI;;MAElE,IAAI,CAACE,KAAK,CAAC,4BAA4B,GAAGH,aAAa,CAAC;MACxD,QAAQF,OAAO,CAAC,SAAS,CAAC;QACxB;QACA,KAAK,GAAG;UACN,IAAI,CAACN,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACW,QAAQ;UACvC;QACF,KAAK,GAAG;UACN,IAAI,CAACZ,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACY,eAAe;UAC9C;QACF,KAAK,GAAG;UACN,IAAI,CAACb,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACa,iBAAiB;UAChD;QACF,KAAK,GAAG;UACN,IAAI,CAACd,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACc,aAAa;UAC5C;QACF,KAAK,GAAG;QACR,KAAK,GAAG;QACR,KAAK,GAAG;QACR,KAAK,GAAG;UACN,IAAI,CAACf,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACe,WAAW;UAC1C;QACF;UACE,IAAI,CAAChB,gBAAgB,GAAG/B,WAAA,CAAAgC,MAAM,CAACC,OAAO;MAAC;MAG3C,IAAIK,KAAK,GAAGzC,KAAK,CAACY,SAAS,CAACuC,uBAAuB,EAAE;QACnD,IAAI,CAACC,cAAc,CAACZ,OAAO,CAAC;OAC7B,MAAM;QACL,IAAIa,QAAkB;QACtB,IAAI;UACFA,QAAQ,GAAGjD,UAAA,CAAAkD,QAAQ,CAACC,gBAAgB,CAACf,OAAO,CAAC;SAC9C,CAAC,OAAOgB,KAAK,EAAE;UACd,IAAI,CAACC,OAAO,CAAC;YACXC,IAAI,EAAEvD,WAAA,CAAAgC,MAAM,CAACC,OAAO;YACpBuB,OAAO,EAAGH,KAAe,CAACI,OAAO;YACjCP,QAAQ,EAAE,IAAIjD,UAAA,CAAAkD,QAAQ;WACvB,CAAC;UACF;;QAEF,IAAI,CAAC/B,QAAQ,CAACsC,iBAAiB,CAACR,QAAQ,CAAC;;IAE7C,CAAC,CAAC;IACFhC,WAAW,CAACkB,EAAE,CAAC,UAAU,EAAGC,OAAkC,IAAI;MAChE,IAAI,CAACY,cAAc,CAACZ,OAAO,CAAC;IAC9B,CAAC,CAAC;IACFnB,WAAW,CAACkB,EAAE,CAAC,MAAM,EAAGuB,IAAY,IAAI;MACtC;;MAEA,IAAI,IAAI,CAAC9B,YAAY,EAAE;QACrB;;MAEF,IAAI,CAACa,KAAK,CAAC,sCAAsC,GAAGiB,IAAI,CAACC,MAAM,CAAC;MAChE,MAAMC,QAAQ,GAAG,IAAI,CAACtC,OAAO,CAACuC,KAAK,CAACH,IAAI,CAAC;MAEzC,KAAK,MAAMF,OAAO,IAAII,QAAQ,EAAE;QAC9B,IAAI,CAACnB,KAAK,CAAC,2BAA2B,GAAGe,OAAO,CAACG,MAAM,CAAC;QACxD,IAAI,CAACzC,gBAAiB,CAAC4C,kBAAkB,EAAE;QAC3C,IAAI,CAACC,OAAO,CAACP,OAAO,CAAC;;IAEzB,CAAC,CAAC;IACFvC,WAAW,CAACkB,EAAE,CAAC,KAAK,EAAE,MAAK;MACzB,IAAI,CAACR,WAAW,GAAG,IAAI;MACvB,IAAI,CAACqC,iBAAiB,EAAE;IAC1B,CAAC,CAAC;IACF/C,WAAW,CAACkB,EAAE,CAAC,OAAO,EAAE,MAAK;MAC3B;;;MAGA8B,OAAO,CAACC,QAAQ,CAAC,MAAK;;QACpB,IAAI,CAACzB,KAAK,CAAC,iCAAiC,GAAGxB,WAAW,CAACkD,OAAO,CAAC;QACnE;;;;QAIA,IAAI,EAAAC,EAAA,OAAI,CAACnC,WAAW,cAAAmC,EAAA,uBAAAA,EAAA,CAAEd,IAAI,MAAKvD,WAAA,CAAAgC,MAAM,CAACsC,EAAE,EAAE;UACxC;;QAEF,IAAIf,IAAY;QAChB,IAAIC,OAAO,GAAG,EAAE;QAChB,QAAQtC,WAAW,CAACkD,OAAO;UACzB,KAAKvE,KAAK,CAACY,SAAS,CAAC8D,gBAAgB;YACnC;;;YAGA,IAAI,IAAI,CAACrC,WAAW,KAAK,IAAI,EAAE;cAC7B;;YAEFqB,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACW,QAAQ;YACtBa,OAAO,GAAG,iCAAiCtC,WAAW,CAACkD,OAAO,EAAE;YAChE;UACF,KAAKvE,KAAK,CAACY,SAAS,CAAC+D,sBAAsB;YACzCjB,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACe,WAAW;YACzBS,OAAO,GAAG,0BAA0B;YACpC;UACF,KAAK3D,KAAK,CAACY,SAAS,CAACD,cAAc;YACjC+C,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACyC,SAAS;YACvBjB,OAAO,GAAG,gBAAgB;YAC1B;UACF,KAAK3D,KAAK,CAACY,SAAS,CAACiE,yBAAyB;YAC5CnB,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAAC2C,kBAAkB;YAChCnB,OAAO,GAAG,8CAA8C;YACxD;UACF,KAAK3D,KAAK,CAACY,SAAS,CAACmE,2BAA2B;YAC9CrB,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACa,iBAAiB;YAC/BW,OAAO,GAAG,4BAA4B;YACtC;UACF,KAAK3D,KAAK,CAACY,SAAS,CAACoE,sBAAsB;YACzCtB,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACW,QAAQ;YACtB,IAAI,IAAI,CAACR,aAAa,KAAK,IAAI,EAAE;cAC/B;;;;;cAKAqB,OAAO,GAAG,iCAAiCtC,WAAW,CAACkD,OAAO,0BAA0B;aACzF,MAAM;cACL,IAAI,IAAI,CAACjC,aAAa,CAACoB,IAAI,KAAK,YAAY,IAAI,IAAI,CAACpB,aAAa,CAACoB,IAAI,KAAK,WAAW,EAAE;gBACvFA,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACe,WAAW;gBACzBS,OAAO,GAAG,IAAI,CAACrB,aAAa,CAACsB,OAAO;eACrC,MAAM;gBACL;;;;gBAIAD,OAAO,GAAG,iCAAiCtC,WAAW,CAACkD,OAAO,wCAAwC,IAAI,CAACjC,aAAa,CAACsB,OAAO,EAAE;;;YAGtI;UACF;YACEF,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACW,QAAQ;YACtBa,OAAO,GAAG,iCAAiCtC,WAAW,CAACkD,OAAO,EAAE;QAAC;QAErE;QACA;QACA;QACA;QACA,IAAI,CAACd,OAAO,CAAC;UAAEC,IAAI;UAAEC,OAAO;UAAEN,QAAQ,EAAE,IAAIjD,UAAA,CAAAkD,QAAQ,EAAE;UAAEiB,OAAO,EAAElD,WAAW,CAACkD;QAAO,CAAE,CAAC;MACzF,CAAC,CAAC;IACJ,CAAC,CAAC;IACFlD,WAAW,CAACkB,EAAE,CAAC,OAAO,EAAG0C,GAAgB,IAAI;MAC3C;;;MAGA;;;;MAIA,IAAIA,GAAG,CAACvB,IAAI,KAAK,wBAAwB,EAAE;QACzC,IAAI,CAACb,KAAK,CACR,4BAA4B,GAC1BoC,GAAG,CAACrB,OAAO,GACX,QAAQ,GACRqB,GAAG,CAACvB,IAAI,GACR,SAAS,GACT7C,kBAAkB,CAACoE,GAAG,CAACnE,KAAK,CAAC,GAC7B,WAAW,GACXmE,GAAG,CAACC,OAAO,CACd;QACD,IAAI,CAAC5C,aAAa,GAAG2C,GAAG;;MAE1B,IAAI,CAAC3D,gBAAgB,CAAC6D,WAAW,CAAC,KAAK,CAAC;IAC1C,CAAC,CAAC;EACJ;EAEOC,YAAYA,CAAA;IACjB,IAAI,CAAC3B,OAAO,CAAC;MACXC,IAAI,EAAEvD,WAAA,CAAAgC,MAAM,CAACe,WAAW;MACxBS,OAAO,EAAE,oBAAoB;MAC7BN,QAAQ,EAAE,IAAIjD,UAAA,CAAAkD,QAAQ;KACvB,CAAC;EACJ;EAEQ+B,YAAYA,CAAA;IAClB;IACA,IAAI,CAAC,IAAI,CAACrD,YAAY,EAAE;MACtB,IAAI,CAACA,YAAY,GAAG,IAAI;MACxB,IAAI,CAACa,KAAK,CACR,0BAA0B,GACxB,IAAI,CAACR,WAAY,CAACqB,IAAI,GACtB,YAAY,GACZ,IAAI,CAACrB,WAAY,CAACsB,OAAO,GACzB,GAAG,CACN;MACD,IAAI,CAACrC,gBAAgB,CAACgE,SAAS,CAAC,IAAI,CAACjD,WAAY,CAAC;MAClD;;;;;;MAMAgC,OAAO,CAACC,QAAQ,CAAC,MAAK;QACpB,IAAI,CAAC/C,QAAQ,CAACgE,eAAe,CAAC,IAAI,CAAClD,WAAY,CAAC;MAClD,CAAC,CAAC;MACF;;;;MAIA,IAAI,CAAChB,WAAW,CAACmE,MAAM,EAAE;;EAE7B;EAEQ3C,KAAKA,CAAC4C,IAAY;IACxBnF,OAAO,CAACuC,KAAK,CACXtC,WAAA,CAAAmF,YAAY,CAACC,KAAK,EAClBnF,WAAW,EACX,GAAG,GAAG,IAAI,CAACiB,MAAM,GAAG,IAAI,GAAGgE,IAAI,CAChC;EACH;EAEA;;;;;EAKQhC,OAAOA,CAACmC,MAA+B;IAC7C;;IAEA,IAAI,IAAI,CAACvD,WAAW,KAAK,IAAI,IAAI,IAAI,CAACA,WAAW,CAACqB,IAAI,KAAKvD,WAAA,CAAAgC,MAAM,CAACsC,EAAE,EAAE;MACpE,IAAI,CAACpC,WAAW,GAAGuD,MAAM;MACzB,IAAI,CAACxB,iBAAiB,EAAE;;IAE1B,IAAI,CAACyB,kBAAkB,EAAE;EAC3B;EAEQzB,iBAAiBA,CAAA;IACvB,IAAI,IAAI,CAAC/B,WAAW,KAAK,IAAI,EAAE;MAC7B;;;MAGA,IACE,IAAI,CAACA,WAAW,CAACqB,IAAI,KAAKvD,WAAA,CAAAgC,MAAM,CAACsC,EAAE,IAClC,IAAI,CAAC1C,WAAW,IACf,IAAI,CAACE,oBAAoB,CAAC8B,MAAM,KAAK,CAAC,IACtC,CAAC,IAAI,CAACnC,mBAAmB,IACzB,CAAC,IAAI,CAACC,aAAc,EACtB;QACA,IAAI,CAACwD,YAAY,EAAE;;;EAGzB;EAEQS,IAAIA,CAAClC,OAAe;IAC1B,IAAI,CAACf,KAAK,CACR,sCAAsC,IACnCe,OAAO,YAAYmC,MAAM,GAAGnC,OAAO,CAACG,MAAM,GAAG,IAAI,CAAC,CACtD;IACD,IAAI,CAACjC,OAAO,GAAG,KAAK;IACpB,IAAI,CAACD,aAAa,GAAG,IAAI;IACzBwC,OAAO,CAACC,QAAQ,CAAC,MAAK;MACpB,IAAI,CAACzC,aAAa,GAAG,KAAK;MAC1B;;;;MAIA,IAAI,IAAI,CAACG,YAAY,EAAE;QACrB;;MAEF,IAAI,CAACT,QAAQ,CAACyE,gBAAgB,CAACpC,OAAO,CAAC;MACvC,IAAI,CAACQ,iBAAiB,EAAE;IAC1B,CAAC,CAAC;EACJ;EAEQD,OAAOA,CAAC8B,YAAoB;IAClC,IAAI,IAAI,CAACnE,OAAO,EAAE;MAChB,IAAI,CAACT,WAAY,CAAC6E,KAAK,EAAE;MACzB,IAAI,CAACJ,IAAI,CAACG,YAAY,CAAC;KACxB,MAAM;MACL,IAAI,CAACpD,KAAK,CACR,8CAA8C,GAAGoD,YAAY,CAAClC,MAAM,CACrE;MACD,IAAI,CAAC9B,oBAAoB,CAAC6D,IAAI,CAACG,YAAY,CAAC;;EAEhD;EAEQ7C,cAAcA,CAACZ,OAAkC;IACvD,IAAI,CAAClB,gBAAgB,CAAC6D,WAAW,CAAC,IAAI,CAAC;IACvC,IAAIzC,aAAa,GAAG,EAAE;IACtB,KAAK,MAAMC,MAAM,IAAI1B,MAAM,CAAC2B,IAAI,CAACJ,OAAO,CAAC,EAAE;MACzCE,aAAa,IAAI,MAAM,GAAGC,MAAM,GAAG,IAAI,GAAGH,OAAO,CAACG,MAAM,CAAC,GAAG,IAAI;;IAElE,IAAI,CAACE,KAAK,CAAC,6BAA6B,GAAGH,aAAa,CAAC;IACzD,IAAIW,QAAkB;IACtB,IAAI;MACFA,QAAQ,GAAGjD,UAAA,CAAAkD,QAAQ,CAACC,gBAAgB,CAACf,OAAO,CAAC;KAC9C,CAAC,OAAO2D,CAAC,EAAE;MACV9C,QAAQ,GAAG,IAAIjD,UAAA,CAAAkD,QAAQ,EAAE;;IAE3B,MAAM8C,WAAW,GAAG/C,QAAQ,CAACgD,MAAM,EAAE;IACrC,IAAI3C,IAAI,GAAW,IAAI,CAACxB,gBAAgB;IACxC,IACEwB,IAAI,KAAKvD,WAAA,CAAAgC,MAAM,CAACC,OAAO,IACvB,OAAOgE,WAAW,CAAC,aAAa,CAAC,KAAK,QAAQ,EAC9C;MACA,MAAME,cAAc,GAAGC,MAAM,CAACH,WAAW,CAAC,aAAa,CAAC,CAAC;MACzD,IAAIE,cAAc,IAAInG,WAAA,CAAAgC,MAAM,EAAE;QAC5BuB,IAAI,GAAG4C,cAAc;QACrB,IAAI,CAACzD,KAAK,CAAC,uBAAuB,GAAGyD,cAAc,GAAG,cAAc,CAAC;;MAEvEjD,QAAQ,CAACmD,MAAM,CAAC,aAAa,CAAC;;IAEhC,IAAI7C,OAAO,GAAG,EAAE;IAChB,IAAI,OAAOyC,WAAW,CAAC,cAAc,CAAC,KAAK,QAAQ,EAAE;MACnD,IAAI;QACFzC,OAAO,GAAG8C,SAAS,CAACL,WAAW,CAAC,cAAc,CAAC,CAAC;OACjD,CAAC,OAAOD,CAAC,EAAE;QACVxC,OAAO,GAAGyC,WAAW,CAAC,cAAc,CAAC;;MAEvC/C,QAAQ,CAACmD,MAAM,CAAC,cAAc,CAAC;MAC/B,IAAI,CAAC3D,KAAK,CACR,kCAAkC,GAAGc,OAAO,GAAG,eAAe,CAC/D;;IAEH,MAAMiC,MAAM,GAAiB;MAAElC,IAAI;MAAEC,OAAO;MAAEN;IAAQ,CAAE;IACxD;IACA,IAAI,CAACI,OAAO,CAACmC,MAAM,CAAC;EACtB;EAEQC,kBAAkBA,CAAA;;IACxB;IACA;IACA,IAAI,CAAC,IAAI,CAACxE,WAAW,CAACqF,SAAS,EAAE;MAC/B;;;MAGA,IAAIhD,IAAY;MAChB,IAAI,EAAAc,EAAA,OAAI,CAACnC,WAAW,cAAAmC,EAAA,uBAAAA,EAAA,CAAEd,IAAI,MAAKvD,WAAA,CAAAgC,MAAM,CAACsC,EAAE,EAAE;QACxCf,IAAI,GAAG1D,KAAK,CAACY,SAAS,CAAC8D,gBAAgB;OACxC,MAAM;QACLhB,IAAI,GAAG1D,KAAK,CAACY,SAAS,CAACD,cAAc;;MAEvC,IAAI,CAACkC,KAAK,CAAC,+BAA+B,GAAGa,IAAI,CAAC;MAClD,IAAI,CAACrC,WAAW,CAACsF,KAAK,CAACjD,IAAI,CAAC;;EAEhC;EAEAkD,gBAAgBA,CAAChB,MAAc,EAAEjC,OAAe;IAC9C,IAAI,CAACd,KAAK,CACR,yBAAyB,GAAG+C,MAAM,GAAG,aAAa,GAAGjC,OAAO,GAAG,GAAG,CACnE;IACD,IAAI,CAACF,OAAO,CAAC;MAAEC,IAAI,EAAEkC,MAAM;MAAEjC,OAAO;MAAEN,QAAQ,EAAE,IAAIjD,UAAA,CAAAkD,QAAQ;IAAE,CAAE,CAAC;EACnE;EAEAuD,SAASA,CAAA;IACP,OAAO,IAAI,CAACxE,WAAW;EACzB;EAEAyE,OAAOA,CAAA;IACL,OAAO,IAAI,CAACtF,SAAS,CAACuF,WAAW,EAAE;EACrC;EAEAC,aAAaA,CAAA;IACX,OAAO,IAAI,CAACvF,MAAM;EACpB;EAEAwF,SAASA,CAAA;IACP;;IAEA,IAAI,IAAI,CAAC5E,WAAW,KAAK,IAAI,IAAI,IAAI,CAACA,WAAW,CAACqB,IAAI,KAAKvD,WAAA,CAAAgC,MAAM,CAACsC,EAAE,EAAE;MACpE,IAAI,CAAC1C,WAAW,GAAG,IAAI;MACvB,IAAI,CAACqC,iBAAiB,EAAE;MACxB;;IAEF,IAAI,CAACtC,OAAO,GAAG,IAAI;IACnB,IAAI,IAAI,CAACG,oBAAoB,CAAC8B,MAAM,GAAG,CAAC,EAAE;MACxC,MAAMmD,WAAW,GAAW,IAAI,CAACjF,oBAAoB,CAACkF,KAAK,EAAG;MAC9D,IAAI,CAACrB,IAAI,CAACoB,WAAW,CAAC;MACtB;;IAEF;;IAEA,IAAI,CAAC7F,WAAW,CAACmE,MAAM,EAAE;EAC3B;EAEA4B,sBAAsBA,CAACC,OAAuB,EAAEzD,OAAe;IAC7D,IAAI,CAACf,KAAK,CAAC,wCAAwC,GAAGe,OAAO,CAACG,MAAM,CAAC;IACrE,MAAMuD,EAAE,GAAmB9D,KAAoB,IAAI;;MACjD,IAAIE,IAAI,GAAWvD,WAAA,CAAAgC,MAAM,CAACe,WAAW;MACrC,IAAI,CAACM,KAA+B,aAA/BA,KAAK,uBAALA,KAAK,CAA4BE,IAAI,MAAK,4BAA4B,EAAE;QAC3EA,IAAI,GAAGvD,WAAA,CAAAgC,MAAM,CAACW,QAAQ;;MAExB,IAAIU,KAAK,EAAE;QACT,IAAI,CAACoD,gBAAgB,CAAClD,IAAI,EAAE,gBAAgBF,KAAK,CAACI,OAAO,EAAE,CAAC;;MAE9D,CAAAY,EAAA,GAAA6C,OAAO,CAACE,QAAQ,cAAA/C,EAAA,uBAAAA,EAAA,CAAAgD,IAAA,CAAAH,OAAA,CAAI;IACtB,CAAC;IACD,IAAI,CAACxE,KAAK,CAAC,+BAA+B,GAAGe,OAAO,CAACG,MAAM,CAAC;IAC5D,IAAI,CAACzC,gBAAgB,CAACmG,cAAc,EAAE;IACtC,IAAI;MACF,IAAI,CAACpG,WAAY,CAAC4C,KAAK,CAACL,OAAO,EAAE0D,EAAE,CAAC;KACrC,CAAC,OAAO9D,KAAK,EAAE;MACd,IAAI,CAACC,OAAO,CAAC;QACXC,IAAI,EAAEvD,WAAA,CAAAgC,MAAM,CAACe,WAAW;QACxBS,OAAO,EAAE,2BAA4BH,KAAe,CAACI,OAAO,EAAE;QAC9DP,QAAQ,EAAE,IAAIjD,UAAA,CAAAkD,QAAQ;OACvB,CAAC;;EAEN;EAEAoE,SAASA,CAAA;IACP,IAAI,CAAC7E,KAAK,CAAC,cAAc,CAAC;IAC1B,IAAI,CAACA,KAAK,CAAC,gCAAgC,CAAC;IAC5C,IAAI,CAACxB,WAAW,CAACsG,GAAG,EAAE;EACxB;;AAtbFC,OAAA,CAAAzG,mBAAA,GAAAA,mBAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}