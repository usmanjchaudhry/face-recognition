{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.PickFirstLoadBalancer = exports.PickFirstLoadBalancingConfig = void 0;\nconst load_balancer_1 = require(\"./load-balancer\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst picker_1 = require(\"./picker\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst TRACER_NAME = 'pick_first';\nfunction trace(text) {\n  logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);\n}\nconst TYPE_NAME = 'pick_first';\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\nclass PickFirstLoadBalancingConfig {\n  getLoadBalancerName() {\n    return TYPE_NAME;\n  }\n  constructor() {}\n  toJsonObject() {\n    return {\n      [TYPE_NAME]: {}\n    };\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj) {\n    return new PickFirstLoadBalancingConfig();\n  }\n}\nexports.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker {\n  constructor(subchannel) {\n    this.subchannel = subchannel;\n  }\n  pick(pickArgs) {\n    return {\n      pickResultType: picker_1.PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\nclass PickFirstLoadBalancer {\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    /**\n     * The list of backend addresses most recently passed to `updateAddressList`.\n     */\n    this.latestAddressList = [];\n    /**\n     * The list of subchannels this load balancer is currently attempting to\n     * connect to.\n     */\n    this.subchannels = [];\n    /**\n     * The current connectivity state of the load balancer.\n     */\n    this.currentState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The index within the `subchannels` array of the subchannel with the most\n     * recently started connection attempt.\n     */\n    this.currentSubchannelIndex = 0;\n    /**\n     * The currently picked subchannel used for making calls. Populated if\n     * and only if the load balancer's current state is READY. In that case,\n     * the subchannel's current state is also READY.\n     */\n    this.currentPick = null;\n    this.triedAllSubchannels = false;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannelStateListener = (subchannel, previousState, newState) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n      if (subchannel.getRealSubchannel() === this.subchannels[this.currentSubchannelIndex].getRealSubchannel() && newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.startNextSubchannelConnecting();\n      }\n      if (newState === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (this.triedAllSubchannels && this.subchannelStateCounts[connectivity_state_1.ConnectivityState.IDLE] === this.subchannels.length) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources. We do not reset triedAllSubchannels\n           * because that is a reminder to request reresolution the next time\n           * this LB policy needs to connect. */\n          this.resetSubchannelList(false);\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n          return;\n        }\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n            if (newLBState !== this.currentState) {\n              if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new picker_1.UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new picker_1.QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        }\n      }\n    };\n    this.pickedSubchannelStateListener = (subchannel, previousState, newState) => {\n      if (newState !== connectivity_state_1.ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState;\n            if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.CONNECTING] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.CONNECTING;\n            } else if (this.subchannelStateCounts[connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE] > 0) {\n              newLBState = connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = connectivity_state_1.ConnectivityState.IDLE;\n            }\n            if (newLBState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new picker_1.UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new picker_1.QueuePicker(this));\n            }\n          } else {\n            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));\n        }\n      }\n    };\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n        if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n  }\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  startConnecting(subchannelIndex) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (this.subchannels[subchannelIndex].getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {\n      trace('Start connecting to subchannel with address ' + this.subchannels[subchannelIndex].getAddress());\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n  pickSubchannel(subchannel) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n    }\n    this.currentPick = subchannel;\n    this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n  updateState(newState, picker) {\n    trace(connectivity_state_1.ConnectivityState[this.currentState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n  resetSubchannelList() {\n    let resetTriedAllSubchannels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [connectivity_state_1.ConnectivityState.CONNECTING]: 0,\n      [connectivity_state_1.ConnectivityState.IDLE]: 0,\n      [connectivity_state_1.ConnectivityState.READY]: 0,\n      [connectivity_state_1.ConnectivityState.SHUTDOWN]: 0,\n      [connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE]: 0\n    };\n    this.subchannels = [];\n    if (resetTriedAllSubchannels) {\n      this.triedAllSubchannels = false;\n    }\n  }\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n  connectToAddressList() {\n    this.resetSubchannelList();\n    trace('Connect to address list ' + this.latestAddressList.map(address => (0, subchannel_address_1.subchannelAddressToString)(address)));\n    this.subchannels = this.latestAddressList.map(address => this.channelControlHelper.createSubchannel(address, {}));\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n      if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n      if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {\n        this.startConnecting(index);\n        if (this.currentPick === null) {\n          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));\n        }\n        return;\n      }\n    }\n    // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n    if (this.currentPick === null) {\n      this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker());\n    }\n  }\n  updateAddressList(addressList, lbConfig) {\n    // lbConfig has no useful information for pick first load balancing\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (this.subchannels.length === 0 || this.latestAddressList.length !== addressList.length || !this.latestAddressList.every((value, index) => addressList[index] && (0, subchannel_address_1.subchannelAddressEqual)(addressList[index], value))) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n  exitIdle() {\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.triedAllSubchannels) {\n      this.channelControlHelper.requestReresolution();\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n    if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n  }\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n  destroy() {\n    this.resetSubchannelList();\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(this.pickedSubchannelStateListener);\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n  getTypeName() {\n    return TYPE_NAME;\n  }\n}\nexports.PickFirstLoadBalancer = PickFirstLoadBalancer;\nfunction setup() {\n  (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);\n  (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);\n}\nexports.setup = setup;","map":{"version":3,"names":["load_balancer_1","require","connectivity_state_1","picker_1","subchannel_address_1","logging","constants_1","TRACER_NAME","trace","text","LogVerbosity","DEBUG","TYPE_NAME","CONNECTION_DELAY_INTERVAL_MS","PickFirstLoadBalancingConfig","getLoadBalancerName","constructor","toJsonObject","createFromJson","obj","exports","PickFirstPicker","subchannel","pick","pickArgs","pickResultType","PickResultType","COMPLETE","status","onCallStarted","onCallEnded","PickFirstLoadBalancer","channelControlHelper","latestAddressList","subchannels","currentState","ConnectivityState","IDLE","currentSubchannelIndex","currentPick","triedAllSubchannels","subchannelStateCounts","CONNECTING","READY","SHUTDOWN","TRANSIENT_FAILURE","subchannelStateListener","previousState","newState","getRealSubchannel","startNextSubchannelConnecting","pickSubchannel","length","resetSubchannelList","updateState","QueuePicker","newLBState","UnavailablePicker","pickedSubchannelStateListener","unref","removeConnectivityStateListener","removeChannelzChild","getChannelzRef","connectionDelayTimeout","setTimeout","clearTimeout","index","entries","subchannelState","getConnectivityState","startConnecting","subchannelIndex","getAddress","process","nextTick","addConnectivityStateListener","ref","addChannelzChild","picker","resetTriedAllSubchannels","arguments","undefined","connectToAddressList","map","address","subchannelAddressToString","createSubchannel","updateAddressList","addressList","lbConfig","every","value","subchannelAddressEqual","exitIdle","requestReresolution","resetBackoff","destroy","getTypeName","setup","registerLoadBalancerType","registerDefaultLoadBalancerType"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/load-balancer-pick-first.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  registerDefaultLoadBalancerType,\n  registerLoadBalancerType,\n} from './load-balancer';\nimport { ConnectivityState } from './connectivity-state';\nimport {\n  QueuePicker,\n  Picker,\n  PickArgs,\n  CompletePickResult,\n  PickResultType,\n  UnavailablePicker,\n} from './picker';\nimport {\n  SubchannelAddress,\n  subchannelAddressEqual,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport * as logging from './logging';\nimport { LogVerbosity } from './constants';\nimport { SubchannelInterface, ConnectivityStateListener } from './subchannel-interface';\n\nconst TRACER_NAME = 'pick_first';\n\nfunction trace(text: string): void {\n  logging.trace(LogVerbosity.DEBUG, TRACER_NAME, text);\n}\n\nconst TYPE_NAME = 'pick_first';\n\n/**\n * Delay after starting a connection on a subchannel before starting a\n * connection on the next subchannel in the list, for Happy Eyeballs algorithm.\n */\nconst CONNECTION_DELAY_INTERVAL_MS = 250;\n\nexport class PickFirstLoadBalancingConfig implements LoadBalancingConfig {\n  getLoadBalancerName(): string {\n    return TYPE_NAME;\n  }\n\n  constructor() {}\n\n  toJsonObject(): object {\n    return {\n      [TYPE_NAME]: {},\n    };\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static createFromJson(obj: any) {\n    return new PickFirstLoadBalancingConfig();\n  }\n}\n\n/**\n * Picker for a `PickFirstLoadBalancer` in the READY state. Always returns the\n * picked subchannel.\n */\nclass PickFirstPicker implements Picker {\n  constructor(private subchannel: SubchannelInterface) {}\n\n  pick(pickArgs: PickArgs): CompletePickResult {\n    return {\n      pickResultType: PickResultType.COMPLETE,\n      subchannel: this.subchannel,\n      status: null,\n      onCallStarted: null,\n      onCallEnded: null\n    };\n  }\n}\n\ninterface ConnectivityStateCounts {\n  [ConnectivityState.CONNECTING]: number;\n  [ConnectivityState.IDLE]: number;\n  [ConnectivityState.READY]: number;\n  [ConnectivityState.SHUTDOWN]: number;\n  [ConnectivityState.TRANSIENT_FAILURE]: number;\n}\n\nexport class PickFirstLoadBalancer implements LoadBalancer {\n  /**\n   * The list of backend addresses most recently passed to `updateAddressList`.\n   */\n  private latestAddressList: SubchannelAddress[] = [];\n  /**\n   * The list of subchannels this load balancer is currently attempting to\n   * connect to.\n   */\n  private subchannels: SubchannelInterface[] = [];\n  /**\n   * The current connectivity state of the load balancer.\n   */\n  private currentState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The index within the `subchannels` array of the subchannel with the most\n   * recently started connection attempt.\n   */\n  private currentSubchannelIndex = 0;\n\n  private subchannelStateCounts: ConnectivityStateCounts;\n  /**\n   * The currently picked subchannel used for making calls. Populated if\n   * and only if the load balancer's current state is READY. In that case,\n   * the subchannel's current state is also READY.\n   */\n  private currentPick: SubchannelInterface | null = null;\n  /**\n   * Listener callback attached to each subchannel in the `subchannels` list\n   * while establishing a connection.\n   */\n  private subchannelStateListener: ConnectivityStateListener;\n  /**\n   * Listener callback attached to the current picked subchannel.\n   */\n  private pickedSubchannelStateListener: ConnectivityStateListener;\n  /**\n   * Timer reference for the timer tracking when to start\n   */\n  private connectionDelayTimeout: NodeJS.Timeout;\n\n  private triedAllSubchannels = false;\n\n  /**\n   * Load balancer that attempts to connect to each backend in the address list\n   * in order, and picks the first one that connects, using it for every\n   * request.\n   * @param channelControlHelper `ChannelControlHelper` instance provided by\n   *     this load balancer's owner.\n   */\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      this.subchannelStateCounts[previousState] -= 1;\n      this.subchannelStateCounts[newState] += 1;\n      /* If the subchannel we most recently attempted to start connecting\n       * to goes into TRANSIENT_FAILURE, immediately try to start\n       * connecting to the next one instead of waiting for the connection\n       * delay timer. */\n      if (\n        subchannel.getRealSubchannel() === this.subchannels[this.currentSubchannelIndex].getRealSubchannel() &&\n        newState === ConnectivityState.TRANSIENT_FAILURE\n      ) {\n        this.startNextSubchannelConnecting();\n      }\n      if (newState === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        return;\n      } else {\n        if (\n          this.triedAllSubchannels &&\n          this.subchannelStateCounts[ConnectivityState.IDLE] ===\n            this.subchannels.length\n        ) {\n          /* If all of the subchannels are IDLE we should go back to a\n           * basic IDLE state where there is no subchannel list to avoid\n           * holding unused resources. We do not reset triedAllSubchannels\n           * because that is a reminder to request reresolution the next time\n           * this LB policy needs to connect. */\n          this.resetSubchannelList(false);\n          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n          return;\n        }\n        if (this.currentPick === null) {\n          if (this.triedAllSubchannels) {\n            let newLBState: ConnectivityState;\n            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n              newLBState = ConnectivityState.CONNECTING;\n            } else if (\n              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >\n              0\n            ) {\n              newLBState = ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = ConnectivityState.IDLE;\n            }\n            if (newLBState !== this.currentState) {\n              if (newLBState === ConnectivityState.TRANSIENT_FAILURE) {\n                this.updateState(newLBState, new UnavailablePicker());\n              } else {\n                this.updateState(newLBState, new QueuePicker(this));\n              }\n            }\n          } else {\n            this.updateState(\n              ConnectivityState.CONNECTING,\n              new QueuePicker(this)\n            );\n          }\n        }\n      }\n    };\n    this.pickedSubchannelStateListener = (\n      subchannel: SubchannelInterface,\n      previousState: ConnectivityState,\n      newState: ConnectivityState\n    ) => {\n      if (newState !== ConnectivityState.READY) {\n        this.currentPick = null;\n        subchannel.unref();\n        subchannel.removeConnectivityStateListener(\n          this.pickedSubchannelStateListener\n        );\n        this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n        if (this.subchannels.length > 0) {\n          if (this.triedAllSubchannels) {\n            let newLBState: ConnectivityState;\n            if (this.subchannelStateCounts[ConnectivityState.CONNECTING] > 0) {\n              newLBState = ConnectivityState.CONNECTING;\n            } else if (\n              this.subchannelStateCounts[ConnectivityState.TRANSIENT_FAILURE] >\n              0\n            ) {\n              newLBState = ConnectivityState.TRANSIENT_FAILURE;\n            } else {\n              newLBState = ConnectivityState.IDLE;\n            }\n            if (newLBState === ConnectivityState.TRANSIENT_FAILURE) {\n              this.updateState(newLBState, new UnavailablePicker());\n            } else {\n              this.updateState(newLBState, new QueuePicker(this));\n            }\n          } else {\n            this.updateState(\n              ConnectivityState.CONNECTING,\n              new QueuePicker(this)\n            );\n          }\n        } else {\n          /* We don't need to backoff here because this only happens if a\n           * subchannel successfully connects then disconnects, so it will not\n           * create a loop of attempting to connect to an unreachable backend\n           */\n          this.updateState(ConnectivityState.IDLE, new QueuePicker(this));\n        }\n      }\n    };\n    this.connectionDelayTimeout = setTimeout(() => {}, 0);\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private startNextSubchannelConnecting() {\n    if (this.triedAllSubchannels) {\n      return;\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      if (index > this.currentSubchannelIndex) {\n        const subchannelState = subchannel.getConnectivityState();\n        if (\n          subchannelState === ConnectivityState.IDLE ||\n          subchannelState === ConnectivityState.CONNECTING\n        ) {\n          this.startConnecting(index);\n          return;\n        }\n      }\n    }\n    this.triedAllSubchannels = true;\n  }\n\n  /**\n   * Have a single subchannel in the `subchannels` list start connecting.\n   * @param subchannelIndex The index into the `subchannels` list.\n   */\n  private startConnecting(subchannelIndex: number) {\n    clearTimeout(this.connectionDelayTimeout);\n    this.currentSubchannelIndex = subchannelIndex;\n    if (\n      this.subchannels[subchannelIndex].getConnectivityState() ===\n      ConnectivityState.IDLE\n    ) {\n      trace(\n        'Start connecting to subchannel with address ' +\n          this.subchannels[subchannelIndex].getAddress()\n      );\n      process.nextTick(() => {\n        this.subchannels[subchannelIndex].startConnecting();\n      });\n    }\n    this.connectionDelayTimeout = setTimeout(() => {\n      this.startNextSubchannelConnecting();\n    }, CONNECTION_DELAY_INTERVAL_MS);\n  }\n\n  private pickSubchannel(subchannel: SubchannelInterface) {\n    trace('Pick subchannel with address ' + subchannel.getAddress());\n    if (this.currentPick !== null) {\n      this.currentPick.unref();\n      this.currentPick.removeConnectivityStateListener(\n        this.pickedSubchannelStateListener\n      );\n    }\n    this.currentPick = subchannel;\n    this.updateState(ConnectivityState.READY, new PickFirstPicker(subchannel));\n    subchannel.addConnectivityStateListener(this.pickedSubchannelStateListener);\n    subchannel.ref();\n    this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    this.resetSubchannelList();\n    clearTimeout(this.connectionDelayTimeout);\n  }\n\n  private updateState(newState: ConnectivityState, picker: Picker) {\n    trace(\n      ConnectivityState[this.currentState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    this.currentState = newState;\n    this.channelControlHelper.updateState(newState, picker);\n  }\n\n  private resetSubchannelList(resetTriedAllSubchannels = true) {\n    for (const subchannel of this.subchannels) {\n      subchannel.removeConnectivityStateListener(this.subchannelStateListener);\n      subchannel.unref();\n      this.channelControlHelper.removeChannelzChild(subchannel.getChannelzRef());\n    }\n    this.currentSubchannelIndex = 0;\n    this.subchannelStateCounts = {\n      [ConnectivityState.CONNECTING]: 0,\n      [ConnectivityState.IDLE]: 0,\n      [ConnectivityState.READY]: 0,\n      [ConnectivityState.SHUTDOWN]: 0,\n      [ConnectivityState.TRANSIENT_FAILURE]: 0,\n    };\n    this.subchannels = [];\n    if (resetTriedAllSubchannels) {\n      this.triedAllSubchannels = false;\n    }\n  }\n\n  /**\n   * Start connecting to the address list most recently passed to\n   * `updateAddressList`.\n   */\n  private connectToAddressList(): void {\n    this.resetSubchannelList();\n    trace(\n      'Connect to address list ' +\n        this.latestAddressList.map((address) =>\n          subchannelAddressToString(address)\n        )\n    );\n    this.subchannels = this.latestAddressList.map((address) =>\n      this.channelControlHelper.createSubchannel(address, {})\n    );\n    for (const subchannel of this.subchannels) {\n      subchannel.ref();\n      this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.addConnectivityStateListener(this.subchannelStateListener);\n      this.subchannelStateCounts[subchannel.getConnectivityState()] += 1;\n      if (subchannel.getConnectivityState() === ConnectivityState.READY) {\n        this.pickSubchannel(subchannel);\n        this.resetSubchannelList();\n        return;\n      }\n    }\n    for (const [index, subchannel] of this.subchannels.entries()) {\n      const subchannelState = subchannel.getConnectivityState();\n      if (\n        subchannelState === ConnectivityState.IDLE ||\n        subchannelState === ConnectivityState.CONNECTING\n      ) {\n        this.startConnecting(index);\n        if (this.currentPick === null) {\n          this.updateState(ConnectivityState.CONNECTING, new QueuePicker(this));\n        }\n        return;\n      }\n    }\n    // If the code reaches this point, every subchannel must be in TRANSIENT_FAILURE\n    if (this.currentPick === null) {\n      this.updateState(\n        ConnectivityState.TRANSIENT_FAILURE,\n        new UnavailablePicker()\n      );\n    }\n  }\n\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig\n  ): void {\n    // lbConfig has no useful information for pick first load balancing\n    /* To avoid unnecessary churn, we only do something with this address list\n     * if we're not currently trying to establish a connection, or if the new\n     * address list is different from the existing one */\n    if (\n      this.subchannels.length === 0 ||\n      this.latestAddressList.length !== addressList.length ||\n      !this.latestAddressList.every(\n        (value, index) => addressList[index] && subchannelAddressEqual(addressList[index], value)\n      )\n    ) {\n      this.latestAddressList = addressList;\n      this.connectToAddressList();\n    }\n  }\n\n  exitIdle() {\n    if (\n      this.currentState === ConnectivityState.IDLE ||\n      this.triedAllSubchannels\n    ) {\n      this.channelControlHelper.requestReresolution();\n    }\n    for (const subchannel of this.subchannels) {\n      subchannel.startConnecting();\n    }\n    if (this.currentState === ConnectivityState.IDLE) {\n      if (this.latestAddressList.length > 0) {\n        this.connectToAddressList();\n      }\n    }\n  }\n\n  resetBackoff() {\n    /* The pick first load balancer does not have a connection backoff, so this\n     * does nothing */\n  }\n\n  destroy() {\n    this.resetSubchannelList();\n    if (this.currentPick !== null) {\n      /* Unref can cause a state change, which can cause a change in the value\n       * of this.currentPick, so we hold a local reference to make sure that\n       * does not impact this function. */\n      const currentPick = this.currentPick;\n      currentPick.unref();\n      currentPick.removeConnectivityStateListener(\n        this.pickedSubchannelStateListener\n      );\n      this.channelControlHelper.removeChannelzChild(currentPick.getChannelzRef());\n    }\n  }\n\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n\nexport function setup(): void {\n  registerLoadBalancerType(\n    TYPE_NAME,\n    PickFirstLoadBalancer,\n    PickFirstLoadBalancingConfig\n  );\n  registerDefaultLoadBalancerType(TYPE_NAME);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}