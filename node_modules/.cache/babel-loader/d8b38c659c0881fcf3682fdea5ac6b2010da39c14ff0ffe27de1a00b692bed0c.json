{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Http2SubchannelConnector = void 0;\nconst http2 = require(\"http2\");\nconst tls_1 = require(\"tls\");\nconst channelz_1 = require(\"./channelz\");\nconst constants_1 = require(\"./constants\");\nconst http_proxy_1 = require(\"./http_proxy\");\nconst logging = require(\"./logging\");\nconst resolver_1 = require(\"./resolver\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst net = require(\"net\");\nconst subchannel_call_1 = require(\"./subchannel-call\");\nconst call_number_1 = require(\"./call-number\");\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\nconst clientVersion = require('../../package.json').version;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\nclass Http2Transport {\n  constructor(session, subchannelAddress, options) {\n    this.session = session;\n    /**\n     * The amount of time in between sending pings\n     */\n    this.keepaliveTimeMs = -1;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Timer reference tracking when the most recent ping will be considered lost\n     */\n    this.keepaliveTimeoutId = null;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n    this.keepaliveWithoutCalls = false;\n    this.activeCalls = new Set();\n    this.disconnectListeners = [];\n    this.disconnectHandled = false;\n    this.channelzEnabled = true;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n    // Build user-agent string.\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    if (this.keepaliveWithoutCalls) {\n      this.startKeepalivePings();\n    }\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n        tooManyPings = true;\n      }\n      this.trace('connection closed by GOAWAY with code ' + errorCode);\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', settings => {\n        this.trace('new settings received' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n      session.on('localSettings', settings => {\n        this.trace('local settings acknowledged by remote' + (this.session !== session ? ' on the old connection' : '') + ': ' + JSON.stringify(settings));\n      });\n    }\n  }\n  getChannelzInfo() {\n    var _a, _b, _c;\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  keepaliveTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  flowControlTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  internalsTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns\n   */\n  reportDisconnectToOwner(tooManyPings) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n  clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n  sendPing() {\n    var _a, _b;\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    try {\n      this.session.ping((err, duration, payload) => {\n        this.keepaliveTrace('Received ping response');\n        this.clearKeepaliveTimeout();\n      });\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n  startKeepalivePings() {\n    var _a, _b;\n    if (this.keepaliveTimeMs < 0) {\n      return;\n    }\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    this.clearKeepaliveTimeout();\n  }\n  removeActiveCall(call) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n    }\n  }\n  addActiveCall(call) {\n    if (this.activeCalls.size === 0) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.activeCalls.add(call);\n  }\n  createCall(metadata, host, method, listener, subchannelCallStatsTracker) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace('local window size: ' + this.session.state.localWindowSize + ' remote window size: ' + this.session.state.remoteWindowSize);\n    this.internalsTrace('session.closed=' + this.session.closed + ' session.destroyed=' + this.session.destroyed + ' session.socket.destroyed=' + this.session.socket.destroyed);\n    let eventTracker;\n    let call;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageSent) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        addMessageReceived: () => {\n          var _a;\n          (_a = subchannelCallStatsTracker.addMessageReceived) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker);\n        },\n        onCallEnd: status => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onCallEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          var _a;\n          (_a = subchannelCallStatsTracker.onStreamEnd) === null || _a === void 0 ? void 0 : _a.call(subchannelCallStatsTracker, success);\n        }\n      };\n    }\n    call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());\n    this.addActiveCall(call);\n    return call;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n  shutdown() {\n    this.session.close();\n  }\n}\nclass Http2SubchannelConnector {\n  constructor(channelTarget) {\n    this.channelTarget = channelTarget;\n    this.session = null;\n    this.isShutdown = false;\n  }\n  trace(text) {}\n  createSession(address, credentials, options, proxyConnectionResult) {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise((resolve, reject) => {\n      var _a, _b, _c;\n      let remoteName;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n      }\n      const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n      let connectionOptions = credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options['grpc-node.max_session_memory'];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n          connectionOptions.checkServerIdentity = (host, cert) => {\n            return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname = (_c = (_b = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n      connectionOptions = Object.assign(Object.assign({}, connectionOptions), address);\n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + error.message);\n      });\n    });\n  }\n  connect(address, credentials, options) {\n    var _a, _b;\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions = credentials._getConnectionOptions() || {};\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options['grpc.ssl_target_name_override'];\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return (0, tls_1.checkServerIdentity)(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = (0, resolver_1.getDefaultAuthority)((_a = (0, uri_parser_1.parseUri)(options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n    return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then(result => this.createSession(address, credentials, options, result));\n  }\n  shutdown() {\n    var _a;\n    this.isShutdown = true;\n    (_a = this.session) === null || _a === void 0 ? void 0 : _a.close();\n    this.session = null;\n  }\n}\nexports.Http2SubchannelConnector = Http2SubchannelConnector;","map":{"version":3,"names":["http2","require","tls_1","channelz_1","constants_1","http_proxy_1","logging","resolver_1","subchannel_address_1","uri_parser_1","net","subchannel_call_1","call_number_1","TRACER_NAME","FLOW_CONTROL_TRACER_NAME","clientVersion","version","HTTP2_HEADER_AUTHORITY","HTTP2_HEADER_CONTENT_TYPE","HTTP2_HEADER_METHOD","HTTP2_HEADER_PATH","HTTP2_HEADER_TE","HTTP2_HEADER_USER_AGENT","constants","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","tooManyPingsData","Buffer","from","Http2Transport","constructor","session","subchannelAddress","options","keepaliveTimeMs","keepaliveTimeoutMs","keepaliveTimeoutId","keepaliveWithoutCalls","activeCalls","Set","disconnectListeners","disconnectHandled","channelzEnabled","remoteName","streamTracker","ChannelzCallTracker","keepalivesSent","messagesSent","messagesReceived","lastMessageSentTimestamp","lastMessageReceivedTimestamp","userAgent","filter","e","join","keepaliveIntervalId","setTimeout","clearTimeout","startKeepalivePings","subchannelAddressString","subchannelAddressToString","channelzRef","registerChannelzSocket","getChannelzInfo","once","trace","stopKeepalivePings","handleDisconnect","errorCode","lastStreamID","opaqueData","tooManyPings","NGHTTP2_ENHANCE_YOUR_CALM","equals","reportDisconnectToOwner","error","message","isTracerEnabled","on","settings","JSON","stringify","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","_a","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","streamsStarted","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastCallStartedTimestamp","lastRemoteStreamCreatedTimestamp","localFlowControlWindow","_b","state","localWindowSize","remoteFlowControlWindow","_c","remoteWindowSize","text","LogVerbosity","DEBUG","id","keepaliveTrace","flowControlTrace","internalsTrace","forEach","listener","setImmediate","call","onDisconnect","addDisconnectListener","push","clearKeepaliveTimeout","sendPing","unref","ping","err","duration","payload","setInterval","clearInterval","removeActiveCall","delete","size","addActiveCall","ref","add","createCall","metadata","host","method","subchannelCallStatsTracker","headers","toHttp2Headers","http2Stream","request","closed","destroyed","eventTracker","addCallStarted","addMessageSent","Date","addMessageReceived","onCallEnd","status","onStreamEnd","success","addCallSucceeded","addCallFailed","Http2SubchannelCall","getNextCallNumber","getChannelzRef","getPeerName","shutdown","close","Http2SubchannelConnector","channelTarget","isShutdown","createSession","address","credentials","proxyConnectionResult","Promise","reject","resolve","realTarget","uriToString","targetAuthority","getDefaultAuthority","connectionOptions","_getConnectionOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","addressScheme","sslTargetNameOverride","checkServerIdentity","cert","servername","authorityHostname","splitHostPort","createConnection","authority","option","connect","Object","assign","removeAllListeners","ALPNProtocols","targetPath","parseUri","path","hostPort","getProxiedConnection","then","result","exports"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/transport.ts"],"sourcesContent":["/*\n * Copyright 2023 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { checkServerIdentity, CipherNameAndProtocol, ConnectionOptions, PeerCertificate, TLSSocket } from 'tls';\nimport { StatusObject } from './call-interface';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ChannelzCallTracker, registerChannelzSocket, SocketInfo, SocketRef, TlsInfo } from './channelz';\nimport { LogVerbosity } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as logging from './logging';\nimport { getDefaultAuthority } from './resolver';\nimport { stringToSubchannelAddress, SubchannelAddress, subchannelAddressToString } from './subchannel-address';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport * as net from 'net';\nimport { Http2SubchannelCall, SubchannelCall, SubchannelCallInterceptingListener } from './subchannel-call';\nimport { Metadata } from './metadata';\nimport { getNextCallNumber } from './call-number';\n\nconst TRACER_NAME = 'transport';\nconst FLOW_CONTROL_TRACER_NAME = 'transport_flowctrl';\n\nconst clientVersion = require('../../package.json').version;\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport interface CallEventTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n  onCallEnd(status: StatusObject): void;\n  onStreamEnd(success: boolean): void;\n}\n\nexport interface TransportDisconnectListener {\n  (tooManyPings: boolean): void;\n}\n\nexport interface Transport {\n  getChannelzRef(): SocketRef;\n  getPeerName(): string;\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): SubchannelCall;\n  addDisconnectListener(listener: TransportDisconnectListener): void;\n  shutdown(): void;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nclass Http2Transport implements Transport {\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = -1;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer | null = null;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  private userAgent: string;\n\n  private activeCalls: Set<Http2SubchannelCall> = new Set();\n\n  private subchannelAddressString: string;\n\n  private disconnectListeners: TransportDisconnectListener[] = [];\n\n  private disconnectHandled = false;\n\n  // Channelz info\n  private channelzRef: SocketRef;\n  private readonly channelzEnabled: boolean = true;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  constructor(\n    private session: http2.ClientHttp2Session,\n    subchannelAddress: SubchannelAddress,\n    options: ChannelOptions\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n    \n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    if (this.keepaliveWithoutCalls) {\n      this.startKeepalivePings();\n    }\n\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n\n    session.once('close', () => {\n      this.trace('session closed');\n      this.stopKeepalivePings();\n      this.handleDisconnect();\n    });\n    session.once('goaway', (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n      let tooManyPings = false;\n      /* See the last paragraph of\n       * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n      if (\n        errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n        opaqueData.equals(tooManyPingsData)\n      ) {\n        tooManyPings = true;\n      }\n      this.trace(\n        'connection closed by GOAWAY with code ' +\n          errorCode\n      );\n      this.reportDisconnectToOwner(tooManyPings);\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n    if (logging.isTracerEnabled(TRACER_NAME)) {\n      session.on('remoteSettings', (settings: http2.Settings) => {\n        this.trace(\n          'new settings received' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n      session.on('localSettings', (settings: http2.Settings) => {\n        this.trace(\n          'local settings acknowledged by remote' +\n            (this.session !== session ? ' on the old connection' : '') +\n            ': ' +\n            JSON.stringify(settings)\n        );\n      });\n    }\n  }\n\n  private getChannelzInfo(): SocketInfo {\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private keepaliveTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private flowControlTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private internalsTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'transport_internals', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  /**\n   * Indicate to the owner of this object that this transport should no longer\n   * be used. That happens if the connection drops, or if the server sends a\n   * GOAWAY.\n   * @param tooManyPings If true, this was triggered by a GOAWAY with data\n   * indicating that the session was closed becaues the client sent too many\n   * pings.\n   * @returns \n   */\n  private reportDisconnectToOwner(tooManyPings: boolean) {\n    if (this.disconnectHandled) {\n      return;\n    }\n    this.disconnectHandled = true;\n    this.disconnectListeners.forEach(listener => listener(tooManyPings));\n  }\n\n  /**\n   * Handle connection drops, but not GOAWAYs.\n   */\n  private handleDisconnect() {\n    this.reportDisconnectToOwner(false);\n    /* Give calls an event loop cycle to finish naturally before reporting the\n     * disconnnection to them. */\n    setImmediate(() => {\n      for (const call of this.activeCalls) {\n        call.onDisconnect();\n      }\n    });\n  }\n\n  addDisconnectListener(listener: TransportDisconnectListener): void {\n    this.disconnectListeners.push(listener);\n  }\n\n  private clearKeepaliveTimeout() {\n    if (!this.keepaliveTimeoutId) {\n      return;\n    }\n    clearTimeout(this.keepaliveTimeoutId);\n    this.keepaliveTimeoutId = null;\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    this.keepaliveTrace('Sending ping with timeout ' + this.keepaliveTimeoutMs + 'ms');\n    if (!this.keepaliveTimeoutId) {\n      this.keepaliveTimeoutId = setTimeout(() => {\n        this.keepaliveTrace('Ping timeout passed without response');\n        this.handleDisconnect();\n      }, this.keepaliveTimeoutMs);\n      this.keepaliveTimeoutId.unref?.();\n    }\n    try {\n      this.session!.ping(\n        (err: Error | null, duration: number, payload: Buffer) => {\n          this.keepaliveTrace('Received ping response');\n          this.clearKeepaliveTimeout();\n        }\n      );\n    } catch (e) {\n      /* If we fail to send a ping, the connection is no longer functional, so\n       * we should discard it. */\n      this.handleDisconnect();\n    }\n  }\n\n  private startKeepalivePings() {\n    if (this.keepaliveTimeMs < 0) {\n      return;\n    }\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  /**\n   * Stop keepalive pings when terminating a connection. This discards the\n   * outstanding ping timeout, so it should not be called if the same\n   * connection will still be used.\n   */\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    this.clearKeepaliveTimeout();\n  }\n\n  private removeActiveCall(call: Http2SubchannelCall) {\n    this.activeCalls.delete(call);\n    if (this.activeCalls.size === 0) {\n      this.session.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n    }\n  }\n\n  private addActiveCall(call: Http2SubchannelCall) {\n    if (this.activeCalls.size === 0) {\n      this.session.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.activeCalls.add(call);\n  }\n\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener, subchannelCallStatsTracker: Partial<CallEventTracker>): Http2SubchannelCall {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = host;\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = method;\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.handleDisconnect();\n      throw e;\n    }\n    this.flowControlTrace(\n      'local window size: ' +\n        this.session.state.localWindowSize +\n        ' remote window size: ' +\n        this.session.state.remoteWindowSize\n    );\n    this.internalsTrace(\n      'session.closed=' + \n      this.session.closed + \n      ' session.destroyed=' + \n      this.session.destroyed + \n      ' session.socket.destroyed=' + \n      this.session.socket.destroyed);\n    let eventTracker: CallEventTracker;\n    let call: Http2SubchannelCall;\n    if (this.channelzEnabled) {\n      this.streamTracker.addCallStarted();\n      eventTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n          this.lastMessageReceivedTimestamp = new Date();\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: status => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: success => {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        }\n      }\n    } else {\n      eventTracker = {\n        addMessageSent: () => {\n          subchannelCallStatsTracker.addMessageSent?.();\n        },\n        addMessageReceived: () => {\n          subchannelCallStatsTracker.addMessageReceived?.();\n        },\n        onCallEnd: (status) => {\n          subchannelCallStatsTracker.onCallEnd?.(status);\n          this.removeActiveCall(call);\n        },\n        onStreamEnd: (success) => {\n          subchannelCallStatsTracker.onStreamEnd?.(success);\n        }\n      }\n    }\n    call = new Http2SubchannelCall(http2Stream, eventTracker, listener, this, getNextCallNumber());\n    this.addActiveCall(call);\n    return call;\n  }\n\n  getChannelzRef(): SocketRef {\n    return this.channelzRef;\n  }\n\n  getPeerName() {\n    return this.subchannelAddressString;\n  }\n\n  shutdown() {\n    this.session.close();\n  }\n}\n\nexport interface SubchannelConnector {\n  connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Transport>;\n  shutdown(): void;\n}\n\nexport class Http2SubchannelConnector implements SubchannelConnector {\n  private session: http2.ClientHttp2Session | null = null;\n  private isShutdown = false;\n  constructor(private channelTarget: GrpcUri) {}\n  private trace(text: string) {\n\n  }\n  private createSession(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions, proxyConnectionResult: ProxyConnectionResult): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    return new Promise<Http2Transport>((resolve, reject) => {\n      let remoteName: string | null;\n      if (proxyConnectionResult.realTarget) {\n        remoteName = uriToString(proxyConnectionResult.realTarget);\n        this.trace('creating HTTP/2 session through proxy to ' + uriToString(proxyConnectionResult.realTarget));\n      } else {\n        remoteName = null;\n        this.trace('creating HTTP/2 session to ' + subchannelAddressToString(address));\n      }\n      const targetAuthority = getDefaultAuthority(\n        proxyConnectionResult.realTarget ?? this.channelTarget\n      );\n      let connectionOptions: http2.SecureClientSessionOptions =\n        credentials._getConnectionOptions() || {};\n      connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n      if ('grpc-node.max_session_memory' in options) {\n        connectionOptions.maxSessionMemory = options[\n          'grpc-node.max_session_memory'\n        ];\n      } else {\n        /* By default, set a very large max session memory limit, to effectively\n         * disable enforcement of the limit. Some testing indicates that Node's\n         * behavior degrades badly when this limit is reached, so we solve that\n         * by disabling the check entirely. */\n        connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n      }\n      let addressScheme = 'http://';\n      if ('secureContext' in connectionOptions) {\n        addressScheme = 'https://';\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (options['grpc.ssl_target_name_override']) {\n          const sslTargetNameOverride = options[\n            'grpc.ssl_target_name_override'\n          ]!;\n          connectionOptions.checkServerIdentity = (\n            host: string,\n            cert: PeerCertificate\n          ): Error | undefined => {\n            return checkServerIdentity(sslTargetNameOverride, cert);\n          };\n          connectionOptions.servername = sslTargetNameOverride;\n        } else {\n          const authorityHostname =\n            splitHostPort(targetAuthority)?.host ?? 'localhost';\n          // We want to always set servername to support SNI\n          connectionOptions.servername = authorityHostname;\n        }\n        if (proxyConnectionResult.socket) {\n          /* This is part of the workaround for\n           * https://github.com/nodejs/node/issues/32922. Without that bug,\n           * proxyConnectionResult.socket would always be a plaintext socket and\n           * this would say\n           * connectionOptions.socket = proxyConnectionResult.socket; */\n          connectionOptions.createConnection = (authority, option) => {\n            return proxyConnectionResult.socket!;\n          };\n        }\n      } else {\n        /* In all but the most recent versions of Node, http2.connect does not use\n         * the options when establishing plaintext connections, so we need to\n         * establish that connection explicitly. */\n        connectionOptions.createConnection = (authority, option) => {\n          if (proxyConnectionResult.socket) {\n            return proxyConnectionResult.socket;\n          } else {\n            /* net.NetConnectOpts is declared in a way that is more restrictive\n             * than what net.connect will actually accept, so we use the type\n             * assertion to work around that. */\n            return net.connect(address);\n          }\n        };\n      }\n  \n      connectionOptions = {\n        ...connectionOptions,\n        ...address,\n      };\n  \n      /* http2.connect uses the options here:\n       * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n       * The spread operator overides earlier values with later ones, so any port\n       * or host values in the options will be used rather than any values extracted\n       * from the first argument. In addition, the path overrides the host and port,\n       * as documented for plaintext connections here:\n       * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n       * and for TLS connections here:\n       * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n       * earlier versions of Node, http2.connect passes these options to\n       * tls.connect but not net.connect, so in the insecure case we still need\n       * to set the createConnection option above to create the connection\n       * explicitly. We cannot do that in the TLS case because http2.connect\n       * passes necessary additional options to tls.connect.\n       * The first argument just needs to be parseable as a URL and the scheme\n       * determines whether the connection will be established over TLS or not.\n       */\n      const session = http2.connect(\n        addressScheme + targetAuthority,\n        connectionOptions\n      );\n      this.session = session;\n      session.unref();\n      session.once('connect', () => {\n        session.removeAllListeners();\n        resolve(new Http2Transport(session, address, options));\n        this.session = null;\n      });\n      session.once('close', () => {\n        this.session = null;\n        reject();\n      });\n      session.once('error', error => {\n        this.trace('connection failed with error ' + (error as Error).message)\n      });\n    });\n  }\n  connect(address: SubchannelAddress, credentials: ChannelCredentials, options: ChannelOptions): Promise<Http2Transport> {\n    if (this.isShutdown) {\n      return Promise.reject();\n    }\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    return getProxiedConnection(\n      address,\n      options,\n      connectionOptions\n    ).then(\n      result => this.createSession(address, credentials, options, result)\n    );\n  }\n\n  shutdown(): void {\n    this.isShutdown = true;\n    this.session?.close();\n    this.session = null;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}