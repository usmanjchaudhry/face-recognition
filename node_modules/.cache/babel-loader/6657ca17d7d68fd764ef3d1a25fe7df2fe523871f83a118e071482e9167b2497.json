{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst Protobuf = require(\"protobufjs\");\nconst descriptor = require(\"protobufjs/ext/descriptor\");\nconst camelCase = require(\"lodash.camelcase\");\nconst descriptorOptions = {\n  longs: String,\n  enums: String,\n  bytes: String,\n  defaults: true,\n  oneofs: true,\n  json: true\n};\nfunction joinName(baseName, name) {\n  if (baseName === '') {\n    return name;\n  } else {\n    return baseName + '.' + name;\n  }\n}\nfunction isHandledReflectionObject(obj) {\n  return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;\n}\nfunction isNamespaceBase(obj) {\n  return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n  const objName = joinName(parentName, obj.name);\n  if (isHandledReflectionObject(obj)) {\n    return [[objName, obj]];\n  } else {\n    if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n      return Object.keys(obj.nested).map(name => {\n        return getAllHandledReflectionObjects(obj.nested[name], objName);\n      }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n    }\n  }\n  return [];\n}\nfunction createDeserializer(cls, options) {\n  return function deserialize(argBuf) {\n    return cls.toObject(cls.decode(argBuf), options);\n  };\n}\nfunction createSerializer(cls) {\n  return function serialize(arg) {\n    const message = cls.fromObject(arg);\n    return cls.encode(message).finish();\n  };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n  /* This is only ever called after the corresponding root.resolveAll(), so we\n   * can assume that the resolved request and response types are non-null */\n  const requestType = method.resolvedRequestType;\n  const responseType = method.resolvedResponseType;\n  return {\n    path: '/' + serviceName + '/' + method.name,\n    requestStream: !!method.requestStream,\n    responseStream: !!method.responseStream,\n    requestSerialize: createSerializer(requestType),\n    requestDeserialize: createDeserializer(requestType, options),\n    responseSerialize: createSerializer(responseType),\n    responseDeserialize: createDeserializer(responseType, options),\n    // TODO(murgatroid99): Find a better way to handle this\n    originalName: camelCase(method.name),\n    requestType: createMessageDefinition(requestType, fileDescriptors),\n    responseType: createMessageDefinition(responseType, fileDescriptors)\n  };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n  const def = {};\n  for (const method of service.methodsArray) {\n    def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n  }\n  return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n  const messageDescriptor = message.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 DescriptorProto',\n    type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n  const enumDescriptor = enumType.toDescriptor('proto3');\n  return {\n    format: 'Protocol Buffer 3 EnumDescriptorProto',\n    type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n    fileDescriptorProtos: fileDescriptors\n  };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n  if (obj instanceof Protobuf.Service) {\n    return createServiceDefinition(obj, name, options, fileDescriptors);\n  } else if (obj instanceof Protobuf.Type) {\n    return createMessageDefinition(obj, fileDescriptors);\n  } else if (obj instanceof Protobuf.Enum) {\n    return createEnumDefinition(obj, fileDescriptors);\n  } else {\n    throw new Error('Type mismatch in reflection object handling');\n  }\n}\nfunction createPackageDefinition(root, options) {\n  const def = {};\n  root.resolveAll();\n  const descriptorList = root.toDescriptor('proto3').file;\n  const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n  for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n    def[name] = createDefinition(obj, name, options, bufferList);\n  }\n  return def;\n}\nfunction addIncludePathResolver(root, includePaths) {\n  const originalResolvePath = root.resolvePath;\n  root.resolvePath = (origin, target) => {\n    if (path.isAbsolute(target)) {\n      return target;\n    }\n    for (const directory of includePaths) {\n      const fullPath = path.join(directory, target);\n      try {\n        fs.accessSync(fullPath, fs.constants.R_OK);\n        return fullPath;\n      } catch (err) {\n        continue;\n      }\n    }\n    process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n    return originalResolvePath(origin, target);\n  };\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n  options = options || {};\n  const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n  root.resolveAll();\n  return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n  const root = new Protobuf.Root();\n  options = options || {};\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      return Promise.reject(new Error('The includeDirs option must be an array'));\n    }\n    addIncludePathResolver(root, options.includeDirs);\n  }\n  return root.load(filename, options).then(loadedRoot => {\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n  });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n  const root = new Protobuf.Root();\n  options = options || {};\n  if (!!options.includeDirs) {\n    if (!Array.isArray(options.includeDirs)) {\n      throw new Error('The includeDirs option must be an array');\n    }\n    addIncludePathResolver(root, options.includeDirs);\n  }\n  const loadedRoot = root.loadSync(filename, options);\n  loadedRoot.resolveAll();\n  return createPackageDefinition(root, options);\n}\nexports.loadSync = loadSync;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n  const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n  return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n// Load Google's well-known proto files that aren't exposed by Protobuf.js.\n// Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n// and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n// Using constant strings for compatibility with tools like Webpack\nconst apiDescriptor = require('protobufjs/google/protobuf/api.json');\nconst descriptorDescriptor = require('protobufjs/google/protobuf/descriptor.json');\nconst sourceContextDescriptor = require('protobufjs/google/protobuf/source_context.json');\nconst typeDescriptor = require('protobufjs/google/protobuf/type.json');\nProtobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);","map":{"version":3,"names":["Object","defineProperty","exports","value","fs","require","path","Protobuf","descriptor","camelCase","descriptorOptions","longs","String","enums","bytes","defaults","oneofs","json","joinName","baseName","name","isHandledReflectionObject","obj","Service","Type","Enum","isNamespaceBase","Namespace","Root","getAllHandledReflectionObjects","parentName","objName","nested","keys","map","reduce","accumulator","currentValue","concat","createDeserializer","cls","options","deserialize","argBuf","toObject","decode","createSerializer","serialize","arg","message","fromObject","encode","finish","createMethodDefinition","method","serviceName","fileDescriptors","requestType","resolvedRequestType","responseType","resolvedResponseType","requestStream","responseStream","requestSerialize","requestDeserialize","responseSerialize","responseDeserialize","originalName","createMessageDefinition","createServiceDefinition","service","def","methodsArray","messageDescriptor","toDescriptor","format","type","$type","fileDescriptorProtos","createEnumDefinition","enumType","enumDescriptor","createDefinition","Error","createPackageDefinition","root","resolveAll","descriptorList","file","bufferList","Buffer","from","FileDescriptorProto","addIncludePathResolver","includePaths","originalResolvePath","resolvePath","origin","target","isAbsolute","directory","fullPath","join","accessSync","constants","R_OK","err","process","emitWarning","createPackageDefinitionFromDescriptorSet","decodedDescriptorSet","fromDescriptor","load","filename","includeDirs","Array","isArray","Promise","reject","then","loadedRoot","loadSync","loadFileDescriptorSetFromBuffer","descriptorSet","FileDescriptorSet","loadFileDescriptorSetFromObject","apiDescriptor","descriptorDescriptor","sourceContextDescriptor","typeDescriptor","common","google","protobuf"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/proto-loader/build/src/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst Protobuf = require(\"protobufjs\");\nconst descriptor = require(\"protobufjs/ext/descriptor\");\nconst camelCase = require(\"lodash.camelcase\");\nconst descriptorOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    defaults: true,\n    oneofs: true,\n    json: true,\n};\nfunction joinName(baseName, name) {\n    if (baseName === '') {\n        return name;\n    }\n    else {\n        return baseName + '.' + name;\n    }\n}\nfunction isHandledReflectionObject(obj) {\n    return (obj instanceof Protobuf.Service ||\n        obj instanceof Protobuf.Type ||\n        obj instanceof Protobuf.Enum);\n}\nfunction isNamespaceBase(obj) {\n    return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;\n}\nfunction getAllHandledReflectionObjects(obj, parentName) {\n    const objName = joinName(parentName, obj.name);\n    if (isHandledReflectionObject(obj)) {\n        return [[objName, obj]];\n    }\n    else {\n        if (isNamespaceBase(obj) && typeof obj.nested !== 'undefined') {\n            return Object.keys(obj.nested)\n                .map(name => {\n                return getAllHandledReflectionObjects(obj.nested[name], objName);\n            })\n                .reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);\n        }\n    }\n    return [];\n}\nfunction createDeserializer(cls, options) {\n    return function deserialize(argBuf) {\n        return cls.toObject(cls.decode(argBuf), options);\n    };\n}\nfunction createSerializer(cls) {\n    return function serialize(arg) {\n        const message = cls.fromObject(arg);\n        return cls.encode(message).finish();\n    };\n}\nfunction createMethodDefinition(method, serviceName, options, fileDescriptors) {\n    /* This is only ever called after the corresponding root.resolveAll(), so we\n     * can assume that the resolved request and response types are non-null */\n    const requestType = method.resolvedRequestType;\n    const responseType = method.resolvedResponseType;\n    return {\n        path: '/' + serviceName + '/' + method.name,\n        requestStream: !!method.requestStream,\n        responseStream: !!method.responseStream,\n        requestSerialize: createSerializer(requestType),\n        requestDeserialize: createDeserializer(requestType, options),\n        responseSerialize: createSerializer(responseType),\n        responseDeserialize: createDeserializer(responseType, options),\n        // TODO(murgatroid99): Find a better way to handle this\n        originalName: camelCase(method.name),\n        requestType: createMessageDefinition(requestType, fileDescriptors),\n        responseType: createMessageDefinition(responseType, fileDescriptors),\n    };\n}\nfunction createServiceDefinition(service, name, options, fileDescriptors) {\n    const def = {};\n    for (const method of service.methodsArray) {\n        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);\n    }\n    return def;\n}\nfunction createMessageDefinition(message, fileDescriptors) {\n    const messageDescriptor = message.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 DescriptorProto',\n        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\nfunction createEnumDefinition(enumType, fileDescriptors) {\n    const enumDescriptor = enumType.toDescriptor('proto3');\n    return {\n        format: 'Protocol Buffer 3 EnumDescriptorProto',\n        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),\n        fileDescriptorProtos: fileDescriptors,\n    };\n}\n/**\n * function createDefinition(obj: Protobuf.Service, name: string, options:\n * Options): ServiceDefinition; function createDefinition(obj: Protobuf.Type,\n * name: string, options: Options): MessageTypeDefinition; function\n * createDefinition(obj: Protobuf.Enum, name: string, options: Options):\n * EnumTypeDefinition;\n */\nfunction createDefinition(obj, name, options, fileDescriptors) {\n    if (obj instanceof Protobuf.Service) {\n        return createServiceDefinition(obj, name, options, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Type) {\n        return createMessageDefinition(obj, fileDescriptors);\n    }\n    else if (obj instanceof Protobuf.Enum) {\n        return createEnumDefinition(obj, fileDescriptors);\n    }\n    else {\n        throw new Error('Type mismatch in reflection object handling');\n    }\n}\nfunction createPackageDefinition(root, options) {\n    const def = {};\n    root.resolveAll();\n    const descriptorList = root.toDescriptor('proto3').file;\n    const bufferList = descriptorList.map(value => Buffer.from(descriptor.FileDescriptorProto.encode(value).finish()));\n    for (const [name, obj] of getAllHandledReflectionObjects(root, '')) {\n        def[name] = createDefinition(obj, name, options, bufferList);\n    }\n    return def;\n}\nfunction addIncludePathResolver(root, includePaths) {\n    const originalResolvePath = root.resolvePath;\n    root.resolvePath = (origin, target) => {\n        if (path.isAbsolute(target)) {\n            return target;\n        }\n        for (const directory of includePaths) {\n            const fullPath = path.join(directory, target);\n            try {\n                fs.accessSync(fullPath, fs.constants.R_OK);\n                return fullPath;\n            }\n            catch (err) {\n                continue;\n            }\n        }\n        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);\n        return originalResolvePath(origin, target);\n    };\n}\nfunction createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {\n    options = options || {};\n    const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);\n    root.resolveAll();\n    return createPackageDefinition(root, options);\n}\n/**\n * Load a .proto file with the specified options.\n * @param filename One or multiple file paths to load. Can be an absolute path\n *     or relative to an include path.\n * @param options.keepCase Preserve field names. The default is to change them\n *     to camel case.\n * @param options.longs The type that should be used to represent `long` values.\n *     Valid options are `Number` and `String`. Defaults to a `Long` object type\n *     from a library.\n * @param options.enums The type that should be used to represent `enum` values.\n *     The only valid option is `String`. Defaults to the numeric value.\n * @param options.bytes The type that should be used to represent `bytes`\n *     values. Valid options are `Array` and `String`. The default is to use\n *     `Buffer`.\n * @param options.defaults Set default values on output objects. Defaults to\n *     `false`.\n * @param options.arrays Set empty arrays for missing array values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.objects Set empty objects for missing object values even if\n *     `defaults` is `false`. Defaults to `false`.\n * @param options.oneofs Set virtual oneof properties to the present field's\n *     name\n * @param options.includeDirs Paths to search for imported `.proto` files.\n */\nfunction load(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            return Promise.reject(new Error('The includeDirs option must be an array'));\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    return root.load(filename, options).then(loadedRoot => {\n        loadedRoot.resolveAll();\n        return createPackageDefinition(root, options);\n    });\n}\nexports.load = load;\nfunction loadSync(filename, options) {\n    const root = new Protobuf.Root();\n    options = options || {};\n    if (!!options.includeDirs) {\n        if (!Array.isArray(options.includeDirs)) {\n            throw new Error('The includeDirs option must be an array');\n        }\n        addIncludePathResolver(root, options.includeDirs);\n    }\n    const loadedRoot = root.loadSync(filename, options);\n    loadedRoot.resolveAll();\n    return createPackageDefinition(root, options);\n}\nexports.loadSync = loadSync;\nfunction loadFileDescriptorSetFromBuffer(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;\nfunction loadFileDescriptorSetFromObject(descriptorSet, options) {\n    const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);\n    return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);\n}\nexports.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;\n// Load Google's well-known proto files that aren't exposed by Protobuf.js.\n// Protobuf.js exposes: any, duration, empty, field_mask, struct, timestamp,\n// and wrappers. compiler/plugin is excluded in Protobuf.js and here.\n// Using constant strings for compatibility with tools like Webpack\nconst apiDescriptor = require('protobufjs/google/protobuf/api.json');\nconst descriptorDescriptor = require('protobufjs/google/protobuf/descriptor.json');\nconst sourceContextDescriptor = require('protobufjs/google/protobuf/source_context.json');\nconst typeDescriptor = require('protobufjs/google/protobuf/type.json');\nProtobuf.common('api', apiDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('descriptor', descriptorDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('source_context', sourceContextDescriptor.nested.google.nested.protobuf.nested);\nProtobuf.common('type', typeDescriptor.nested.google.nested.protobuf.nested);\n//# sourceMappingURL=index.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}