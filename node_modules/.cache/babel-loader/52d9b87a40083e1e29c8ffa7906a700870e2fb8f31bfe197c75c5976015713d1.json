{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\nconst logging = require(\"./logging\");\nconst constants_1 = require(\"./constants\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst channelz_1 = require(\"./channelz\");\nconst TRACER_NAME = 'subchannel';\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials, connector) {\n    var _a;\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    this.connector = connector;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n    this.transport = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n    this.stateListeners = [];\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n    this.refcount = 0;\n    // Channelz info\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n    // Channelz socket info\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);\n    this.keepaliveTime = (_a = options['grpc.keepalive_time_ms']) !== null && _a !== void 0 ? _a : -1;\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n  startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = Object.assign(Object.assign({}, options), {\n        'grpc.keepalive_time_ms': adjustedKeepaliveTime\n      });\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(transport => {\n      if (this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY)) {\n        this.transport = transport;\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(transport.getChannelzRef());\n        }\n        transport.addDisconnectListener(tooManyPings => {\n          this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n          if (tooManyPings && this.keepaliveTime > 0) {\n            this.keepaliveTime *= 2;\n            logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);\n          }\n        });\n      }\n    }, error => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  transitionToState(oldStates, newState) {\n    var _a, _b;\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        (_b = this.transport) === null || _b === void 0 ? void 0 : _b.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      if (this.channelzEnabled) {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      }\n    }\n  }\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n  createCall(metadata, host, method, listener) {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === constants_1.Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      };\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  getRealSubchannel() {\n    return this;\n  }\n  throttleKeepalive(newKeepaliveTime) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\nexports.Subchannel = Subchannel;","map":{"version":3,"names":["connectivity_state_1","require","backoff_timeout_1","logging","constants_1","uri_parser_1","subchannel_address_1","channelz_1","TRACER_NAME","KEEPALIVE_MAX_TIME_MS","Subchannel","constructor","channelTarget","subchannelAddress","options","credentials","connector","connectivityState","ConnectivityState","IDLE","transport","continueConnecting","stateListeners","refcount","channelzEnabled","callTracker","ChannelzCallTracker","childrenTracker","ChannelzChildrenTracker","streamTracker","backoffOptions","initialDelay","maxDelay","backoffTimeout","BackoffTimeout","handleBackoffTimer","subchannelAddressString","subchannelAddressToString","keepaliveTime","_a","channelzTrace","ChannelzTrace","channelzRef","registerChannelzSubchannel","getChannelzInfo","addTrace","trace","JSON","stringify","undefined","state","children","getChildLists","target","text","LogVerbosity","DEBUG","id","refTrace","transitionToState","TRANSIENT_FAILURE","CONNECTING","startBackoff","runOnce","stopBackoff","stop","reset","startConnectingInternal","adjustedKeepaliveTime","Math","min","Object","assign","connect","then","READY","refChild","getChannelzRef","addDisconnectListener","tooManyPings","log","ERROR","uriToString","error","oldStates","newState","indexOf","previousState","unrefChild","shutdown","isRunning","process","nextTick","_b","Error","listener","ref","unref","unregisterChannelzRef","unrefIfOneRef","createCall","metadata","host","method","statsTracker","addCallStarted","onCallEnd","status","code","Status","OK","addCallSucceeded","addCallFailed","startConnecting","getConnectivityState","addConnectivityStateListener","push","removeConnectivityStateListener","listenerIndex","splice","resetBackoff","getAddress","getRealSubchannel","throttleKeepalive","newKeepaliveTime","exports"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/subchannel.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport {\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, unregisterChannelzRef } from './channelz';\nimport { ConnectivityStateListener } from './subchannel-interface';\nimport { SubchannelCallInterceptingListener } from './subchannel-call';\nimport { SubchannelCall } from './subchannel-call';\nimport { CallEventTracker, SubchannelConnector, Transport } from './transport';\n\nconst TRACER_NAME = 'subchannel';\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private transport: Transport | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  private backoffTimeout: BackoffTimeout;\n\n  private keepaliveTime: number;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private streamTracker = new ChannelzCallTracker();\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials,\n    private connector: SubchannelConnector\n  ) {\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    this.keepaliveTime = options['grpc.keepalive_time_ms'] ?? -1;\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private startConnectingInternal() {\n    let options = this.options;\n    if (options['grpc.keepalive_time_ms']) {\n      const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);\n      options = {...options, 'grpc.keepalive_time_ms': adjustedKeepaliveTime};\n    }\n    this.connector.connect(this.subchannelAddress, this.credentials, options).then(\n      transport => {\n        if (this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY)) {\n          this.transport = transport;\n          if (this.channelzEnabled) {\n            this.childrenTracker.refChild(transport.getChannelzRef());\n          }\n          transport.addDisconnectListener((tooManyPings) => {\n            this.transitionToState([ConnectivityState.READY], ConnectivityState.IDLE);\n            if (tooManyPings && this.keepaliveTime > 0) {\n              this.keepaliveTime *= 2;\n              logging.log(\n                LogVerbosity.ERROR,\n                `Connection to ${uriToString(this.channelTarget)} at ${\n                  this.subchannelAddressString\n                } rejected by server because of excess pings. Increasing ping interval to ${\n                  this.keepaliveTime\n                } ms`\n              );\n            }\n          });\n        }\n      },\n      error => {\n        this.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.TRANSIENT_FAILURE);\n      }\n    )\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.channelzEnabled && this.transport) {\n          this.childrenTracker.unrefChild(this.transport.getChannelzRef());\n        }\n        this.transport?.shutdown();\n        this.transport = null;\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState, this.keepaliveTime);\n    }\n    return true;\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    if (this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.IDLE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  createCall(metadata: Metadata, host: string, method: string, listener: SubchannelCallInterceptingListener): SubchannelCall {\n    if (!this.transport) {\n      throw new Error('Cannot create call, subchannel not READY');\n    }\n    let statsTracker: Partial<CallEventTracker>;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      this.streamTracker.addCallStarted();\n      statsTracker = {\n        onCallEnd: status => {\n          if (status.code === Status.OK) {\n            this.callTracker.addCallSucceeded();\n          } else {\n            this.callTracker.addCallFailed();\n          }\n        }\n      }\n    } else {\n      statsTracker = {};\n    }\n    return this.transport.createCall(metadata, host, method, listener, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n\n  getRealSubchannel(): this {\n    return this;\n  }\n\n  throttleKeepalive(newKeepaliveTime: number) {\n    if (newKeepaliveTime > this.keepaliveTime) {\n      this.keepaliveTime = newKeepaliveTime;\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}