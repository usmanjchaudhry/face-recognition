{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RetryingCall = exports.MessageBufferTracker = exports.RetryThrottler = void 0;\nconst constants_1 = require(\"./constants\");\nconst metadata_1 = require(\"./metadata\");\nconst logging = require(\"./logging\");\nconst TRACER_NAME = 'retrying_call';\nclass RetryThrottler {\n  constructor(maxTokens, tokenRatio, previousRetryThrottler) {\n    this.maxTokens = maxTokens;\n    this.tokenRatio = tokenRatio;\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\nexports.RetryThrottler = RetryThrottler;\nclass MessageBufferTracker {\n  constructor(totalLimit, limitPerCall) {\n    this.totalLimit = totalLimit;\n    this.limitPerCall = limitPerCall;\n    this.totalAllocated = 0;\n    this.allocatedPerCall = new Map();\n  }\n  allocate(size, callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n  free(size, callId) {\n    var _a;\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n  freeAll(callId) {\n    var _a;\n    const currentPerCall = (_a = this.allocatedPerCall.get(callId)) !== null && _a !== void 0 ? _a : 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\nexports.MessageBufferTracker = MessageBufferTracker;\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\nclass RetryingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.bufferTracker = bufferTracker;\n    this.retryThrottler = retryThrottler;\n    this.listener = null;\n    this.initialMetadata = null;\n    this.underlyingCalls = [];\n    this.writeBuffer = [];\n    /**\n     * The offset of message indices in the writeBuffer. For example, if\n     * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n     * is in writeBuffer[5].\n     */\n    this.writeBufferOffset = 0;\n    /**\n     * Tracks whether a read has been started, so that we know whether to start\n     * reads on new child calls. This only matters for the first read, because\n     * once a message comes in the child call becomes committed and there will\n     * be no new child calls.\n     */\n    this.readStarted = false;\n    this.transparentRetryUsed = false;\n    /**\n     * Number of attempts so far\n     */\n    this.attempts = 0;\n    this.hedgingTimer = null;\n    this.committedCallIndex = null;\n    this.initialRetryBackoffSec = 0;\n    this.nextRetryBackoffSec = 0;\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  reportStatus(statusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      var _a;\n      // Explicitly construct status object to remove progress field\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata\n      });\n    });\n  }\n  cancelWithStatus(status, details) {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({\n      code: status,\n      details,\n      metadata: new metadata_1.Metadata()\n    });\n    for (const {\n      call\n    } of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer() {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n  getBufferEntry(messageIndex) {\n    var _a;\n    return (_a = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a !== void 0 ? _a : {\n      entryType: 'FREED',\n      allocated: false\n    };\n  }\n  getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n  clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;\n    for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n  commitCall(index) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    this.clearSentMessages();\n  }\n  commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.state === 'ACTIVE' && childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n  isStatusCodeInList(list, code) {\n    return list.some(value => value === code || value.toString().toLowerCase() === constants_1.Status[code].toLowerCase());\n  }\n  getNextRetryBackoffMs() {\n    var _a;\n    const retryPolicy = (_a = this.callConfig) === null || _a === void 0 ? void 0 : _a.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs;\n  }\n  maybeRetryCall(pushback, callback) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig.methodConfig.retryPolicy;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      var _a, _b;\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if ((_b = (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.canRetryCall()) !== null && _b !== void 0 ? _b : true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n  countActiveCalls() {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n  handleProcessedStatus(status, callIndex, pushback) {\n    var _a, _b, _c;\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList((_a = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a !== void 0 ? _a : [], status.code)) {\n          (_b = this.retryThrottler) === null || _b === void 0 ? void 0 : _b.addCallFailed();\n          let delayMs;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {\n          (_c = this.retryThrottler) === null || _c === void 0 ? void 0 : _c.addCallFailed();\n          this.maybeRetryCall(pushback, retried => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n  getPushback(metadata) {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0]);\n    } catch (e) {\n      return -1;\n    }\n  }\n  handleChildStatus(status, callIndex) {\n    var _a;\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === constants_1.Status.OK) {\n      (_a = this.retryThrottler) === null || _a === void 0 ? void 0 : _a.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        }\n        ;\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n  maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  maybeStartHedgingTimer() {\n    var _a, _b, _c;\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = (_a = hedgingPolicy.hedgingDelay) !== null && _a !== void 0 ? _a : '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    (_c = (_b = this.hedgingTimer).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n  }\n  startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({\n      state: 'ACTIVE',\n      call: child,\n      nextMessageToSend: 0\n    });\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n  handleChildWriteCompleted(childIndex) {\n    var _a, _b;\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    (_b = (_a = this.getBufferEntry(messageIndex)).callback) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n  sendNextChildMessage(childIndex) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n  sendMessageWithContext(context, message) {\n    var _a;\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj = {\n      message,\n      flags: context.flags\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      (_a = context.callback) === null || _a === void 0 ? void 0 : _a.call(context);\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: error => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback;\n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: error => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    });\n    for (const call of this.underlyingCalls) {\n      if ((call === null || call === void 0 ? void 0 : call.state) === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod() {\n    return this.methodName;\n  }\n  getHost() {\n    return this.host;\n  }\n}\nexports.RetryingCall = RetryingCall;","map":{"version":3,"names":["constants_1","require","metadata_1","logging","TRACER_NAME","RetryThrottler","constructor","maxTokens","tokenRatio","previousRetryThrottler","tokens","addCallSucceeded","Math","max","addCallFailed","min","canRetryCall","exports","MessageBufferTracker","totalLimit","limitPerCall","totalAllocated","allocatedPerCall","Map","allocate","size","callId","currentPerCall","_a","get","set","free","Error","freeAll","delete","PREVIONS_RPC_ATTEMPTS_METADATA_KEY","RetryingCall","channel","callConfig","methodName","host","credentials","deadline","callNumber","bufferTracker","retryThrottler","listener","initialMetadata","underlyingCalls","writeBuffer","writeBufferOffset","readStarted","transparentRetryUsed","attempts","hedgingTimer","committedCallIndex","initialRetryBackoffSec","nextRetryBackoffSec","methodConfig","retryPolicy","state","Number","initialBackoff","substring","length","hedgingPolicy","getCallNumber","trace","text","LogVerbosity","DEBUG","reportStatus","statusObject","code","details","process","nextTick","onReceiveStatus","metadata","cancelWithStatus","status","Metadata","call","getPeer","getBufferEntry","messageIndex","entryType","allocated","getNextBufferIndex","clearSentMessages","earliestNeededMessageIndex","nextMessageToSend","bufferEntry","message","slice","commitCall","index","i","Status","CANCELLED","commitCallWithMostMessages","mostMessages","callWithMostMessages","childCall","entries","isStatusCodeInList","list","some","value","toString","toLowerCase","getNextRetryBackoffMs","nextBackoffMs","random","maxBackoffSec","maxBackoff","backoffMultiplier","maybeRetryCall","pushback","callback","maxAttempts","retryDelayMs","setTimeout","_b","startNewAttempt","countActiveCalls","count","handleProcessedStatus","callIndex","nonFatalStatusCodes","delayMs","maybeStartHedgingAttempt","retryableStatusCodes","_c","retried","getPushback","mdValue","parseInt","e","handleChildStatus","progress","OK","maybeStartHedgingTimer","clearTimeout","hedgingDelayString","hedgingDelay","hedgingDelaySec","unref","child","createLoadBalancingCall","push","previousAttempts","clone","receivedMetadata","start","onReceiveMetadata","onReceiveMessage","sendNextChildMessage","startRead","handleChildWriteCompleted","childIndex","sendMessageWithContext","error","halfClose","context","writeObj","flags","underlyingCall","halfCloseIndex","setCredentials","newCredentials","getMethod","getHost"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/retrying-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { Deadline } from \"./deadline\";\nimport { Metadata } from \"./metadata\";\nimport { CallConfig } from \"./resolver\";\nimport * as logging from './logging';\nimport { Call, InterceptingListener, MessageContext, StatusObject, WriteCallback, WriteObject } from \"./call-interface\";\nimport { LoadBalancingCall, StatusObjectWithProgress } from \"./load-balancing-call\";\nimport { InternalChannel } from \"./internal-channel\";\n\nconst TRACER_NAME = 'retrying_call';\n\nexport class RetryThrottler {\n  private tokens: number;\n  constructor(private readonly maxTokens: number, private readonly tokenRatio: number, previousRetryThrottler?: RetryThrottler) {\n    if (previousRetryThrottler) {\n      /* When carrying over tokens from a previous config, rescale them to the\n       * new max value */\n      this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);\n    } else {\n      this.tokens = maxTokens;\n    }\n  }\n\n  addCallSucceeded() {\n    this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);\n  }\n\n  addCallFailed() {\n    this.tokens = Math.min(this.tokens - 1, 0);\n  }\n\n  canRetryCall() {\n    return this.tokens > this.maxTokens / 2;\n  }\n}\n\nexport class MessageBufferTracker {\n  private totalAllocated: number = 0;\n  private allocatedPerCall: Map<number, number> = new Map<number, number>();\n\n  constructor(private totalLimit: number, private limitPerCall: number) {}\n\n  allocate(size: number, callId: number): boolean {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {\n      return false;\n    }\n    this.allocatedPerCall.set(callId, currentPerCall + size);\n    this.totalAllocated += size;\n    return true;\n  }\n\n  free(size: number, callId: number) {\n    if (this.totalAllocated < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= size;\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (currentPerCall < size) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);\n    }\n    this.allocatedPerCall.set(callId, currentPerCall - size);\n  }\n\n  freeAll(callId: number) {\n    const currentPerCall = this.allocatedPerCall.get(callId) ?? 0;\n    if (this.totalAllocated < currentPerCall) {\n      throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);\n    }\n    this.totalAllocated -= currentPerCall;\n    this.allocatedPerCall.delete(callId);\n  }\n}\n\ntype UnderlyingCallState = 'ACTIVE' | 'COMPLETED';\n\ninterface UnderlyingCall {\n  state: UnderlyingCallState;\n  call: LoadBalancingCall;\n  nextMessageToSend: number;\n}\n\n/**\n * A retrying call can be in one of these states:\n * RETRY: Retries are configured and new attempts may be sent\n * HEDGING: Hedging is configured and new attempts may be sent\n * TRANSPARENT_ONLY: Neither retries nor hedging are configured, and\n * transparent retry attempts may still be sent\n * COMMITTED: One attempt is committed, and no new attempts will be\n * sent\n */\ntype RetryingCallState = 'RETRY' | 'HEDGING' | 'TRANSPARENT_ONLY' | 'COMMITTED';\n\n/**\n * The different types of objects that can be stored in the write buffer, with\n * the following meanings:\n * MESSAGE: This is a message to be sent.\n * HALF_CLOSE: When this entry is reached, the calls should send a half-close.\n * FREED: This slot previously contained a message that has been sent on all\n * child calls and is no longer needed.\n */\ntype WriteBufferEntryType = 'MESSAGE' | 'HALF_CLOSE' | 'FREED';\n\n/**\n * Entry in the buffer of messages to send to the remote end.\n */\ninterface WriteBufferEntry {\n  entryType: WriteBufferEntryType;\n  /**\n   * Message to send.\n   * Only populated if entryType is MESSAGE.\n   */\n  message?: WriteObject;\n  /**\n   * Callback to call after sending the message.\n   * Only populated if entryType is MESSAGE and the call is in the COMMITTED\n   * state.\n   */\n  callback?: WriteCallback;\n  /**\n   * Indicates whether the message is allocated in the buffer tracker. Ignored\n   * if entryType is not MESSAGE. Should be the return value of\n   * bufferTracker.allocate.\n   */\n  allocated: boolean;\n}\n\nconst PREVIONS_RPC_ATTEMPTS_METADATA_KEY = 'grpc-previous-rpc-attempts';\n\nexport class RetryingCall implements Call {\n  private state: RetryingCallState;\n  private listener: InterceptingListener | null = null;\n  private initialMetadata: Metadata | null = null;\n  private underlyingCalls: UnderlyingCall[] = [];\n  private writeBuffer: WriteBufferEntry[] = [];\n  /**\n   * The offset of message indices in the writeBuffer. For example, if\n   * writeBufferOffset is 10, message 10 is in writeBuffer[0] and message 15\n   * is in writeBuffer[5].\n   */\n  private writeBufferOffset = 0;\n  /**\n   * Tracks whether a read has been started, so that we know whether to start\n   * reads on new child calls. This only matters for the first read, because\n   * once a message comes in the child call becomes committed and there will\n   * be no new child calls.\n   */\n  private readStarted = false;\n  private transparentRetryUsed: boolean = false;\n  /**\n   * Number of attempts so far\n   */\n  private attempts: number = 0;\n  private hedgingTimer: NodeJS.Timer | null = null;\n  private committedCallIndex: number | null = null;\n  private initialRetryBackoffSec = 0;\n  private nextRetryBackoffSec = 0;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host: string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number,\n    private readonly bufferTracker: MessageBufferTracker,\n    private readonly retryThrottler?: RetryThrottler\n  ) {\n    if (callConfig.methodConfig.retryPolicy) {\n      this.state = 'RETRY';\n      const retryPolicy = callConfig.methodConfig.retryPolicy;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));\n    } else if (callConfig.methodConfig.hedgingPolicy) {\n      this.state = 'HEDGING';\n    } else {\n      this.state = 'TRANSPARENT_ONLY';\n    }\n  }\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private reportStatus(statusObject: StatusObject) {\n    this.trace('ended with status: code=' + statusObject.code + ' details=\"' + statusObject.details + '\"');\n    this.bufferTracker.freeAll(this.callNumber);\n    this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;\n    this.writeBuffer = [];\n    process.nextTick(() => {\n      // Explicitly construct status object to remove progress field\n      this.listener?.onReceiveStatus({\n        code: statusObject.code,\n        details: statusObject.details,\n        metadata: statusObject.metadata\n      });\n    });\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.reportStatus({code: status, details, metadata: new Metadata()});\n    for (const {call} of this.underlyingCalls) {\n      call.cancelWithStatus(status, details);\n    }\n  }\n  getPeer(): string {\n    if (this.committedCallIndex !== null) {\n      return this.underlyingCalls[this.committedCallIndex].call.getPeer();\n    } else {\n      return 'unknown';\n    }\n  }\n\n  private getBufferEntry(messageIndex: number): WriteBufferEntry {\n    return this.writeBuffer[messageIndex - this.writeBufferOffset] ?? {entryType: 'FREED', allocated: false};\n  }\n\n  private getNextBufferIndex() {\n    return this.writeBufferOffset + this.writeBuffer.length;\n  }\n\n  private clearSentMessages() {\n    if (this.state !== 'COMMITTED') {\n      return;\n    }\n    const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex!].nextMessageToSend;\n    for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {\n      const bufferEntry = this.getBufferEntry(messageIndex);\n      if (bufferEntry.allocated) {\n        this.bufferTracker.free(bufferEntry.message!.message.length, this.callNumber);\n      }\n    }\n    this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);\n    this.writeBufferOffset = earliestNeededMessageIndex;\n  }\n\n  private commitCall(index: number) {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    if (this.underlyingCalls[index].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('Committing call [' + this.underlyingCalls[index].call.getCallNumber() + '] at index ' + index);\n    this.state = 'COMMITTED';\n    this.committedCallIndex = index;\n    for (let i = 0; i < this.underlyingCalls.length; i++) {\n      if (i === index) {\n        continue;\n      }\n      if (this.underlyingCalls[i].state === 'COMPLETED') {\n        continue;\n      }\n      this.underlyingCalls[i].state = 'COMPLETED';\n      this.underlyingCalls[i].call.cancelWithStatus(Status.CANCELLED, 'Discarded in favor of other hedged attempt');\n    }\n    this.clearSentMessages();\n  }\n\n  private commitCallWithMostMessages() {\n    if (this.state === 'COMMITTED') {\n      return;\n    }\n    let mostMessages = -1;\n    let callWithMostMessages = -1;\n    for (const [index, childCall] of this.underlyingCalls.entries()) {\n      if (childCall.state === 'ACTIVE' && childCall.nextMessageToSend > mostMessages) {\n        mostMessages = childCall.nextMessageToSend;\n        callWithMostMessages = index;\n      }\n    }\n    if (callWithMostMessages === -1) {\n      /* There are no active calls, disable retries to force the next call that\n       * is started to be committed. */\n      this.state = 'TRANSPARENT_ONLY';\n    } else {\n      this.commitCall(callWithMostMessages);\n    }\n  }\n\n  private isStatusCodeInList(list: (Status | string)[], code: Status) {\n    return list.some((value => value === code || value.toString().toLowerCase() === Status[code].toLowerCase()));\n  }\n\n  private getNextRetryBackoffMs() {\n    const retryPolicy = this.callConfig?.methodConfig.retryPolicy;\n    if (!retryPolicy) {\n      return 0;\n    }\n    const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1000;\n    const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));\n    this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);\n    return nextBackoffMs\n  }\n\n  private maybeRetryCall(pushback: number | null, callback: (retried: boolean) => void) {\n    if (this.state !== 'RETRY') {\n      callback(false);\n      return;\n    }\n    const retryPolicy = this.callConfig!.methodConfig.retryPolicy!;\n    if (this.attempts >= Math.min(retryPolicy.maxAttempts, 5)) {\n      callback(false);\n      return;\n    }\n    let retryDelayMs: number;\n    if (pushback === null) {\n      retryDelayMs = this.getNextRetryBackoffMs();\n    } else if (pushback < 0) {\n      this.state = 'TRANSPARENT_ONLY';\n      callback(false);\n      return;\n    } else {\n      retryDelayMs = pushback;\n      this.nextRetryBackoffSec = this.initialRetryBackoffSec;\n    }\n    setTimeout(() => {\n      if (this.state !== 'RETRY') {\n        callback(false);\n        return;\n      }\n      if (this.retryThrottler?.canRetryCall() ?? true) {\n        callback(true);\n        this.attempts += 1;\n        this.startNewAttempt();\n      }\n    }, retryDelayMs);\n  }\n\n  private countActiveCalls(): number {\n    let count = 0;\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE') {\n        count += 1;\n      }\n    }\n    return count;\n  }\n\n  private handleProcessedStatus(status: StatusObject, callIndex: number, pushback: number | null) {\n    switch (this.state) {\n      case 'COMMITTED':\n      case 'TRANSPARENT_ONLY':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'HEDGING':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.hedgingPolicy!.nonFatalStatusCodes ?? [], status.code)) {\n          this.retryThrottler?.addCallFailed();\n          let delayMs: number;\n          if (pushback === null) {\n            delayMs = 0;\n          } else if (pushback < 0) {\n            this.state = 'TRANSPARENT_ONLY';\n            this.commitCall(callIndex);\n            this.reportStatus(status);\n            return;\n          } else {\n            delayMs = pushback;\n          }\n          setTimeout(() => {\n            this.maybeStartHedgingAttempt();\n            // If after trying to start a call there are no active calls, this was the last one\n            if (this.countActiveCalls() === 0) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          }, delayMs);\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n      case 'RETRY':\n        if (this.isStatusCodeInList(this.callConfig!.methodConfig.retryPolicy!.retryableStatusCodes, status.code)) {\n          this.retryThrottler?.addCallFailed();\n          this.maybeRetryCall(pushback, (retried) => {\n            if (!retried) {\n              this.commitCall(callIndex);\n              this.reportStatus(status);\n            }\n          });\n        } else {\n          this.commitCall(callIndex);\n          this.reportStatus(status);\n        }\n        break;\n    }\n  }\n\n  private getPushback(metadata: Metadata): number | null {\n    const mdValue = metadata.get('grpc-retry-pushback-ms');\n    if (mdValue.length === 0) {\n      return null;\n    }\n    try {\n      return parseInt(mdValue[0] as string);\n    } catch (e) {\n      return -1;\n    }\n  }\n\n  private handleChildStatus(status: StatusObjectWithProgress, callIndex: number) {\n    if (this.underlyingCalls[callIndex].state === 'COMPLETED') {\n      return;\n    }\n    this.trace('state=' + this.state + ' handling status with progress ' + status.progress + ' from child [' + this.underlyingCalls[callIndex].call.getCallNumber() + '] in state ' + this.underlyingCalls[callIndex].state);\n    this.underlyingCalls[callIndex].state = 'COMPLETED';\n    if (status.code === Status.OK) {\n      this.retryThrottler?.addCallSucceeded();\n      this.commitCall(callIndex);\n      this.reportStatus(status);\n      return;\n    }\n    if (this.state === 'COMMITTED') {\n      this.reportStatus(status);\n      return;\n    }\n    const pushback = this.getPushback(status.metadata);\n    switch (status.progress) {\n      case 'NOT_STARTED':\n        // RPC never leaves the client, always safe to retry\n        this.startNewAttempt();\n        break;\n      case 'REFUSED':\n        // RPC reaches the server library, but not the server application logic\n        if (this.transparentRetryUsed) {\n          this.handleProcessedStatus(status, callIndex, pushback);\n        } else {\n          this.transparentRetryUsed = true;\n          this.startNewAttempt();\n        };\n        break;\n      case 'DROP':\n        this.commitCall(callIndex);\n        this.reportStatus(status);\n        break;\n      case 'PROCESSED':\n        this.handleProcessedStatus(status, callIndex, pushback);\n        break;\n    }\n  }\n\n  private maybeStartHedgingAttempt() {\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private maybeStartHedgingTimer() {\n    if (this.hedgingTimer) {\n      clearTimeout(this.hedgingTimer);\n    }\n    if (this.state !== 'HEDGING') {\n      return;\n    }\n    if (!this.callConfig.methodConfig.hedgingPolicy) {\n      return;\n    }\n    const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;\n    if (this.attempts >= Math.min(hedgingPolicy.maxAttempts, 5)) {\n      return;\n    }\n    const hedgingDelayString = hedgingPolicy.hedgingDelay ?? '0s';\n    const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));\n    this.hedgingTimer = setTimeout(() => {\n      this.maybeStartHedgingAttempt();\n    }, hedgingDelaySec * 1000);\n    this.hedgingTimer.unref?.();\n  }\n\n  private startNewAttempt() {\n    const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);\n    this.trace('Created child call [' + child.getCallNumber() + '] for attempt ' + this.attempts);\n    const index = this.underlyingCalls.length;\n    this.underlyingCalls.push({state: 'ACTIVE', call: child, nextMessageToSend: 0});\n    const previousAttempts = this.attempts - 1;\n    const initialMetadata = this.initialMetadata!.clone();\n    if (previousAttempts > 0) {\n      initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n    }\n    let receivedMetadata = false;\n    child.start(initialMetadata, {\n      onReceiveMetadata: metadata => {\n        this.trace('Received metadata from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        receivedMetadata = true;\n        if (previousAttempts > 0) {\n          metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMetadata(metadata);\n        }\n      },\n      onReceiveMessage: message => {\n        this.trace('Received message from child [' + child.getCallNumber() + ']');\n        this.commitCall(index);\n        if (this.underlyingCalls[index].state === 'ACTIVE') {\n          this.listener!.onReceiveMessage(message);\n        }\n      },\n      onReceiveStatus: status => {\n        this.trace('Received status from child [' + child.getCallNumber() + ']');\n        if (!receivedMetadata && previousAttempts > 0) {\n          status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);\n        }\n        this.handleChildStatus(status, index);\n      }\n    });\n    this.sendNextChildMessage(index);\n    if (this.readStarted) {\n      child.startRead();\n    }\n  }\n\n  start(metadata: Metadata, listener: InterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.initialMetadata = metadata;\n    this.attempts += 1;\n    this.startNewAttempt();\n    this.maybeStartHedgingTimer();\n  }\n\n  private handleChildWriteCompleted(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    const messageIndex = childCall.nextMessageToSend;\n    this.getBufferEntry(messageIndex).callback?.();\n    this.clearSentMessages();\n    childCall.nextMessageToSend += 1;\n    this.sendNextChildMessage(childIndex);\n  }\n\n  private sendNextChildMessage(childIndex: number) {\n    const childCall = this.underlyingCalls[childIndex];\n    if (childCall.state === 'COMPLETED') {\n      return;\n    }\n    if (this.getBufferEntry(childCall.nextMessageToSend)) {\n      const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);\n      switch (bufferEntry.entryType) {\n        case 'MESSAGE':\n          childCall.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(childIndex);\n            }\n          }, bufferEntry.message!.message);\n          break;\n        case 'HALF_CLOSE':\n          childCall.nextMessageToSend += 1;\n          childCall.call.halfClose();\n          break;\n        case 'FREED':\n          // Should not be possible\n          break;\n      }\n    }\n  }\n\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    const writeObj: WriteObject = {\n      message,\n      flags: context.flags,\n    };\n    const messageIndex = this.getNextBufferIndex();\n    const bufferEntry: WriteBufferEntry = {\n      entryType: 'MESSAGE',\n      message: writeObj,\n      allocated: this.bufferTracker.allocate(message.length, this.callNumber)\n    };\n    this.writeBuffer.push(bufferEntry);\n    if (bufferEntry.allocated) {\n      context.callback?.();\n      for (const [callIndex, call] of this.underlyingCalls.entries()) {\n        if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n          call.call.sendMessageWithContext({\n            callback: (error) => {\n              // Ignore error\n              this.handleChildWriteCompleted(callIndex);\n            }\n          }, message);\n        }\n      }\n    } else {\n      this.commitCallWithMostMessages();\n      // commitCallWithMostMessages can fail if we are between ping attempts\n      if (this.committedCallIndex === null) {\n        return;\n      }\n      const call = this.underlyingCalls[this.committedCallIndex];\n      bufferEntry.callback = context.callback; \n      if (call.state === 'ACTIVE' && call.nextMessageToSend === messageIndex) {\n        call.call.sendMessageWithContext({\n          callback: (error) => {\n            // Ignore error\n            this.handleChildWriteCompleted(this.committedCallIndex!);\n          }\n        }, message);\n      }\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    this.readStarted = true;\n    for (const underlyingCall of this.underlyingCalls) {\n      if (underlyingCall?.state === 'ACTIVE') {\n        underlyingCall.call.startRead();\n      }\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    const halfCloseIndex = this.getNextBufferIndex();\n    this.writeBuffer.push({\n      entryType: 'HALF_CLOSE',\n      allocated: false\n    });\n    for (const call of this.underlyingCalls) {\n      if (call?.state === 'ACTIVE' && call.nextMessageToSend === halfCloseIndex) {\n        call.nextMessageToSend += 1;\n        call.call.halfClose();\n      }\n    }\n  }\n  setCredentials(newCredentials: CallCredentials): void {\n    throw new Error(\"Method not implemented.\");\n  }\n  getMethod(): string {\n    return this.methodName;\n  }\n  getHost(): string {\n    return this.host;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}