{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.setup = exports.getChannelzServiceDefinition = exports.getChannelzHandlers = exports.unregisterChannelzRef = exports.registerChannelzSocket = exports.registerChannelzServer = exports.registerChannelzSubchannel = exports.registerChannelzChannel = exports.ChannelzCallTracker = exports.ChannelzChildrenTracker = exports.ChannelzTrace = void 0;\nconst net_1 = require(\"net\");\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst admin_1 = require(\"./admin\");\nconst make_client_1 = require(\"./make-client\");\nfunction channelRefToMessage(ref) {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction subchannelRefToMessage(ref) {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  };\n}\nfunction serverRefToMessage(ref) {\n  return {\n    server_id: ref.id\n  };\n}\nfunction socketRefToMessage(ref) {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  };\n}\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\nclass ChannelzTrace {\n  constructor() {\n    this.events = [];\n    this.eventsLogged = 0;\n    this.creationTimestamp = new Date();\n  }\n  addTrace(severity, description, child) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: (child === null || child === void 0 ? void 0 : child.kind) === 'channel' ? child : undefined,\n      childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n  getTraceMessage() {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        };\n      })\n    };\n  }\n}\nexports.ChannelzTrace = ChannelzTrace;\nclass ChannelzChildrenTracker {\n  constructor() {\n    this.channelChildren = new Map();\n    this.subchannelChildren = new Map();\n    this.socketChildren = new Map();\n  }\n  refChild(child) {\n    var _a, _b, _c;\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = (_a = this.channelChildren.get(child.id)) !== null && _a !== void 0 ? _a : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.channelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = (_b = this.subchannelChildren.get(child.id)) !== null && _b !== void 0 ? _b : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.subchannelChildren.set(child.id, trackedChild);\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = (_c = this.socketChildren.get(child.id)) !== null && _c !== void 0 ? _c : {\n            ref: child,\n            count: 0\n          };\n          trackedChild.count += 1;\n          this.socketChildren.set(child.id, trackedChild);\n          break;\n        }\n    }\n  }\n  unrefChild(child) {\n    switch (child.kind) {\n      case 'channel':\n        {\n          let trackedChild = this.channelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.channelChildren.delete(child.id);\n            } else {\n              this.channelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'subchannel':\n        {\n          let trackedChild = this.subchannelChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.subchannelChildren.delete(child.id);\n            } else {\n              this.subchannelChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n      case 'socket':\n        {\n          let trackedChild = this.socketChildren.get(child.id);\n          if (trackedChild !== undefined) {\n            trackedChild.count -= 1;\n            if (trackedChild.count === 0) {\n              this.socketChildren.delete(child.id);\n            } else {\n              this.socketChildren.set(child.id, trackedChild);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getChildLists() {\n    const channels = [];\n    for (const {\n      ref\n    } of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels = [];\n    for (const {\n      ref\n    } of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets = [];\n    for (const {\n      ref\n    } of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {\n      channels,\n      subchannels,\n      sockets\n    };\n  }\n}\nexports.ChannelzChildrenTracker = ChannelzChildrenTracker;\nclass ChannelzCallTracker {\n  constructor() {\n    this.callsStarted = 0;\n    this.callsSucceeded = 0;\n    this.callsFailed = 0;\n    this.lastCallStartedTimestamp = null;\n  }\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\nexports.ChannelzCallTracker = ChannelzCallTracker;\nlet nextId = 1;\nfunction getNextId() {\n  return nextId++;\n}\nconst channels = [];\nconst subchannels = [];\nconst servers = [];\nconst sockets = [];\nfunction registerChannelzChannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'channel'\n  };\n  if (channelzEnabled) {\n    channels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzChannel = registerChannelzChannel;\nfunction registerChannelzSubchannel(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'subchannel'\n  };\n  if (channelzEnabled) {\n    subchannels[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSubchannel = registerChannelzSubchannel;\nfunction registerChannelzServer(getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    kind: 'server'\n  };\n  if (channelzEnabled) {\n    servers[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzServer = registerChannelzServer;\nfunction registerChannelzSocket(name, getInfo, channelzEnabled) {\n  const id = getNextId();\n  const ref = {\n    id,\n    name,\n    kind: 'socket'\n  };\n  if (channelzEnabled) {\n    sockets[id] = {\n      ref,\n      getInfo\n    };\n  }\n  return ref;\n}\nexports.registerChannelzSocket = registerChannelzSocket;\nfunction unregisterChannelzRef(ref) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\nexports.unregisterChannelzRef = unregisterChannelzRef;\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection) {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk) {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result = [];\n  return result.concat(...bytePairs);\n}\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns\n */\nfunction ipAddressStringToBuffer(ipAddress) {\n  if ((0, net_1.isIPv4)(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if ((0, net_1.isIPv6)(ipAddress)) {\n    let leftSection;\n    let rightSection;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\nfunction connectivityStateToMessage(state) {\n  switch (state) {\n    case connectivity_state_1.ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case connectivity_state_1.ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case connectivity_state_1.ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case connectivity_state_1.ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\nfunction dateToProtoTimestamp(date) {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: millisSinceEpoch / 1000 | 0,\n    nanos: millisSinceEpoch % 1000 * 1000000\n  };\n}\nfunction getChannelMessage(channelEntry) {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\nfunction GetChannel(call, callback) {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {\n    channel: getChannelMessage(channelEntry)\n  });\n}\nfunction GetTopChannels(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\nfunction getServerMessage(serverEntry) {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\nfunction GetServer(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {\n    server: getServerMessage(serverEntry)\n  });\n}\nfunction GetServers(call, callback) {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\nfunction GetSubchannel(call, callback) {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {\n    subchannel: subchannelMessage\n  });\n}\nfunction subchannelAddressToAddressMessage(subchannelAddress) {\n  var _a;\n  if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: (_a = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a !== void 0 ? _a : undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\nfunction GetSocket(call, callback) {\n  var _a, _b, _c, _d, _e;\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: (_a = resolvedInfo.security.cipherSuiteStandardName) !== null && _a !== void 0 ? _a : undefined,\n      other_name: (_b = resolvedInfo.security.cipherSuiteOtherName) !== null && _b !== void 0 ? _b : undefined,\n      local_certificate: (_c = resolvedInfo.security.localCertificate) !== null && _c !== void 0 ? _c : undefined,\n      remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : undefined\n    }\n  } : null;\n  const socketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? {\n        value: resolvedInfo.localFlowControlWindow\n      } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {\n        value: resolvedInfo.remoteFlowControlWindow\n      } : null\n    }\n  };\n  callback(null, {\n    socket: socketMessage\n  });\n}\nfunction GetServerSockets(call, callback) {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': constants_1.Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\nfunction getChannelzHandlers() {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\nexports.getChannelzHandlers = getChannelzHandlers;\nlet loadedChannelzDefinition = null;\nfunction getChannelzServiceDefinition() {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [`${__dirname}/../../proto`]\n  });\n  const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\nexports.getChannelzServiceDefinition = getChannelzServiceDefinition;\nfunction setup() {\n  (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);\n}\nexports.setup = setup;","map":{"version":3,"names":["net_1","require","connectivity_state_1","constants_1","subchannel_address_1","admin_1","make_client_1","channelRefToMessage","ref","channel_id","id","name","subchannelRefToMessage","subchannel_id","serverRefToMessage","server_id","socketRefToMessage","socket_id","TARGET_RETAINED_TRACES","ChannelzTrace","constructor","events","eventsLogged","creationTimestamp","Date","addTrace","severity","description","child","timestamp","push","childChannel","kind","undefined","childSubchannel","length","slice","getTraceMessage","creation_timestamp","dateToProtoTimestamp","num_events_logged","map","event","channel_ref","subchannel_ref","exports","ChannelzChildrenTracker","channelChildren","Map","subchannelChildren","socketChildren","refChild","trackedChild","_a","get","count","set","_b","_c","unrefChild","delete","getChildLists","channels","values","subchannels","sockets","ChannelzCallTracker","callsStarted","callsSucceeded","callsFailed","lastCallStartedTimestamp","addCallStarted","addCallSucceeded","addCallFailed","nextId","getNextId","servers","registerChannelzChannel","getInfo","channelzEnabled","registerChannelzSubchannel","registerChannelzServer","registerChannelzSocket","unregisterChannelzRef","parseIPv6Section","addressSection","numberValue","Number","parseInt","parseIPv6Chunk","addressChunk","bytePairs","split","section","result","concat","ipAddressStringToBuffer","ipAddress","isIPv4","Buffer","from","Uint8Array","segment","isIPv6","leftSection","rightSection","doubleColonIndex","indexOf","substring","leftBuffer","rightBuffer","middleBuffer","alloc","connectivityStateToMessage","state","ConnectivityState","CONNECTING","IDLE","READY","SHUTDOWN","TRANSIENT_FAILURE","date","millisSinceEpoch","getTime","seconds","nanos","getChannelMessage","channelEntry","resolvedInfo","data","target","calls_started","callTracker","calls_succeeded","calls_failed","last_call_started_timestamp","trace","children","GetChannel","call","callback","channelId","request","Status","NOT_FOUND","channel","GetTopChannels","maxResults","max_results","resultList","i","start_channel_id","end","getServerMessage","serverEntry","listen_socket","listenerChildren","GetServer","serverId","server","GetServers","start_server_id","GetSubchannel","subchannelId","subchannelEntry","subchannelMessage","socket_ref","subchannel","subchannelAddressToAddressMessage","subchannelAddress","isTcpSubchannelAddress","address","tcpip_address","ip_address","host","port","uds_address","filename","path","GetSocket","socketId","socketEntry","securityMessage","security","model","tls","cipher_suite","cipherSuiteStandardName","standard_name","other_name","cipherSuiteOtherName","local_certificate","localCertificate","remote_certificate","_d","remoteCertificate","socketMessage","local","localAddress","remote","remoteAddress","remote_name","_e","remoteName","keep_alives_sent","keepAlivesSent","streams_started","streamsStarted","streams_succeeded","streamsSucceeded","streams_failed","streamsFailed","last_local_stream_created_timestamp","lastLocalStreamCreatedTimestamp","last_remote_stream_created_timestamp","lastRemoteStreamCreatedTimestamp","messages_received","messagesReceived","messages_sent","messagesSent","last_message_received_timestamp","lastMessageReceivedTimestamp","last_message_sent_timestamp","lastMessageSentTimestamp","local_flow_control_window","localFlowControlWindow","value","remote_flow_control_window","remoteFlowControlWindow","socket","GetServerSockets","startId","start_socket_id","allSockets","sessionChildren","sort","ref1","ref2","getChannelzHandlers","loadedChannelzDefinition","getChannelzServiceDefinition","loaderLoadSync","loadSync","loadedProto","keepCase","longs","String","enums","defaults","oneofs","includeDirs","__dirname","channelzGrpcObject","loadPackageDefinition","grpc","channelz","v1","Channelz","service","setup","registerAdminService"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/channelz.ts"],"sourcesContent":["/*\n * Copyright 2021 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { isIPv4, isIPv6 } from \"net\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { Status } from \"./constants\";\nimport { Timestamp } from \"./generated/google/protobuf/Timestamp\";\nimport { Channel as ChannelMessage } from \"./generated/grpc/channelz/v1/Channel\";\nimport { ChannelConnectivityState__Output } from \"./generated/grpc/channelz/v1/ChannelConnectivityState\";\nimport { ChannelRef as ChannelRefMessage } from \"./generated/grpc/channelz/v1/ChannelRef\";\nimport { ChannelTrace } from \"./generated/grpc/channelz/v1/ChannelTrace\";\nimport { GetChannelRequest__Output } from \"./generated/grpc/channelz/v1/GetChannelRequest\";\nimport { GetChannelResponse } from \"./generated/grpc/channelz/v1/GetChannelResponse\";\nimport { sendUnaryData, ServerUnaryCall } from \"./server-call\";\nimport { ServerRef as ServerRefMessage } from \"./generated/grpc/channelz/v1/ServerRef\";\nimport { SocketRef as SocketRefMessage } from \"./generated/grpc/channelz/v1/SocketRef\";\nimport { isTcpSubchannelAddress, SubchannelAddress } from \"./subchannel-address\";\nimport { SubchannelRef as SubchannelRefMessage } from \"./generated/grpc/channelz/v1/SubchannelRef\";\nimport { GetServerRequest__Output } from \"./generated/grpc/channelz/v1/GetServerRequest\";\nimport { GetServerResponse } from \"./generated/grpc/channelz/v1/GetServerResponse\";\nimport { Server as ServerMessage } from \"./generated/grpc/channelz/v1/Server\";\nimport { GetServersRequest__Output } from \"./generated/grpc/channelz/v1/GetServersRequest\";\nimport { GetServersResponse } from \"./generated/grpc/channelz/v1/GetServersResponse\";\nimport { GetTopChannelsRequest__Output } from \"./generated/grpc/channelz/v1/GetTopChannelsRequest\";\nimport { GetTopChannelsResponse } from \"./generated/grpc/channelz/v1/GetTopChannelsResponse\";\nimport { GetSubchannelRequest__Output } from \"./generated/grpc/channelz/v1/GetSubchannelRequest\";\nimport { GetSubchannelResponse } from \"./generated/grpc/channelz/v1/GetSubchannelResponse\";\nimport { Subchannel as SubchannelMessage } from \"./generated/grpc/channelz/v1/Subchannel\";\nimport { GetSocketRequest__Output } from \"./generated/grpc/channelz/v1/GetSocketRequest\";\nimport { GetSocketResponse } from \"./generated/grpc/channelz/v1/GetSocketResponse\";\nimport { Socket as SocketMessage } from \"./generated/grpc/channelz/v1/Socket\";\nimport { Address } from \"./generated/grpc/channelz/v1/Address\";\nimport { Security } from \"./generated/grpc/channelz/v1/Security\";\nimport { GetServerSocketsRequest__Output } from \"./generated/grpc/channelz/v1/GetServerSocketsRequest\";\nimport { GetServerSocketsResponse } from \"./generated/grpc/channelz/v1/GetServerSocketsResponse\";\nimport { ChannelzDefinition, ChannelzHandlers } from \"./generated/grpc/channelz/v1/Channelz\";\nimport { ProtoGrpcType as ChannelzProtoGrpcType } from \"./generated/channelz\";\nimport type { loadSync } from '@grpc/proto-loader';\nimport { registerAdminService } from \"./admin\";\nimport { loadPackageDefinition } from \"./make-client\";\n\nexport type TraceSeverity = 'CT_UNKNOWN' | 'CT_INFO' | 'CT_WARNING' | 'CT_ERROR';\n\nexport interface ChannelRef {\n  kind: 'channel';\n  id: number;\n  name: string;\n}\n\nexport interface SubchannelRef {\n  kind: 'subchannel';\n  id: number;\n  name: string;\n}\n\nexport interface ServerRef {\n  kind: 'server';\n  id: number;\n}\n\nexport interface SocketRef {\n  kind: 'socket';\n  id: number;\n  name: string;\n}\n\nfunction channelRefToMessage(ref: ChannelRef): ChannelRefMessage {\n  return {\n    channel_id: ref.id,\n    name: ref.name\n  };\n}\n\nfunction subchannelRefToMessage(ref: SubchannelRef): SubchannelRefMessage {\n  return {\n    subchannel_id: ref.id,\n    name: ref.name\n  }\n}\n\nfunction serverRefToMessage(ref: ServerRef): ServerRefMessage {\n  return {\n    server_id: ref.id\n  }\n}\n\nfunction socketRefToMessage(ref: SocketRef): SocketRefMessage {\n  return {\n    socket_id: ref.id,\n    name: ref.name\n  }\n}\n\ninterface TraceEvent {\n  description: string;\n  severity: TraceSeverity;\n  timestamp: Date;\n  childChannel?: ChannelRef;\n  childSubchannel?: SubchannelRef;\n}\n\n/**\n * The loose upper bound on the number of events that should be retained in a\n * trace. This may be exceeded by up to a factor of 2. Arbitrarily chosen as a\n * number that should be large enough to contain the recent relevant\n * information, but small enough to not use excessive memory.\n */\nconst TARGET_RETAINED_TRACES = 32;\n\nexport class ChannelzTrace {\n  events: TraceEvent[] = [];\n  creationTimestamp: Date;\n  eventsLogged: number = 0;\n\n  constructor() {\n    this.creationTimestamp = new Date();\n  }\n\n  addTrace(severity: TraceSeverity, description: string, child?: ChannelRef | SubchannelRef) {\n    const timestamp = new Date();\n    this.events.push({\n      description: description,\n      severity: severity,\n      timestamp: timestamp,\n      childChannel: child?.kind === 'channel' ? child : undefined,\n      childSubchannel: child?.kind === 'subchannel' ? child : undefined\n    });\n    // Whenever the trace array gets too large, discard the first half\n    if (this.events.length >= TARGET_RETAINED_TRACES * 2) {\n      this.events = this.events.slice(TARGET_RETAINED_TRACES);\n    }\n    this.eventsLogged += 1;\n  }\n\n  getTraceMessage(): ChannelTrace {\n    return {\n      creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),\n      num_events_logged: this.eventsLogged,\n      events: this.events.map(event => {\n        return {\n          description: event.description,\n          severity: event.severity,\n          timestamp: dateToProtoTimestamp(event.timestamp),\n          channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,\n          subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null\n        }\n      })\n    };\n  }\n}\n\nexport class ChannelzChildrenTracker {\n  private channelChildren: Map<number, {ref: ChannelRef, count: number}> = new Map<number, {ref: ChannelRef, count: number}>();\n  private subchannelChildren: Map<number, {ref: SubchannelRef, count: number}> = new Map<number, {ref: SubchannelRef, count: number}>();\n  private socketChildren: Map<number, {ref: SocketRef, count: number}> = new Map<number, {ref: SocketRef, count: number}>();\n\n  refChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.channelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'subchannel':{\n        let trackedChild = this.subchannelChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.subchannelChildren.set(child.id, trackedChild);\n        break;\n      }\n      case 'socket':{\n        let trackedChild = this.socketChildren.get(child.id) ?? {ref: child, count: 0};\n        trackedChild.count += 1;\n        this.socketChildren.set(child.id, trackedChild);\n        break;\n      }\n    }\n  }\n\n  unrefChild(child: ChannelRef | SubchannelRef | SocketRef) {\n    switch (child.kind) {\n      case 'channel': {\n        let trackedChild = this.channelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.channelChildren.delete(child.id);\n          } else {\n            this.channelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'subchannel': {\n        let trackedChild = this.subchannelChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.subchannelChildren.delete(child.id);\n          } else {\n            this.subchannelChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n      case 'socket': {\n        let trackedChild = this.socketChildren.get(child.id);\n        if (trackedChild !== undefined) {\n          trackedChild.count -= 1;\n          if (trackedChild.count === 0) {\n            this.socketChildren.delete(child.id);\n          } else {\n            this.socketChildren.set(child.id, trackedChild);\n          }\n        }\n        break;\n      }\n    }\n  }\n\n  getChildLists(): ChannelzChildren {\n    const channels: ChannelRef[] = [];\n    for (const {ref} of this.channelChildren.values()) {\n      channels.push(ref);\n    }\n    const subchannels: SubchannelRef[] = [];\n    for (const {ref} of this.subchannelChildren.values()) {\n      subchannels.push(ref);\n    }\n    const sockets: SocketRef[] = [];\n    for (const {ref} of this.socketChildren.values()) {\n      sockets.push(ref);\n    }\n    return {channels, subchannels, sockets};\n  }\n}\n\nexport class ChannelzCallTracker {\n  callsStarted: number = 0;\n  callsSucceeded: number = 0;\n  callsFailed: number = 0;\n  lastCallStartedTimestamp: Date | null = null;\n\n  addCallStarted() {\n    this.callsStarted += 1;\n    this.lastCallStartedTimestamp = new Date();\n  }\n  addCallSucceeded() {\n    this.callsSucceeded += 1;\n  }\n  addCallFailed() {\n    this.callsFailed += 1;\n  }\n}\n\nexport interface ChannelzChildren {\n  channels: ChannelRef[];\n  subchannels: SubchannelRef[];\n  sockets: SocketRef[];\n}\n\nexport interface ChannelInfo {\n  target: string;\n  state: ConnectivityState;\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  children: ChannelzChildren;\n}\n\nexport interface SubchannelInfo extends ChannelInfo {}\n\nexport interface ServerInfo {\n  trace: ChannelzTrace;\n  callTracker: ChannelzCallTracker;\n  listenerChildren: ChannelzChildren;\n  sessionChildren: ChannelzChildren;\n}\n\nexport interface TlsInfo {\n  cipherSuiteStandardName: string | null;\n  cipherSuiteOtherName: string | null;\n  localCertificate: Buffer | null;\n  remoteCertificate: Buffer | null;\n}\n\nexport interface SocketInfo {\n  localAddress: SubchannelAddress | null;\n  remoteAddress: SubchannelAddress | null;\n  security: TlsInfo | null;\n  remoteName: string | null;\n  streamsStarted: number;\n  streamsSucceeded: number;\n  streamsFailed: number;\n  messagesSent: number;\n  messagesReceived: number;\n  keepAlivesSent: number;\n  lastLocalStreamCreatedTimestamp: Date | null;\n  lastRemoteStreamCreatedTimestamp: Date | null;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n  localFlowControlWindow: number | null;\n  remoteFlowControlWindow: number | null;\n}\n\ninterface ChannelEntry {\n  ref: ChannelRef;\n  getInfo(): ChannelInfo;\n}\n\ninterface SubchannelEntry {\n  ref: SubchannelRef;\n  getInfo(): SubchannelInfo;\n}\n\ninterface ServerEntry {\n  ref: ServerRef;\n  getInfo(): ServerInfo;\n}\n\ninterface SocketEntry {\n  ref: SocketRef;\n  getInfo(): SocketInfo;\n}\n\nlet nextId = 1;\n\nfunction getNextId(): number {\n  return nextId++;\n}\n\nconst channels: (ChannelEntry | undefined)[] = [];\nconst subchannels: (SubchannelEntry | undefined)[] = [];\nconst servers: (ServerEntry | undefined)[] = [];\nconst sockets: (SocketEntry | undefined)[] = [];\n\nexport function registerChannelzChannel(name: string, getInfo: () => ChannelInfo, channelzEnabled: boolean): ChannelRef {\n  const id = getNextId();\n  const ref: ChannelRef = {id, name, kind: 'channel'};\n  if (channelzEnabled) {\n    channels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSubchannel(name: string, getInfo:() => SubchannelInfo, channelzEnabled: boolean): SubchannelRef {\n  const id = getNextId();\n  const ref: SubchannelRef = {id, name, kind: 'subchannel'};\n  if (channelzEnabled) {\n    subchannels[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzServer(getInfo: () => ServerInfo, channelzEnabled: boolean): ServerRef {\n  const id = getNextId();\n  const ref: ServerRef = {id, kind: 'server'};\n  if (channelzEnabled) {\n    servers[id] = { ref, getInfo };\n  }\n  return ref;\n}\n\nexport function registerChannelzSocket(name: string, getInfo: () => SocketInfo, channelzEnabled: boolean): SocketRef {\n  const id = getNextId();\n  const ref: SocketRef = {id, name, kind: 'socket'};\n  if (channelzEnabled) {\n    sockets[id] = { ref, getInfo};\n  }\n  return ref;\n}\n\nexport function unregisterChannelzRef(ref: ChannelRef | SubchannelRef | ServerRef | SocketRef) {\n  switch (ref.kind) {\n    case 'channel':\n      delete channels[ref.id];\n      return;\n    case 'subchannel':\n      delete subchannels[ref.id];\n      return;\n    case 'server':\n      delete servers[ref.id];\n      return;\n    case 'socket':\n      delete sockets[ref.id];\n      return;\n  }\n}\n\n/**\n * Parse a single section of an IPv6 address as two bytes\n * @param addressSection A hexadecimal string of length up to 4\n * @returns The pair of bytes representing this address section\n */\nfunction parseIPv6Section(addressSection: string): [number, number] {\n  const numberValue = Number.parseInt(addressSection, 16);\n  return [numberValue / 256 | 0, numberValue % 256];\n}\n\n/**\n * Parse a chunk of an IPv6 address string to some number of bytes\n * @param addressChunk Some number of segments of up to 4 hexadecimal\n *   characters each, joined by colons.\n * @returns The list of bytes representing this address chunk\n */\nfunction parseIPv6Chunk(addressChunk: string): number[] {\n  if (addressChunk === '') {\n    return [];\n  }\n  const bytePairs = addressChunk.split(':').map(section => parseIPv6Section(section));\n  const result: number[] = [];\n  return result.concat(...bytePairs);\n}\n\n/**\n * Converts an IPv4 or IPv6 address from string representation to binary\n * representation\n * @param ipAddress an IP address in standard IPv4 or IPv6 text format\n * @returns \n */\nfunction ipAddressStringToBuffer(ipAddress: string): Buffer | null {\n  if (isIPv4(ipAddress)) {\n    return Buffer.from(Uint8Array.from(ipAddress.split('.').map(segment => Number.parseInt(segment))));\n  } else if (isIPv6(ipAddress)) {\n    let leftSection: string;\n    let rightSection: string;\n    const doubleColonIndex = ipAddress.indexOf('::');\n    if (doubleColonIndex === -1) {\n      leftSection = ipAddress;\n      rightSection = '';\n    } else {\n      leftSection = ipAddress.substring(0, doubleColonIndex);\n      rightSection = ipAddress.substring(doubleColonIndex + 2);\n    }\n    const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));\n    const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));\n    const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);\n    return Buffer.concat([leftBuffer, middleBuffer, rightBuffer]);\n  } else {\n    return null;\n  }\n}\n\nfunction connectivityStateToMessage(state: ConnectivityState): ChannelConnectivityState__Output {\n  switch (state) {\n    case ConnectivityState.CONNECTING:\n      return {\n        state: 'CONNECTING'\n      };\n    case ConnectivityState.IDLE:\n      return {\n        state: 'IDLE'\n      };\n    case ConnectivityState.READY:\n      return {\n        state: 'READY'\n      };\n    case ConnectivityState.SHUTDOWN:\n      return {\n        state: 'SHUTDOWN'\n      };\n    case ConnectivityState.TRANSIENT_FAILURE:\n      return {\n        state: 'TRANSIENT_FAILURE'\n      };\n    default:\n      return {\n        state: 'UNKNOWN'\n      };\n  }\n}\n\nfunction dateToProtoTimestamp(date?: Date | null): Timestamp | null {\n  if (!date) {\n    return null;\n  }\n  const millisSinceEpoch = date.getTime();\n  return {\n    seconds: (millisSinceEpoch / 1000) | 0,\n    nanos: (millisSinceEpoch % 1000) * 1_000_000\n  }\n}\n\nfunction getChannelMessage(channelEntry: ChannelEntry): ChannelMessage {\n  const resolvedInfo = channelEntry.getInfo();\n  return {\n    ref: channelRefToMessage(channelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    channel_ref: resolvedInfo.children.channels.map(ref => channelRefToMessage(ref)),\n    subchannel_ref: resolvedInfo.children.subchannels.map(ref => subchannelRefToMessage(ref))\n  };\n}\n\nfunction GetChannel(call: ServerUnaryCall<GetChannelRequest__Output, GetChannelResponse>, callback: sendUnaryData<GetChannelResponse>): void {\n  const channelId = Number.parseInt(call.request.channel_id);\n  const channelEntry = channels[channelId];\n  if (channelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No channel data found for id ' + channelId\n    });\n    return;\n  }\n  callback(null, {channel: getChannelMessage(channelEntry)});\n}\n\nfunction GetTopChannels(call: ServerUnaryCall<GetTopChannelsRequest__Output, GetTopChannelsResponse>, callback: sendUnaryData<GetTopChannelsResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ChannelMessage[] = [];\n  let i = Number.parseInt(call.request.start_channel_id);\n  for (; i < channels.length; i++) {\n    const channelEntry = channels[i];\n    if (channelEntry === undefined) {\n      continue;\n    }\n    resultList.push(getChannelMessage(channelEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    channel: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction getServerMessage(serverEntry: ServerEntry): ServerMessage {\n  const resolvedInfo = serverEntry.getInfo();\n  return {\n    ref: serverRefToMessage(serverEntry.ref),\n    data: {\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    listen_socket: resolvedInfo.listenerChildren.sockets.map(ref => socketRefToMessage(ref))\n  };\n}\n\nfunction GetServer(call: ServerUnaryCall<GetServerRequest__Output, GetServerResponse>, callback: sendUnaryData<GetServerResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  callback(null, {server: getServerMessage(serverEntry)});\n}\n\nfunction GetServers(call: ServerUnaryCall<GetServersRequest__Output, GetServersResponse>, callback: sendUnaryData<GetServersResponse>): void {\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resultList: ServerMessage[] = [];\n  let i = Number.parseInt(call.request.start_server_id);\n  for (; i < servers.length; i++) {\n    const serverEntry = servers[i];\n    if (serverEntry === undefined) {\n      continue;\n    }\n    resultList.push(getServerMessage(serverEntry));\n    if (resultList.length >= maxResults) {\n      break;\n    }\n  }\n  callback(null, {\n    server: resultList,\n    end: i >= servers.length\n  });\n}\n\nfunction GetSubchannel(call: ServerUnaryCall<GetSubchannelRequest__Output, GetSubchannelResponse>, callback: sendUnaryData<GetSubchannelResponse>): void {\n  const subchannelId = Number.parseInt(call.request.subchannel_id);\n  const subchannelEntry = subchannels[subchannelId];\n  if (subchannelEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No subchannel data found for id ' + subchannelId\n    });\n    return;\n  }\n  const resolvedInfo = subchannelEntry.getInfo();\n  const subchannelMessage: SubchannelMessage = {\n    ref: subchannelRefToMessage(subchannelEntry.ref),\n    data: {\n      target: resolvedInfo.target,\n      state: connectivityStateToMessage(resolvedInfo.state),\n      calls_started: resolvedInfo.callTracker.callsStarted,\n      calls_succeeded: resolvedInfo.callTracker.callsSucceeded,\n      calls_failed: resolvedInfo.callTracker.callsFailed,\n      last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),\n      trace: resolvedInfo.trace.getTraceMessage()\n    },\n    socket_ref: resolvedInfo.children.sockets.map(ref => socketRefToMessage(ref))\n  };\n  callback(null, {subchannel: subchannelMessage});\n}\n\nfunction subchannelAddressToAddressMessage(subchannelAddress: SubchannelAddress): Address {\n  if (isTcpSubchannelAddress(subchannelAddress)) {\n    return {\n      address: 'tcpip_address',\n      tcpip_address: {\n        ip_address: ipAddressStringToBuffer(subchannelAddress.host) ?? undefined,\n        port: subchannelAddress.port\n      }\n    };\n  } else {\n    return {\n      address: 'uds_address',\n      uds_address: {\n        filename: subchannelAddress.path\n      }\n    };\n  }\n}\n\nfunction GetSocket(call: ServerUnaryCall<GetSocketRequest__Output, GetSocketResponse>, callback: sendUnaryData<GetSocketResponse>): void {\n  const socketId = Number.parseInt(call.request.socket_id);\n  const socketEntry = sockets[socketId];\n  if (socketEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No socket data found for id ' + socketId\n    });\n    return;\n  }\n  const resolvedInfo = socketEntry.getInfo();\n  const securityMessage: Security | null = resolvedInfo.security ? {\n    model: 'tls',\n    tls: {\n      cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? 'standard_name' : 'other_name',\n      standard_name: resolvedInfo.security.cipherSuiteStandardName ?? undefined,\n      other_name: resolvedInfo.security.cipherSuiteOtherName ?? undefined,\n      local_certificate: resolvedInfo.security.localCertificate ?? undefined,\n      remote_certificate: resolvedInfo.security.remoteCertificate ?? undefined\n    }\n  } : null;\n  const socketMessage: SocketMessage = {\n    ref: socketRefToMessage(socketEntry.ref),\n    local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,\n    remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,\n    remote_name: resolvedInfo.remoteName ?? undefined,\n    security: securityMessage,\n    data: {\n      keep_alives_sent: resolvedInfo.keepAlivesSent,\n      streams_started: resolvedInfo.streamsStarted,\n      streams_succeeded: resolvedInfo.streamsSucceeded,\n      streams_failed: resolvedInfo.streamsFailed,\n      last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),\n      last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),\n      messages_received: resolvedInfo.messagesReceived,\n      messages_sent: resolvedInfo.messagesSent,\n      last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),\n      last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),\n      local_flow_control_window: resolvedInfo.localFlowControlWindow ? { value: resolvedInfo.localFlowControlWindow } : null,\n      remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? { value: resolvedInfo.remoteFlowControlWindow } : null,\n    }\n  };\n  callback(null, {socket: socketMessage});\n}\n\nfunction GetServerSockets(call: ServerUnaryCall<GetServerSocketsRequest__Output, GetServerSocketsResponse>, callback: sendUnaryData<GetServerSocketsResponse>): void {\n  const serverId = Number.parseInt(call.request.server_id);\n  const serverEntry = servers[serverId];\n  if (serverEntry === undefined) {\n    callback({\n      'code': Status.NOT_FOUND,\n      'details': 'No server data found for id ' + serverId\n    });\n    return;\n  }\n  const startId = Number.parseInt(call.request.start_socket_id);\n  const maxResults = Number.parseInt(call.request.max_results);\n  const resolvedInfo = serverEntry.getInfo();\n  // If we wanted to include listener sockets in the result, this line would\n  // instead say\n  // const allSockets = resolvedInfo.listenerChildren.sockets.concat(resolvedInfo.sessionChildren.sockets).sort((ref1, ref2) => ref1.id - ref2.id);\n  const allSockets = resolvedInfo.sessionChildren.sockets.sort((ref1, ref2) => ref1.id - ref2.id);\n  const resultList: SocketRefMessage[] = [];\n  let i = 0;\n  for (; i < allSockets.length; i++) {\n    if (allSockets[i].id >= startId) {\n      resultList.push(socketRefToMessage(allSockets[i]));\n      if (resultList.length >= maxResults) {\n        break;\n      }\n    }\n  }\n  callback(null, {\n    socket_ref: resultList,\n    end: i >= allSockets.length\n  });\n}\n\nexport function getChannelzHandlers(): ChannelzHandlers {\n  return {\n    GetChannel,\n    GetTopChannels,\n    GetServer,\n    GetServers,\n    GetSubchannel,\n    GetSocket,\n    GetServerSockets\n  };\n}\n\nlet loadedChannelzDefinition: ChannelzDefinition | null = null;\n\nexport function getChannelzServiceDefinition(): ChannelzDefinition {\n  if (loadedChannelzDefinition) {\n    return loadedChannelzDefinition;\n  }\n  /* The purpose of this complexity is to avoid loading @grpc/proto-loader at\n   * runtime for users who will not use/enable channelz. */\n  const loaderLoadSync = require('@grpc/proto-loader').loadSync as typeof loadSync;\n  const loadedProto = loaderLoadSync('channelz.proto', {\n    keepCase: true,\n    longs: String,\n    enums: String,\n    defaults: true,\n    oneofs: true,\n    includeDirs: [\n      `${__dirname}/../../proto`\n    ]\n  });\n  const channelzGrpcObject = loadPackageDefinition(loadedProto) as unknown as ChannelzProtoGrpcType;\n  loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;\n  return loadedChannelzDefinition;\n}\n\nexport function setup() {\n  registerAdminService(getChannelzServiceDefinition, getChannelzHandlers);\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}