{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LoadBalancingCall = void 0;\nconst connectivity_state_1 = require(\"./connectivity-state\");\nconst constants_1 = require(\"./constants\");\nconst deadline_1 = require(\"./deadline\");\nconst metadata_1 = require(\"./metadata\");\nconst picker_1 = require(\"./picker\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst logging = require(\"./logging\");\nconst control_plane_status_1 = require(\"./control-plane-status\");\nconst http2 = require(\"http2\");\nconst TRACER_NAME = 'load_balancing_call';\nclass LoadBalancingCall {\n  constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {\n    var _a, _b;\n    this.channel = channel;\n    this.callConfig = callConfig;\n    this.methodName = methodName;\n    this.host = host;\n    this.credentials = credentials;\n    this.deadline = deadline;\n    this.callNumber = callNumber;\n    this.child = null;\n    this.readPending = false;\n    this.pendingMessage = null;\n    this.pendingHalfClose = false;\n    this.pendingChildStatus = null;\n    this.ended = false;\n    this.metadata = null;\n    this.listener = null;\n    this.onCallEnded = null;\n    const splitPath = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = (_b = (_a = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '[' + this.callNumber + '] ' + text);\n  }\n  outputStatus(status, progress) {\n    var _a, _b;\n    if (!this.ended) {\n      this.ended = true;\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      const finalStatus = Object.assign(Object.assign({}, status), {\n        progress\n      });\n      (_a = this.listener) === null || _a === void 0 ? void 0 : _a.onReceiveStatus(finalStatus);\n      (_b = this.onCallEnded) === null || _b === void 0 ? void 0 : _b.call(this, finalStatus.code);\n    }\n  }\n  doPick() {\n    var _a, _b;\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called');\n    const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n    const subchannelString = pickResult.subchannel ? '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : '' + pickResult.subchannel;\n    this.trace('Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + subchannelString + ' status: ' + ((_a = pickResult.status) === null || _a === void 0 ? void 0 : _a.code) + ' ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.details));\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        this.credentials.generateMetadata({\n          service_url: this.serviceUrl\n        }).then(credsMetadata => {\n          var _a, _b, _c;\n          const finalMetadata = this.metadata.clone();\n          finalMetadata.merge(credsMetadata);\n          if (finalMetadata.get('authorization').length > 1) {\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: '\"authorization\" metadata cannot have multiple values',\n              metadata: new metadata_1.Metadata()\n            }, 'PROCESSED');\n          }\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            this.trace('Picked subchannel ' + subchannelString + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + ' after getting credentials metadata. Retrying pick');\n            this.doPick();\n            return;\n          }\n          if (this.deadline !== Infinity) {\n            finalMetadata.set('grpc-timeout', (0, deadline_1.getDeadlineTimeoutString)(this.deadline));\n          }\n          try {\n            this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n              onReceiveMetadata: metadata => {\n                this.trace('Received metadata');\n                this.listener.onReceiveMetadata(metadata);\n              },\n              onReceiveMessage: message => {\n                this.trace('Received message');\n                this.listener.onReceiveMessage(message);\n              },\n              onReceiveStatus: status => {\n                this.trace('Received status');\n                if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                  this.outputStatus(status, 'REFUSED');\n                } else {\n                  this.outputStatus(status, 'PROCESSED');\n                }\n              }\n            });\n          } catch (error) {\n            this.trace('Failed to start call on picked subchannel ' + subchannelString + ' with error ' + error.message);\n            this.outputStatus({\n              code: constants_1.Status.INTERNAL,\n              details: 'Failed to start HTTP/2 stream with error ' + error.message,\n              metadata: new metadata_1.Metadata()\n            }, 'NOT_STARTED');\n            return;\n          }\n          (_b = (_a = this.callConfig).onCommitted) === null || _b === void 0 ? void 0 : _b.call(_a);\n          (_c = pickResult.onCallStarted) === null || _c === void 0 ? void 0 : _c.call(pickResult);\n          this.onCallEnded = pickResult.onCallEnded;\n          this.trace('Created child call [' + this.child.getCallNumber() + ']');\n          if (this.readPending) {\n            this.child.startRead();\n          }\n          if (this.pendingMessage) {\n            this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n          }\n          if (this.pendingHalfClose) {\n            this.child.halfClose();\n          }\n        }, error => {\n          // We assume the error code isn't 0 (Status.OK)\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          this.outputStatus({\n            code: code,\n            details: details,\n            metadata: new metadata_1.Metadata()\n          }, 'PROCESSED');\n        });\n        break;\n      case picker_1.PickResultType.DROP:\n        const {\n          code,\n          details\n        } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n        this.outputStatus({\n          code,\n          details,\n          metadata: pickResult.status.metadata\n        }, 'DROP');\n        break;\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const {\n            code,\n            details\n          } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);\n          this.outputStatus({\n            code,\n            details,\n            metadata: pickResult.status.metadata\n          }, 'PROCESSED');\n        }\n        break;\n      case picker_1.PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n  cancelWithStatus(status, details) {\n    var _a;\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    (_a = this.child) === null || _a === void 0 ? void 0 : _a.cancelWithStatus(status, details);\n    this.outputStatus({\n      code: status,\n      details: details,\n      metadata: new metadata_1.Metadata()\n    }, 'PROCESSED');\n  }\n  getPeer() {\n    var _a, _b;\n    return (_b = (_a = this.child) === null || _a === void 0 ? void 0 : _a.getPeer()) !== null && _b !== void 0 ? _b : this.channel.getTarget();\n  }\n  start(metadata, listener) {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context, message) {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = {\n        context,\n        message\n      };\n    }\n  }\n  startRead() {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose() {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials) {\n    throw new Error(\"Method not implemented.\");\n  }\n  getCallNumber() {\n    return this.callNumber;\n  }\n}\nexports.LoadBalancingCall = LoadBalancingCall;","map":{"version":3,"names":["connectivity_state_1","require","constants_1","deadline_1","metadata_1","picker_1","uri_parser_1","logging","control_plane_status_1","http2","TRACER_NAME","LoadBalancingCall","constructor","channel","callConfig","methodName","host","credentials","deadline","callNumber","child","readPending","pendingMessage","pendingHalfClose","pendingChildStatus","ended","metadata","listener","onCallEnded","splitPath","split","serviceName","length","hostname","_b","_a","splitHostPort","serviceUrl","trace","text","LogVerbosity","DEBUG","outputStatus","status","progress","code","details","finalStatus","Object","assign","onReceiveStatus","call","doPick","Error","pickResult","pickInformation","subchannelString","subchannel","getChannelzRef","id","getAddress","PickResultType","pickResultType","COMPLETE","generateMetadata","service_url","then","credsMetadata","finalMetadata","clone","merge","get","Status","INTERNAL","Metadata","getConnectivityState","ConnectivityState","READY","Infinity","set","getDeadlineTimeoutString","getRealSubchannel","createCall","onReceiveMetadata","onReceiveMessage","message","rstCode","constants","NGHTTP2_REFUSED_STREAM","error","onCommitted","_c","onCallStarted","getCallNumber","startRead","sendMessageWithContext","context","halfClose","restrictControlPlaneStatusCode","UNKNOWN","DROP","TRANSIENT_FAILURE","getOptions","waitForReady","queueCallForPick","QUEUE","cancelWithStatus","getPeer","getTarget","start","setCredentials","exports"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/load-balancing-call.ts"],"sourcesContent":["/*\n * Copyright 2022 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { CallCredentials } from \"./call-credentials\";\nimport { Call, InterceptingListener, MessageContext, StatusObject } from \"./call-interface\";\nimport { SubchannelCall } from \"./subchannel-call\";\nimport { ConnectivityState } from \"./connectivity-state\";\nimport { LogVerbosity, Status } from \"./constants\";\nimport { Deadline, getDeadlineTimeoutString } from \"./deadline\";\nimport { FilterStack, FilterStackFactory } from \"./filter-stack\";\nimport { InternalChannel } from \"./internal-channel\";\nimport { Metadata } from \"./metadata\";\nimport { PickResultType } from \"./picker\";\nimport { CallConfig } from \"./resolver\";\nimport { splitHostPort } from \"./uri-parser\";\nimport * as logging from './logging';\nimport { restrictControlPlaneStatusCode } from \"./control-plane-status\";\nimport * as http2 from 'http2';\n\nconst TRACER_NAME = 'load_balancing_call';\n\nexport type RpcProgress = 'NOT_STARTED' | 'DROP' | 'REFUSED' | 'PROCESSED';\n\nexport interface StatusObjectWithProgress extends StatusObject {\n  progress: RpcProgress;\n}\n\nexport interface LoadBalancingCallInterceptingListener extends InterceptingListener {\n  onReceiveStatus(status: StatusObjectWithProgress): void;\n}\n\nexport class LoadBalancingCall implements Call {\n  private child: SubchannelCall | null = null;\n  private readPending = false;\n  private pendingMessage: {context: MessageContext, message: Buffer} | null = null;\n  private pendingHalfClose = false;\n  private pendingChildStatus: StatusObject | null = null;\n  private ended = false;\n  private serviceUrl: string;\n  private metadata: Metadata | null = null;\n  private listener: InterceptingListener | null = null;\n  private onCallEnded: ((statusCode: Status) => void) | null = null;\n  constructor(\n    private readonly channel: InternalChannel,\n    private readonly callConfig: CallConfig,\n    private readonly methodName: string,\n    private readonly host : string,\n    private readonly credentials: CallCredentials,\n    private readonly deadline: Deadline,\n    private readonly callNumber: number\n  ) {\n    const splitPath: string[] = this.methodName.split('/');\n    let serviceName = '';\n    /* The standard path format is \"/{serviceName}/{methodName}\", so if we split\n     * by '/', the first item should be empty and the second should be the\n     * service name */\n    if (splitPath.length >= 2) {\n      serviceName = splitPath[1];\n    }\n    const hostname = splitHostPort(this.host)?.host ?? 'localhost';\n    /* Currently, call credentials are only allowed on HTTPS connections, so we\n     * can assume that the scheme is \"https\" */\n    this.serviceUrl = `https://${hostname}/${serviceName}`;\n  }\n\n  private trace(text: string): void {\n    logging.trace(\n      LogVerbosity.DEBUG,\n      TRACER_NAME,\n      '[' + this.callNumber + '] ' + text\n    );\n  }\n\n  private outputStatus(status: StatusObject, progress: RpcProgress) {\n    if (!this.ended) {\n      this.ended = true;\n      this.trace('ended with status: code=' + status.code + ' details=\"' + status.details + '\"');\n      const finalStatus = {...status, progress};\n      this.listener?.onReceiveStatus(finalStatus);\n      this.onCallEnded?.(finalStatus.code);\n    }\n  }\n\n  doPick() {\n    if (this.ended) {\n      return;\n    }\n    if (!this.metadata) {\n      throw new Error('doPick called before start');\n    }\n    this.trace('Pick called')\n    const pickResult = this.channel.doPick(this.metadata, this.callConfig.pickInformation);\n    const subchannelString = pickResult.subchannel ? \n      '(' + pickResult.subchannel.getChannelzRef().id + ') ' + pickResult.subchannel.getAddress() : \n      '' + pickResult.subchannel; \n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        subchannelString +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        this.credentials.generateMetadata({service_url: this.serviceUrl}).then(\n          (credsMetadata) => {\n            const finalMetadata = this.metadata!.clone();\n            finalMetadata.merge(credsMetadata);\n            if (finalMetadata.get('authorization').length > 1) {\n              this.outputStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: '\"authorization\" metadata cannot have multiple values',\n                  metadata: new Metadata()\n                },\n                'PROCESSED'\n              );\n            }\n            if (pickResult.subchannel!.getConnectivityState() !== ConnectivityState.READY) {\n              this.trace(\n                'Picked subchannel ' +\n                  subchannelString +\n                  ' has state ' +\n                  ConnectivityState[pickResult.subchannel!.getConnectivityState()] +\n                  ' after getting credentials metadata. Retrying pick'\n              );\n              this.doPick();\n              return;\n            }\n\n            if (this.deadline !== Infinity) {\n              finalMetadata.set('grpc-timeout', getDeadlineTimeoutString(this.deadline));\n            }\n            try {\n              this.child = pickResult.subchannel!.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {\n                onReceiveMetadata: metadata => {\n                  this.trace('Received metadata');\n                  this.listener!.onReceiveMetadata(metadata);\n                },\n                onReceiveMessage: message => {\n                  this.trace('Received message');\n                  this.listener!.onReceiveMessage(message);\n                },\n                onReceiveStatus: status => {\n                  this.trace('Received status');\n                  if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {\n                    this.outputStatus(status, 'REFUSED');\n                  } else {\n                    this.outputStatus(status, 'PROCESSED');\n                  }\n                }\n              });\n            } catch (error) {\n              this.trace(\n                'Failed to start call on picked subchannel ' +\n                  subchannelString +\n                  ' with error ' +\n                  (error as Error).message\n              );\n              this.outputStatus(\n                {\n                  code: Status.INTERNAL,\n                  details: 'Failed to start HTTP/2 stream with error ' + (error as Error).message,\n                  metadata: new Metadata()\n                },\n                'NOT_STARTED'\n              );\n              return;\n            }\n            this.callConfig.onCommitted?.();\n            pickResult.onCallStarted?.();\n            this.onCallEnded = pickResult.onCallEnded;\n            this.trace('Created child call [' + this.child.getCallNumber() + ']');\n            if (this.readPending) {\n              this.child.startRead();\n            }\n            if (this.pendingMessage) {\n              this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);\n            }\n            if (this.pendingHalfClose) {\n              this.child.halfClose();\n            }\n          }, (error: Error & { code: number }) => {\n            // We assume the error code isn't 0 (Status.OK)\n            const {code, details} = restrictControlPlaneStatusCode(\n              typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n              `Getting metadata from plugin failed with error: ${error.message}`\n            )\n            this.outputStatus(\n              {\n                code: code,\n                details: details,\n                metadata: new Metadata()\n              },\n              'PROCESSED'\n            );\n          }\n        );\n        break;\n      case PickResultType.DROP:\n        const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n        this.outputStatus({code, details, metadata: pickResult.status!.metadata}, 'DROP');\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (this.metadata.getOptions().waitForReady) {\n          this.channel.queueCallForPick(this);\n        } else {\n          const {code, details} = restrictControlPlaneStatusCode(pickResult.status!.code, pickResult.status!.details);\n          this.outputStatus({code, details, metadata: pickResult.status!.metadata}, 'PROCESSED');\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.channel.queueCallForPick(this);\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string): void {\n    this.trace('cancelWithStatus code: ' + status + ' details: \"' + details + '\"');\n    this.child?.cancelWithStatus(status, details);\n    this.outputStatus({code: status, details: details, metadata: new Metadata()}, 'PROCESSED');\n  }\n  getPeer(): string {\n    return this.child?.getPeer() ?? this.channel.getTarget();\n  }\n  start(metadata: Metadata, listener: LoadBalancingCallInterceptingListener): void {\n    this.trace('start called');\n    this.listener = listener;\n    this.metadata = metadata;\n    this.doPick();\n  }\n  sendMessageWithContext(context: MessageContext, message: Buffer): void {\n    this.trace('write() called with message of length ' + message.length);\n    if (this.child) {\n      this.child.sendMessageWithContext(context, message);\n    } else {\n      this.pendingMessage = {context, message};\n    }\n  }\n  startRead(): void {\n    this.trace('startRead called');\n    if (this.child) {\n      this.child.startRead();\n    } else {\n      this.readPending = true;\n    }\n  }\n  halfClose(): void {\n    this.trace('halfClose called');\n    if (this.child) {\n      this.child.halfClose();\n    } else {\n      this.pendingHalfClose = true;\n    }\n  }\n  setCredentials(credentials: CallCredentials): void {\n    throw new Error(\"Method not implemented.\");\n  }\n\n  getCallNumber(): number {\n    return this.callNumber;\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}