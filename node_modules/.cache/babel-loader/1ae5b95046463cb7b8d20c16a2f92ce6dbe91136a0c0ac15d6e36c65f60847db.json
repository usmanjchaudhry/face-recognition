{"ast":null,"code":"\"use strict\";\n\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Server = void 0;\nconst http2 = require(\"http2\");\nconst constants_1 = require(\"./constants\");\nconst server_call_1 = require(\"./server-call\");\nconst server_credentials_1 = require(\"./server-credentials\");\nconst resolver_1 = require(\"./resolver\");\nconst logging = require(\"./logging\");\nconst subchannel_address_1 = require(\"./subchannel-address\");\nconst uri_parser_1 = require(\"./uri-parser\");\nconst channelz_1 = require(\"./channelz\");\nconst error_1 = require(\"./error\");\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants;\nconst TRACER_NAME = 'server';\nfunction noop() {}\nfunction getUnimplementedStatusResponse(methodName) {\n  return {\n    code: constants_1.Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`\n  };\n}\nfunction getDefaultHandler(handlerType, methodName) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);\n  switch (handlerType) {\n    case 'unary':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'clientStream':\n      return (call, callback) => {\n        callback(unimplementedStatusResponse, null);\n      };\n    case 'serverStream':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return call => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\nclass Server {\n  constructor(options) {\n    var _a, _b, _c, _d;\n    this.http2ServerList = [];\n    this.handlers = new Map();\n    this.sessions = new Map();\n    this.started = false;\n    this.serverAddressString = 'null';\n    // Channelz Info\n    this.channelzEnabled = true;\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();\n    this.options = options !== null && options !== void 0 ? options : {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = (0, channelz_1.registerChannelzServer)(() => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    }\n    this.maxConnectionAgeMs = (_a = this.options['grpc.max_connection_age_ms']) !== null && _a !== void 0 ? _a : UNLIMITED_CONNECTION_AGE_MS;\n    this.maxConnectionAgeGraceMs = (_b = this.options['grpc.max_connection_age_grace_ms']) !== null && _b !== void 0 ? _b : UNLIMITED_CONNECTION_AGE_MS;\n    this.keepaliveTimeMs = (_c = this.options['grpc.keepalive_time_ms']) !== null && _c !== void 0 ? _c : KEEPALIVE_MAX_TIME_MS;\n    this.keepaliveTimeoutMs = (_d = this.options['grpc.keepalive_timeout_ms']) !== null && _d !== void 0 ? _d : KEEPALIVE_TIMEOUT_MS;\n    this.trace('Server constructed');\n  }\n  getChannelzInfo() {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n  getChannelzSessionInfoGetter(session) {\n    return () => {\n      var _a, _b, _c;\n      const sessionInfo = this.sessions.get(session);\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;\n      let tlsInfo;\n      if (session.encrypted) {\n        const tlsSocket = sessionSocket;\n        const cipherInfo = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n          remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: (_b = session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n        remoteFlowControlWindow: (_c = session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n      };\n      return socketInfo;\n    };\n  }\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n  addProtoService() {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n  addService(service, implementation) {\n    if (service === null || typeof service !== 'object' || implementation === null || typeof implementation !== 'object') {\n      throw new Error('addService() requires two objects as arguments');\n    }\n    const serviceKeys = Object.keys(service);\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      let methodType;\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n      let implFn = implementation[name];\n      let impl;\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n      const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n  removeService(service) {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach(name => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n  bind(port, creds) {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n  bindAsync(port, creds, callback) {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n    if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    const initialPortUri = (0, uri_parser_1.parseUri)(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n    const serverOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams']\n      };\n    }\n    const deferredCallback = (error, port) => {\n      process.nextTick(() => callback(error, port));\n    };\n    const setupServer = () => {\n      let http2Server;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(serverOptions, creds._getSettings());\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', socket => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', e => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n    const bindSpecificPort = (addressList, portNum, previousCount) => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: portNum,\n          count: previousCount\n        });\n      }\n      return Promise.all(addressList.map(address => {\n        this.trace('Attempting to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address));\n        let addr;\n        if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {\n          addr = {\n            host: address.host,\n            port: portNum\n          };\n        } else {\n          addr = address;\n        }\n        const http2Server = setupServer();\n        return new Promise((resolve, reject) => {\n          const onError = err => {\n            this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n            resolve(err);\n          };\n          http2Server.once('error', onError);\n          http2Server.listen(addr, () => {\n            const boundAddress = http2Server.address();\n            let boundSubchannelAddress;\n            if (typeof boundAddress === 'string') {\n              boundSubchannelAddress = {\n                path: boundAddress\n              };\n            } else {\n              boundSubchannelAddress = {\n                host: boundAddress.address,\n                port: boundAddress.port\n              };\n            }\n            let channelzRef;\n            channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), () => {\n              return {\n                localAddress: boundSubchannelAddress,\n                remoteAddress: null,\n                security: null,\n                remoteName: null,\n                streamsStarted: 0,\n                streamsSucceeded: 0,\n                streamsFailed: 0,\n                messagesSent: 0,\n                messagesReceived: 0,\n                keepAlivesSent: 0,\n                lastLocalStreamCreatedTimestamp: null,\n                lastRemoteStreamCreatedTimestamp: null,\n                lastMessageSentTimestamp: null,\n                lastMessageReceivedTimestamp: null,\n                localFlowControlWindow: null,\n                remoteFlowControlWindow: null\n              };\n            }, this.channelzEnabled);\n            if (this.channelzEnabled) {\n              this.listenerChildrenTracker.refChild(channelzRef);\n            }\n            this.http2ServerList.push({\n              server: http2Server,\n              channelzRef: channelzRef\n            });\n            this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n            resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n            http2Server.removeListener('error', onError);\n          });\n        });\n      })).then(results => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error('Invalid state: multiple port numbers added from single address');\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount\n        };\n      });\n    };\n    const bindWildcardPort = addressList => {\n      if (addressList.length === 0) {\n        return Promise.resolve({\n          port: 0,\n          count: 0\n        });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise((resolve, reject) => {\n        const onError = err => {\n          this.trace('Failed to bind ' + (0, subchannel_address_1.subchannelAddressToString)(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        };\n        http2Server.once('error', onError);\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address();\n          const boundSubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef;\n          channelzRef = (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress), () => {\n            return {\n              localAddress: boundSubchannelAddress,\n              remoteAddress: null,\n              security: null,\n              remoteName: null,\n              streamsStarted: 0,\n              streamsSucceeded: 0,\n              streamsFailed: 0,\n              messagesSent: 0,\n              messagesReceived: 0,\n              keepAlivesSent: 0,\n              lastLocalStreamCreatedTimestamp: null,\n              lastRemoteStreamCreatedTimestamp: null,\n              lastMessageSentTimestamp: null,\n              lastMessageReceivedTimestamp: null,\n              localFlowControlWindow: null,\n              remoteFlowControlWindow: null\n            };\n          }, this.channelzEnabled);\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.refChild(channelzRef);\n          }\n          this.http2ServerList.push({\n            server: http2Server,\n            channelzRef: channelzRef\n          });\n          this.trace('Successfully bound ' + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));\n          resolve(bindSpecificPort(addressList.slice(1), boundAddress.port, 1));\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n    const resolverListener = {\n      onSuccessfulResolution: (addressList, serviceConfig, serviceConfigError) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n        let bindResultPromise;\n        if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(addressList, addressList[0].port, 0);\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(bindResult => {\n          if (bindResult.count === 0) {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(constants_1.LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          } else {\n            if (bindResult.count < addressList.length) {\n              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);\n            }\n            deferredCallback(null, bindResult.port);\n          }\n        }, error => {\n          const errorString = `No address added out of total ${addressList.length} resolved`;\n          logging.log(constants_1.LogVerbosity.ERROR, errorString);\n          deferredCallback(new Error(errorString), 0);\n        });\n      },\n      onError: error => {\n        deferredCallback(new Error(error.details), 0);\n      }\n    };\n    const resolver = (0, resolver_1.createResolver)(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n  forceShutdown() {\n    // Close the server if it is still running.\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            (0, channelz_1.unregisterChannelzRef)(ref);\n          }\n        });\n      }\n    }\n    this.started = false;\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n    }\n  }\n  register(name, handler, serialize, deserialize, type) {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name\n    });\n    return true;\n  }\n  unregister(name) {\n    return this.handlers.delete(name);\n  }\n  start() {\n    if (this.http2ServerList.length === 0 || this.http2ServerList.every(_ref => {\n      let {\n        server: http2Server\n      } = _ref;\n      return http2Server.listening !== true;\n    })) {\n      throw new Error('server must be bound in order to start');\n    }\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n  tryShutdown(callback) {\n    const wrappedCallback = error => {\n      if (this.channelzEnabled) {\n        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n    function maybeCallback() {\n      pendingChecks--;\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n    // Close the server if necessary.\n    this.started = false;\n    for (const {\n      server: http2Server,\n      channelzRef: ref\n    } of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            (0, channelz_1.unregisterChannelzRef)(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n  addHttp2Port() {\n    throw new Error('Not yet implemented');\n  }\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns\n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n  _verifyContentType(stream, headers) {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n    if (typeof contentType !== 'string' || !contentType.startsWith('application/grpc')) {\n      stream.respond({\n        [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE\n      }, {\n        endStream: true\n      });\n      return false;\n    }\n    return true;\n  }\n  _retrieveHandler(headers) {\n    const path = headers[HTTP2_HEADER_PATH];\n    this.trace('Received call to method ' + path + ' at address ' + this.serverAddressString);\n    const handler = this.handlers.get(path);\n    if (handler === undefined) {\n      this.trace('No handler registered for method ' + path + '. Sending UNIMPLEMENTED status.');\n      throw getUnimplementedStatusResponse(path);\n    }\n    return handler;\n  }\n  _respondWithError(err, stream) {\n    let channelzSessionInfo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    const call = new server_call_1.Http2ServerCallStream(stream, null, this.options);\n    if (err.code === undefined) {\n      err.code = constants_1.Status.INTERNAL;\n    }\n    if (this.channelzEnabled) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n    }\n    call.sendError(err);\n  }\n  _channelzHandler(stream, headers) {\n    var _a;\n    const channelzSessionInfo = this.sessions.get(stream.session);\n    this.callTracker.addCallStarted();\n    channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError({\n        details: (0, error_1.getErrorMessage)(err),\n        code: (_a = (0, error_1.getErrorCode)(err)) !== null && _a !== void 0 ? _a : undefined\n      }, stream, channelzSessionInfo);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    call.once('callEnd', code => {\n      if (code === constants_1.Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    });\n    if (channelzSessionInfo) {\n      call.once('streamEnd', success => {\n        if (success) {\n          channelzSessionInfo.streamTracker.addCallSucceeded();\n        } else {\n          channelzSessionInfo.streamTracker.addCallFailed();\n        }\n      });\n      call.on('sendMessage', () => {\n        channelzSessionInfo.messagesSent += 1;\n        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n      });\n      call.on('receiveMessage', () => {\n        channelzSessionInfo.messagesReceived += 1;\n        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n      });\n    }\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _streamHandler(stream, headers) {\n    var _a;\n    if (this._verifyContentType(stream, headers) !== true) {\n      return;\n    }\n    let handler;\n    try {\n      handler = this._retrieveHandler(headers);\n    } catch (err) {\n      this._respondWithError({\n        details: (0, error_1.getErrorMessage)(err),\n        code: (_a = (0, error_1.getErrorCode)(err)) !== null && _a !== void 0 ? _a : undefined\n      }, stream, null);\n      return;\n    }\n    const call = new server_call_1.Http2ServerCallStream(stream, handler, this.options);\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      call.sendError({\n        code: constants_1.Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n  _runHandlerForCall(call, handler, headers) {\n    var _a;\n    const metadata = call.receiveMetadata(headers);\n    const encoding = (_a = metadata.get('grpc-encoding')[0]) !== null && _a !== void 0 ? _a : 'identity';\n    metadata.remove('grpc-encoding');\n    const {\n      type\n    } = handler;\n    if (type === 'unary') {\n      handleUnary(call, handler, metadata, encoding);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(call, handler, metadata, encoding);\n    } else if (type === 'serverStream') {\n      handleServerStreaming(call, handler, metadata, encoding);\n    } else if (type === 'bidi') {\n      handleBidiStreaming(call, handler, metadata, encoding);\n    } else {\n      return false;\n    }\n    return true;\n  }\n  _setupHandlers(http2Server) {\n    if (http2Server === null) {\n      return;\n    }\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null';\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress;\n      } else {\n        serverAddressString = serverAddress.address + ':' + serverAddress.port;\n      }\n    }\n    this.serverAddressString = serverAddressString;\n    const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;\n    http2Server.on('stream', handler.bind(this));\n    http2Server.on('session', session => {\n      var _a, _b, _c, _d, _e;\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n      let channelzRef;\n      channelzRef = (0, channelz_1.registerChannelzSocket)((_a = session.socket.remoteAddress) !== null && _a !== void 0 ? _a : 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n      const channelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new channelz_1.ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      let connectionAgeTimer = null;\n      let connectionAgeGraceTimer = null;\n      let sessionClosedByServer = false;\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n        connectionAgeTimer = (_c = (_b = setTimeout(() => {\n          var _a, _b;\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n          }\n          try {\n            session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), Buffer.from('max_age'));\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = (_b = (_a = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n          }\n        }, this.maxConnectionAgeMs + jitter)).unref) === null || _c === void 0 ? void 0 : _c.call(_b);\n      }\n      const keeapliveTimeTimer = (_e = (_d = setInterval(() => {\n        var _a, _b;\n        const timeoutTImer = (_b = (_a = setTimeout(() => {\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n          }\n          session.close();\n        }, this.keepaliveTimeoutMs)).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n        try {\n          session.ping((err, duration, payload) => {\n            clearTimeout(timeoutTImer);\n          });\n        } catch (e) {\n          // The ping can't be sent because the session is already closed\n          session.destroy();\n        }\n      }, this.keepaliveTimeMs)).unref) === null || _e === void 0 ? void 0 : _e.call(_d);\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          if (!sessionClosedByServer) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          }\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          (0, channelz_1.unregisterChannelzRef)(channelzRef);\n        }\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n        if (keeapliveTimeTimer) {\n          clearTimeout(keeapliveTimeTimer);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\nexports.Server = Server;\nfunction handleUnary(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const emitter = new server_call_1.ServerUnaryCallImpl(call, metadata, request);\n    handler.func(emitter, (err, value, trailer, flags) => {\n      call.sendUnaryMessage(err, value, trailer, flags);\n    });\n  });\n}\nfunction handleClientStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerReadableStreamImpl(call, metadata, handler.deserialize, encoding);\n  function respond(err, value, trailer, flags) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n  if (call.cancelled) {\n    return;\n  }\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\nfunction handleServerStreaming(call, handler, metadata, encoding) {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err);\n      return;\n    }\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n    const stream = new server_call_1.ServerWritableStreamImpl(call, metadata, handler.serialize, request);\n    handler.func(stream);\n  });\n}\nfunction handleBidiStreaming(call, handler, metadata, encoding) {\n  const stream = new server_call_1.ServerDuplexStreamImpl(call, metadata, handler.serialize, handler.deserialize, encoding);\n  if (call.cancelled) {\n    return;\n  }\n  handler.func(stream);\n}","map":{"version":3,"names":["http2","require","constants_1","server_call_1","server_credentials_1","resolver_1","logging","subchannel_address_1","uri_parser_1","channelz_1","error_1","UNLIMITED_CONNECTION_AGE_MS","KEEPALIVE_MAX_TIME_MS","KEEPALIVE_TIMEOUT_MS","HTTP2_HEADER_PATH","constants","TRACER_NAME","noop","getUnimplementedStatusResponse","methodName","code","Status","UNIMPLEMENTED","details","getDefaultHandler","handlerType","unimplementedStatusResponse","call","callback","emit","Error","Server","constructor","options","http2ServerList","handlers","Map","sessions","started","serverAddressString","channelzEnabled","channelzTrace","ChannelzTrace","callTracker","ChannelzCallTracker","listenerChildrenTracker","ChannelzChildrenTracker","sessionChildrenTracker","channelzRef","registerChannelzServer","getChannelzInfo","addTrace","maxConnectionAgeMs","_a","maxConnectionAgeGraceMs","_b","keepaliveTimeMs","_c","keepaliveTimeoutMs","_d","trace","listenerChildren","getChildLists","sessionChildren","getChannelzSessionInfoGetter","session","sessionInfo","get","sessionSocket","socket","remoteAddress","stringToSubchannelAddress","remotePort","localAddress","localPort","tlsInfo","encrypted","tlsSocket","cipherInfo","getCipher","certificate","getCertificate","peerCertificate","getPeerCertificate","cipherSuiteStandardName","standardName","cipherSuiteOtherName","name","localCertificate","raw","remoteCertificate","socketInfo","security","remoteName","streamsStarted","streamTracker","callsStarted","streamsSucceeded","callsSucceeded","streamsFailed","callsFailed","messagesSent","messagesReceived","keepAlivesSent","lastLocalStreamCreatedTimestamp","lastRemoteStreamCreatedTimestamp","lastCallStartedTimestamp","lastMessageSentTimestamp","lastMessageReceivedTimestamp","localFlowControlWindow","state","localWindowSize","remoteFlowControlWindow","remoteWindowSize","text","LogVerbosity","DEBUG","id","addProtoService","addService","service","implementation","serviceKeys","Object","keys","length","forEach","attrs","methodType","requestStream","responseStream","implFn","impl","undefined","originalName","bind","success","register","path","responseSerialize","requestDeserialize","removeService","unregister","port","creds","bindAsync","TypeError","ServerCredentials","initialPortUri","parseUri","portUri","mapUriDefaultScheme","serverOptions","maxSendHeaderBlockLength","Number","MAX_SAFE_INTEGER","maxSessionMemory","settings","maxConcurrentStreams","deferredCallback","error","process","nextTick","setupServer","http2Server","_isSecure","secureServerOptions","assign","_getSettings","createSecureServer","on","e","message","createServer","setTimeout","_setupHandlers","bindSpecificPort","addressList","portNum","previousCount","Promise","resolve","count","all","map","address","subchannelAddressToString","addr","isTcpSubchannelAddress","host","reject","onError","err","once","listen","boundAddress","boundSubchannelAddress","registerChannelzSocket","refChild","push","server","removeListener","then","results","result","bindWildcardPort","slice","resolverListener","onSuccessfulResolution","serviceConfig","serviceConfigError","bindResultPromise","bindResult","errorString","log","ERROR","INFO","resolver","createResolver","updateResolution","forceShutdown","ref","listening","close","unrefChild","unregisterChannelzRef","channelzInfo","destroy","NGHTTP2_CANCEL","clear","handler","serialize","deserialize","type","has","set","func","delete","start","every","_ref","tryShutdown","wrappedCallback","pendingChecks","maybeCallback","closed","addHttp2Port","getChannelzRef","_verifyContentType","stream","headers","contentType","HTTP2_HEADER_CONTENT_TYPE","startsWith","respond","HTTP2_HEADER_STATUS","HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE","endStream","_retrieveHandler","_respondWithError","channelzSessionInfo","arguments","Http2ServerCallStream","INTERNAL","addCallFailed","sendError","_channelzHandler","addCallStarted","getErrorMessage","getErrorCode","OK","addCallSucceeded","Date","_runHandlerForCall","_streamHandler","metadata","receiveMetadata","encoding","remove","handleUnary","handleClientStreaming","handleServerStreaming","handleBidiStreaming","serverAddress","clientAddress","connectionAgeTimer","connectionAgeGraceTimer","sessionClosedByServer","jitterMagnitude","jitter","Math","random","goaway","NGHTTP2_NO_ERROR","Buffer","from","unref","keeapliveTimeTimer","_e","setInterval","timeoutTImer","ping","duration","payload","clearTimeout","exports","receiveUnaryMessage","request","cancelled","emitter","ServerUnaryCallImpl","value","trailer","flags","sendUnaryMessage","ServerReadableStreamImpl","ServerWritableStreamImpl","ServerDuplexStreamImpl"],"sources":["/Users/usmanchaudhry/Documents/GitHub/weather-app/face-recognition/node_modules/@grpc/grpc-js/src/server.ts"],"sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { AddressInfo } from 'net';\n\nimport { ServiceError } from './call';\nimport { Status, LogVerbosity } from './constants';\nimport { Deserialize, Serialize, ServiceDefinition } from './make-client';\nimport { Metadata } from './metadata';\nimport {\n  BidiStreamingHandler,\n  ClientStreamingHandler,\n  HandleCall,\n  Handler,\n  HandlerType,\n  Http2ServerCallStream,\n  sendUnaryData,\n  ServerDuplexStream,\n  ServerDuplexStreamImpl,\n  ServerReadableStream,\n  ServerReadableStreamImpl,\n  ServerStreamingHandler,\n  ServerUnaryCall,\n  ServerUnaryCallImpl,\n  ServerWritableStream,\n  ServerWritableStreamImpl,\n  UnaryHandler,\n  ServerErrorResponse,\n  ServerStatusResponse,\n} from './server-call';\nimport { ServerCredentials } from './server-credentials';\nimport { ChannelOptions } from './channel-options';\nimport {\n  createResolver,\n  ResolverListener,\n  mapUriDefaultScheme,\n} from './resolver';\nimport * as logging from './logging';\nimport {\n  SubchannelAddress,\n  TcpSubchannelAddress,\n  isTcpSubchannelAddress,\n  subchannelAddressToString,\n  stringToSubchannelAddress,\n} from './subchannel-address';\nimport { parseUri } from './uri-parser';\nimport { ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzServer, registerChannelzSocket, ServerInfo, ServerRef, SocketInfo, SocketRef, TlsInfo, unregisterChannelzRef } from './channelz';\nimport { CipherNameAndProtocol, TLSSocket } from 'tls';\nimport { getErrorCode, getErrorMessage } from './error';\n\nconst UNLIMITED_CONNECTION_AGE_MS = ~(1<<31);\nconst KEEPALIVE_MAX_TIME_MS = ~(1<<31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nconst {\n  HTTP2_HEADER_PATH\n} = http2.constants\n\nconst TRACER_NAME = 'server';\n\ninterface BindResult {\n  port: number;\n  count: number;\n}\n\nfunction noop(): void {}\n\nfunction getUnimplementedStatusResponse(\n  methodName: string\n): Partial<ServiceError> {\n  return {\n    code: Status.UNIMPLEMENTED,\n    details: `The server does not implement the method ${methodName}`,\n  };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\ntype UntypedUnaryHandler = UnaryHandler<any, any>;\ntype UntypedClientStreamingHandler = ClientStreamingHandler<any, any>;\ntype UntypedServerStreamingHandler = ServerStreamingHandler<any, any>;\ntype UntypedBidiStreamingHandler = BidiStreamingHandler<any, any>;\nexport type UntypedHandleCall = HandleCall<any, any>;\ntype UntypedHandler = Handler<any, any>;\nexport interface UntypedServiceImplementation {\n  [name: string]: UntypedHandleCall;\n}\n\nfunction getDefaultHandler(handlerType: HandlerType, methodName: string) {\n  const unimplementedStatusResponse = getUnimplementedStatusResponse(\n    methodName\n  );\n  switch (handlerType) {\n    case 'unary':\n      return (\n        call: ServerUnaryCall<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'clientStream':\n      return (\n        call: ServerReadableStream<any, any>,\n        callback: sendUnaryData<any>\n      ) => {\n        callback(unimplementedStatusResponse as ServiceError, null);\n      };\n    case 'serverStream':\n      return (call: ServerWritableStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    case 'bidi':\n      return (call: ServerDuplexStream<any, any>) => {\n        call.emit('error', unimplementedStatusResponse);\n      };\n    default:\n      throw new Error(`Invalid handlerType ${handlerType}`);\n  }\n}\n\ninterface ChannelzSessionInfo {\n  ref: SocketRef;\n  streamTracker: ChannelzCallTracker;\n  messagesSent: number;\n  messagesReceived: number;\n  lastMessageSentTimestamp: Date | null;\n  lastMessageReceivedTimestamp: Date | null;\n}\n\ninterface ChannelzListenerInfo {\n  ref: SocketRef;\n}\n\nexport class Server {\n  private http2ServerList: { server: (http2.Http2Server | http2.Http2SecureServer), channelzRef: SocketRef }[] = [];\n\n  private handlers: Map<string, UntypedHandler> = new Map<\n    string,\n    UntypedHandler\n  >();\n  private sessions = new Map<http2.ServerHttp2Session, ChannelzSessionInfo>();\n  private started = false;\n  private options: ChannelOptions;\n  private serverAddressString: string = 'null'\n\n  // Channelz Info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: ServerRef;\n  private channelzTrace = new ChannelzTrace();\n  private callTracker = new ChannelzCallTracker();\n  private listenerChildrenTracker = new ChannelzChildrenTracker();\n  private sessionChildrenTracker = new ChannelzChildrenTracker();\n\n  private readonly maxConnectionAgeMs: number;\n  private readonly maxConnectionAgeGraceMs: number;\n\n  private readonly keepaliveTimeMs: number;\n  private readonly keepaliveTimeoutMs: number;\n\n  constructor(options?: ChannelOptions) {\n    this.options = options ?? {};\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzRef = registerChannelzServer(() => this.getChannelzInfo(), this.channelzEnabled);\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Server created');\n    }\n    this.maxConnectionAgeMs = this.options['grpc.max_connection_age_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;\n    this.maxConnectionAgeGraceMs = this.options['grpc.max_connection_age_grace_ms'] ?? UNLIMITED_CONNECTION_AGE_MS;\n    this.keepaliveTimeMs = this.options['grpc.keepalive_time_ms'] ?? KEEPALIVE_MAX_TIME_MS;\n    this.keepaliveTimeoutMs = this.options['grpc.keepalive_timeout_ms'] ?? KEEPALIVE_TIMEOUT_MS;\n    this.trace('Server constructed');\n  }\n\n  private getChannelzInfo(): ServerInfo {\n    return {\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      listenerChildren: this.listenerChildrenTracker.getChildLists(),\n      sessionChildren: this.sessionChildrenTracker.getChildLists()\n    };\n  }\n\n  private getChannelzSessionInfoGetter(session: http2.ServerHttp2Session): () => SocketInfo {\n    return () => {\n      const sessionInfo = this.sessions.get(session)!;\n      const sessionSocket = session.socket;\n      const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n      const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress!, sessionSocket.localPort) : null;\n      let tlsInfo: TlsInfo | null;\n      if (session.encrypted) {\n        const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n        const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n        const certificate = tlsSocket.getCertificate();\n        const peerCertificate = tlsSocket.getPeerCertificate();\n        tlsInfo = {\n          cipherSuiteStandardName: cipherInfo.standardName ?? null,\n          cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n          localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n          remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n        };\n      } else {\n        tlsInfo = null;\n      }\n      const socketInfo: SocketInfo = {\n        remoteAddress: remoteAddress,\n        localAddress: localAddress,\n        security: tlsInfo,\n        remoteName: null,\n        streamsStarted: sessionInfo.streamTracker.callsStarted,\n        streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,\n        streamsFailed: sessionInfo.streamTracker.callsFailed,\n        messagesSent: sessionInfo.messagesSent,\n        messagesReceived: sessionInfo.messagesReceived,\n        keepAlivesSent: 0,\n        lastLocalStreamCreatedTimestamp: null,\n        lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,\n        lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,\n        lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,\n        localFlowControlWindow: session.state.localWindowSize ?? null,\n        remoteFlowControlWindow: session.state.remoteWindowSize ?? null\n      };\n      return socketInfo;\n    };\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + text);\n  }\n  \n\n  addProtoService(): never {\n    throw new Error('Not implemented. Use addService() instead');\n  }\n\n  addService(\n    service: ServiceDefinition,\n    implementation: UntypedServiceImplementation\n  ): void {\n    if (\n      service === null ||\n      typeof service !== 'object' ||\n      implementation === null ||\n      typeof implementation !== 'object'\n    ) {\n      throw new Error('addService() requires two objects as arguments');\n    }\n\n    const serviceKeys = Object.keys(service);\n\n    if (serviceKeys.length === 0) {\n      throw new Error('Cannot add an empty service to a server');\n    }\n\n    serviceKeys.forEach((name) => {\n      const attrs = service[name];\n      let methodType: HandlerType;\n\n      if (attrs.requestStream) {\n        if (attrs.responseStream) {\n          methodType = 'bidi';\n        } else {\n          methodType = 'clientStream';\n        }\n      } else {\n        if (attrs.responseStream) {\n          methodType = 'serverStream';\n        } else {\n          methodType = 'unary';\n        }\n      }\n\n      let implFn = implementation[name];\n      let impl;\n\n      if (implFn === undefined && typeof attrs.originalName === 'string') {\n        implFn = implementation[attrs.originalName];\n      }\n\n      if (implFn !== undefined) {\n        impl = implFn.bind(implementation);\n      } else {\n        impl = getDefaultHandler(methodType, name);\n      }\n\n      const success = this.register(\n        attrs.path,\n        impl as UntypedHandleCall,\n        attrs.responseSerialize,\n        attrs.requestDeserialize,\n        methodType\n      );\n\n      if (success === false) {\n        throw new Error(`Method handler for ${attrs.path} already provided.`);\n      }\n    });\n  }\n\n  removeService(service: ServiceDefinition): void {\n    if (service === null || typeof service !== 'object') {\n      throw new Error('removeService() requires object as argument');\n    }\n\n    const serviceKeys = Object.keys(service);\n    serviceKeys.forEach((name) => {\n      const attrs = service[name];\n      this.unregister(attrs.path);\n    });\n  }\n\n  bind(port: string, creds: ServerCredentials): never {\n    throw new Error('Not implemented. Use bindAsync() instead');\n  }\n\n  bindAsync(\n    port: string,\n    creds: ServerCredentials,\n    callback: (error: Error | null, port: number) => void\n  ): void {\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n\n    if (typeof port !== 'string') {\n      throw new TypeError('port must be a string');\n    }\n\n    if (creds === null || !(creds instanceof ServerCredentials)) {\n      throw new TypeError('creds must be a ServerCredentials object');\n    }\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n\n    const initialPortUri = parseUri(port);\n    if (initialPortUri === null) {\n      throw new Error(`Could not parse port \"${port}\"`);\n    }\n    const portUri = mapUriDefaultScheme(initialPortUri);\n    if (portUri === null) {\n      throw new Error(`Could not get a default scheme for port \"${port}\"`);\n    }\n\n    const serverOptions: http2.ServerOptions = {\n      maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER,\n    };\n    if ('grpc-node.max_session_memory' in this.options) {\n      serverOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    } else {\n      /* By default, set a very large max session memory limit, to effectively\n       * disable enforcement of the limit. Some testing indicates that Node's\n       * behavior degrades badly when this limit is reached, so we solve that\n       * by disabling the check entirely. */\n      serverOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;\n    }\n    if ('grpc.max_concurrent_streams' in this.options) {\n      serverOptions.settings = {\n        maxConcurrentStreams: this.options['grpc.max_concurrent_streams'],\n      };\n    }\n\n    const deferredCallback = (error: Error | null, port: number) => {\n      process.nextTick(() => callback(error, port));\n    }\n\n    const setupServer = (): http2.Http2Server | http2.Http2SecureServer => {\n      let http2Server: http2.Http2Server | http2.Http2SecureServer;\n      if (creds._isSecure()) {\n        const secureServerOptions = Object.assign(\n          serverOptions,\n          creds._getSettings()!\n        );\n        http2Server = http2.createSecureServer(secureServerOptions);\n        http2Server.on('secureConnection', (socket: TLSSocket) => {\n          /* These errors need to be handled by the user of Http2SecureServer,\n           * according to https://github.com/nodejs/node/issues/35824 */\n          socket.on('error', (e: Error) => {\n            this.trace('An incoming TLS connection closed with error: ' + e.message);\n          });\n        });\n      } else {\n        http2Server = http2.createServer(serverOptions);\n      }\n\n      http2Server.setTimeout(0, noop);\n      this._setupHandlers(http2Server);\n      return http2Server;\n    };\n\n    const bindSpecificPort = (\n      addressList: SubchannelAddress[],\n      portNum: number,\n      previousCount: number\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve({ port: portNum, count: previousCount });\n      }\n      return Promise.all(\n        addressList.map((address) => {\n          this.trace('Attempting to bind ' + subchannelAddressToString(address));\n          let addr: SubchannelAddress;\n          if (isTcpSubchannelAddress(address)) {\n            addr = {\n              host: (address as TcpSubchannelAddress).host,\n              port: portNum,\n            };\n          } else {\n            addr = address;\n          }\n\n          const http2Server = setupServer();\n          return new Promise<number | Error>((resolve, reject) => {\n            const onError = (err: Error) => {\n              this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);\n              resolve(err);\n            }\n\n            http2Server.once('error', onError);\n\n            http2Server.listen(addr, () => {\n              const boundAddress = http2Server.address()!;\n              let boundSubchannelAddress: SubchannelAddress;\n              if (typeof boundAddress === 'string') {\n                boundSubchannelAddress = {\n                  path: boundAddress\n                };\n              } else {\n                boundSubchannelAddress = {\n                  host: boundAddress.address,\n                  port: boundAddress.port\n                }\n              }\n              let channelzRef: SocketRef;\n              channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => {\n                return {\n                  localAddress: boundSubchannelAddress,\n                  remoteAddress: null,\n                  security: null,\n                  remoteName: null,\n                  streamsStarted: 0,\n                  streamsSucceeded: 0,\n                  streamsFailed: 0,\n                  messagesSent: 0,\n                  messagesReceived: 0,\n                  keepAlivesSent: 0,\n                  lastLocalStreamCreatedTimestamp: null,\n                  lastRemoteStreamCreatedTimestamp: null,\n                  lastMessageSentTimestamp: null,\n                  lastMessageReceivedTimestamp: null,\n                  localFlowControlWindow: null,\n                  remoteFlowControlWindow: null\n                };\n              }, this.channelzEnabled);\n              if (this.channelzEnabled) {\n                this.listenerChildrenTracker.refChild(channelzRef);\n              }\n              this.http2ServerList.push({server: http2Server, channelzRef: channelzRef});\n              this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));\n              resolve('port' in boundSubchannelAddress ? boundSubchannelAddress.port : portNum);\n              http2Server.removeListener('error', onError);\n            });\n          });\n        })\n      ).then((results) => {\n        let count = 0;\n        for (const result of results) {\n          if (typeof result === 'number') {\n            count += 1;\n            if (result !== portNum) {\n              throw new Error(\n                'Invalid state: multiple port numbers added from single address'\n              );\n            }\n          }\n        }\n        return {\n          port: portNum,\n          count: count + previousCount,\n        };\n      });\n    };\n\n    const bindWildcardPort = (\n      addressList: SubchannelAddress[]\n    ): Promise<BindResult> => {\n      if (addressList.length === 0) {\n        return Promise.resolve<BindResult>({ port: 0, count: 0 });\n      }\n      const address = addressList[0];\n      const http2Server = setupServer();\n      return new Promise<BindResult>((resolve, reject) => {\n        const onError = (err: Error) => {\n          this.trace('Failed to bind ' + subchannelAddressToString(address) + ' with error ' + err.message);\n          resolve(bindWildcardPort(addressList.slice(1)));\n        }\n\n        http2Server.once('error', onError);\n\n        http2Server.listen(address, () => {\n          const boundAddress = http2Server.address() as AddressInfo;\n          const boundSubchannelAddress: SubchannelAddress = {\n            host: boundAddress.address,\n            port: boundAddress.port\n          };\n          let channelzRef: SocketRef;\n          channelzRef = registerChannelzSocket(subchannelAddressToString(boundSubchannelAddress), () => {\n            return {\n              localAddress: boundSubchannelAddress,\n              remoteAddress: null,\n              security: null,\n              remoteName: null,\n              streamsStarted: 0,\n              streamsSucceeded: 0,\n              streamsFailed: 0,\n              messagesSent: 0,\n              messagesReceived: 0,\n              keepAlivesSent: 0,\n              lastLocalStreamCreatedTimestamp: null,\n              lastRemoteStreamCreatedTimestamp: null,\n              lastMessageSentTimestamp: null,\n              lastMessageReceivedTimestamp: null,\n              localFlowControlWindow: null,\n              remoteFlowControlWindow: null\n            };\n          }, this.channelzEnabled);\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.refChild(channelzRef);\n          }\n          this.http2ServerList.push({server: http2Server, channelzRef: channelzRef});\n          this.trace('Successfully bound ' + subchannelAddressToString(boundSubchannelAddress));\n          resolve(\n            bindSpecificPort(\n              addressList.slice(1),\n              boundAddress.port,\n              1\n            )\n          );\n          http2Server.removeListener('error', onError);\n        });\n      });\n    };\n\n    const resolverListener: ResolverListener = {\n      onSuccessfulResolution: (\n        addressList,\n        serviceConfig,\n        serviceConfigError\n      ) => {\n        // We only want one resolution result. Discard all future results\n        resolverListener.onSuccessfulResolution = () => {};\n        if (addressList.length === 0) {\n          deferredCallback(new Error(`No addresses resolved for port ${port}`), 0);\n          return;\n        }\n        let bindResultPromise: Promise<BindResult>;\n        if (isTcpSubchannelAddress(addressList[0])) {\n          if (addressList[0].port === 0) {\n            bindResultPromise = bindWildcardPort(addressList);\n          } else {\n            bindResultPromise = bindSpecificPort(\n              addressList,\n              addressList[0].port,\n              0\n            );\n          }\n        } else {\n          // Use an arbitrary non-zero port for non-TCP addresses\n          bindResultPromise = bindSpecificPort(addressList, 1, 0);\n        }\n        bindResultPromise.then(\n          (bindResult) => {\n            if (bindResult.count === 0) {\n              const errorString = `No address added out of total ${addressList.length} resolved`;\n              logging.log(LogVerbosity.ERROR, errorString);\n              deferredCallback(new Error(errorString), 0);\n            } else {\n              if (bindResult.count < addressList.length) {\n                logging.log(\n                  LogVerbosity.INFO,\n                  `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`\n                );\n              }\n              deferredCallback(null, bindResult.port);\n            }\n          },\n          (error) => {\n            const errorString = `No address added out of total ${addressList.length} resolved`;\n            logging.log(LogVerbosity.ERROR, errorString);\n            deferredCallback(new Error(errorString), 0);\n          }\n        );\n      },\n      onError: (error) => {\n        deferredCallback(new Error(error.details), 0);\n      },\n    };\n\n    const resolver = createResolver(portUri, resolverListener, this.options);\n    resolver.updateResolution();\n  }\n\n  forceShutdown(): void {\n    // Close the server if it is still running.\n\n    for (const {server: http2Server, channelzRef: ref} of this.http2ServerList) {\n      if (http2Server.listening) {\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n        });\n      }\n    }\n\n    this.started = false;\n\n    // Always destroy any available sessions. It's possible that one or more\n    // tryShutdown() calls are in progress. Don't wait on them to finish.\n    this.sessions.forEach((channelzInfo, session) => {\n      // Cast NGHTTP2_CANCEL to any because TypeScript doesn't seem to\n      // recognize destroy(code) as a valid signature.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      session.destroy(http2.constants.NGHTTP2_CANCEL as any);\n    });\n    this.sessions.clear();\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n  }\n\n  register<RequestType, ResponseType>(\n    name: string,\n    handler: HandleCall<RequestType, ResponseType>,\n    serialize: Serialize<ResponseType>,\n    deserialize: Deserialize<RequestType>,\n    type: string\n  ): boolean {\n    if (this.handlers.has(name)) {\n      return false;\n    }\n\n    this.handlers.set(name, {\n      func: handler,\n      serialize,\n      deserialize,\n      type,\n      path: name,\n    } as UntypedHandler);\n    return true;\n  }\n\n  unregister(name: string): boolean {\n    return this.handlers.delete(name);\n  }\n\n  start(): void {\n    if (\n      this.http2ServerList.length === 0 ||\n      this.http2ServerList.every(\n        ({server: http2Server}) => http2Server.listening !== true\n      )\n    ) {\n      throw new Error('server must be bound in order to start');\n    }\n\n    if (this.started === true) {\n      throw new Error('server is already started');\n    }\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', 'Starting');\n    }\n    this.started = true;\n  }\n\n  tryShutdown(callback: (error?: Error) => void): void {\n    const wrappedCallback = (error?: Error) => {\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n      callback(error);\n    };\n    let pendingChecks = 0;\n\n    function maybeCallback(): void {\n      pendingChecks--;\n\n      if (pendingChecks === 0) {\n        wrappedCallback();\n      }\n    }\n\n    // Close the server if necessary.\n    this.started = false;\n\n    for (const {server: http2Server, channelzRef: ref} of this.http2ServerList) {\n      if (http2Server.listening) {\n        pendingChecks++;\n        http2Server.close(() => {\n          if (this.channelzEnabled) {\n            this.listenerChildrenTracker.unrefChild(ref);\n            unregisterChannelzRef(ref);\n          }\n          maybeCallback();\n        });\n      }\n    }\n\n    this.sessions.forEach((channelzInfo, session) => {\n      if (!session.closed) {\n        pendingChecks += 1;\n        session.close(maybeCallback);\n      }\n    });\n    if (pendingChecks === 0) {\n      wrappedCallback();\n    }\n  }\n\n  addHttp2Port(): never {\n    throw new Error('Not yet implemented');\n  }\n\n  /**\n   * Get the channelz reference object for this server. The returned value is\n   * garbage if channelz is disabled for this server.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  private _verifyContentType(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders): boolean {\n    const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];\n\n    if (\n      typeof contentType !== 'string' ||\n      !contentType.startsWith('application/grpc')\n    ) {\n      stream.respond(\n        {\n          [http2.constants.HTTP2_HEADER_STATUS]:\n            http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,\n        },\n        { endStream: true }\n      );\n      return false\n    }\n\n    return true\n  }\n\n  private _retrieveHandler(headers: http2.IncomingHttpHeaders): Handler<any, any> {\n    const path = headers[HTTP2_HEADER_PATH] as string\n\n    this.trace(\n      'Received call to method ' +\n      path +\n      ' at address ' +\n      this.serverAddressString\n    );\n\n    const handler = this.handlers.get(path);\n\n    if (handler === undefined) {\n      this.trace(\n        'No handler registered for method ' +\n        path +\n        '. Sending UNIMPLEMENTED status.'\n      );\n      throw getUnimplementedStatusResponse(path);\n    }\n\n    return handler\n  }\n  \n  private _respondWithError<T extends Partial<ServiceError>>(\n    err: T, \n    stream: http2.ServerHttp2Stream, \n    channelzSessionInfo: ChannelzSessionInfo | null = null\n  ) {\n    const call = new Http2ServerCallStream(stream, null!, this.options);\n    \n    if (err.code === undefined) {\n      err.code = Status.INTERNAL;\n    }\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed()\n    }\n\n    call.sendError(err);\n  }\n\n  private _channelzHandler(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) {\n    const channelzSessionInfo = this.sessions.get(stream.session as http2.ServerHttp2Session);\n    \n    this.callTracker.addCallStarted();\n    channelzSessionInfo?.streamTracker.addCallStarted();\n\n    if (!this._verifyContentType(stream, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed();\n      return\n    }\n\n    let handler: Handler<any, any>\n    try {\n      handler = this._retrieveHandler(headers)\n    } catch (err) {\n      this._respondWithError({\n        details: getErrorMessage(err),\n        code: getErrorCode(err) ?? undefined\n      }, stream, channelzSessionInfo)\n      return\n    }\n  \n    const call = new Http2ServerCallStream(stream, handler, this.options);\n      \n    call.once('callEnd', (code: Status) => {\n      if (code === Status.OK) {\n        this.callTracker.addCallSucceeded();\n      } else {\n        this.callTracker.addCallFailed();\n      }\n    });\n    \n    if (channelzSessionInfo) {\n      call.once('streamEnd', (success: boolean) => {\n        if (success) {\n          channelzSessionInfo.streamTracker.addCallSucceeded();\n        } else {\n          channelzSessionInfo.streamTracker.addCallFailed();\n        }\n      });\n      call.on('sendMessage', () => {\n        channelzSessionInfo.messagesSent += 1;\n        channelzSessionInfo.lastMessageSentTimestamp = new Date();\n      });\n      call.on('receiveMessage', () => {\n        channelzSessionInfo.messagesReceived += 1;\n        channelzSessionInfo.lastMessageReceivedTimestamp = new Date();\n      });\n    }\n\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      this.callTracker.addCallFailed();\n      channelzSessionInfo?.streamTracker.addCallFailed()\n\n      call.sendError({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n\n  private _streamHandler(stream: http2.ServerHttp2Stream, headers: http2.IncomingHttpHeaders) {\n    if (this._verifyContentType(stream, headers) !== true) {\n      return\n    }\n\n    let handler: Handler<any, any>\n    try {\n      handler = this._retrieveHandler(headers)\n    } catch (err) {\n      this._respondWithError({\n        details: getErrorMessage(err),\n        code: getErrorCode(err) ?? undefined\n      }, stream, null)\n      return\n    }\n\n    const call = new Http2ServerCallStream(stream, handler, this.options)\n    if (!this._runHandlerForCall(call, handler, headers)) {\n      call.sendError({\n        code: Status.INTERNAL,\n        details: `Unknown handler type: ${handler.type}`\n      });\n    }\n  }\n\n  private _runHandlerForCall(call: Http2ServerCallStream<any, any>, handler: Handler<any, any>, headers: http2.IncomingHttpHeaders): boolean {\n    const metadata = call.receiveMetadata(headers);\n    const encoding = (metadata.get('grpc-encoding')[0] as string | undefined) ?? 'identity';\n    metadata.remove('grpc-encoding');\n\n    const { type } = handler\n    if (type === 'unary') {\n      handleUnary(call, handler as UntypedUnaryHandler, metadata, encoding);\n    } else if (type === 'clientStream') {\n      handleClientStreaming(\n        call,\n        handler as UntypedClientStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else if (type === 'serverStream') {\n      handleServerStreaming(\n        call,\n        handler as UntypedServerStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else if (type === 'bidi') {\n      handleBidiStreaming(\n        call,\n        handler as UntypedBidiStreamingHandler,\n        metadata,\n        encoding\n      );\n    } else {\n      return false\n    }\n\n    return true\n  }\n\n  private _setupHandlers(\n    http2Server: http2.Http2Server | http2.Http2SecureServer\n  ): void {\n    if (http2Server === null) {\n      return;\n    }\n\n    const serverAddress = http2Server.address();\n    let serverAddressString = 'null'\n    if (serverAddress) {\n      if (typeof serverAddress === 'string') {\n        serverAddressString = serverAddress\n      } else {\n        serverAddressString =\n          serverAddress.address + ':' + serverAddress.port\n      }\n    }\n    this.serverAddressString = serverAddressString\n\n    const handler = this.channelzEnabled \n      ? this._channelzHandler \n      : this._streamHandler\n\n    http2Server.on('stream', handler.bind(this))\n    http2Server.on('session', (session) => {\n      if (!this.started) {\n        session.destroy();\n        return;\n      }\n\n      let channelzRef: SocketRef;\n      channelzRef = registerChannelzSocket(session.socket.remoteAddress ?? 'unknown', this.getChannelzSessionInfoGetter(session), this.channelzEnabled);\n\n      const channelzSessionInfo: ChannelzSessionInfo = {\n        ref: channelzRef,\n        streamTracker: new ChannelzCallTracker(),\n        messagesSent: 0,\n        messagesReceived: 0,\n        lastMessageSentTimestamp: null,\n        lastMessageReceivedTimestamp: null\n      };\n\n      this.sessions.set(session, channelzSessionInfo);\n      const clientAddress = session.socket.remoteAddress;\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Connection established by client ' + clientAddress);\n        this.sessionChildrenTracker.refChild(channelzRef);\n      }\n      let connectionAgeTimer: NodeJS.Timer | null = null;\n      let connectionAgeGraceTimer: NodeJS.Timer | null = null;\n      let sessionClosedByServer = false;\n      if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {\n        // Apply a random jitter within a +/-10% range\n        const jitterMagnitude = this.maxConnectionAgeMs / 10;\n        const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;\n        connectionAgeTimer = setTimeout(() => {\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by max connection age from ' + clientAddress);\n          }\n          try {\n            session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1<<31), Buffer.from('max_age'));\n          } catch (e) {\n            // The goaway can't be sent because the session is already closed\n            session.destroy();\n            return;\n          }\n          session.close();\n          /* Allow a grace period after sending the GOAWAY before forcibly\n           * closing the connection. */\n          if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {\n            connectionAgeGraceTimer = setTimeout(() => {\n              session.destroy();\n            }, this.maxConnectionAgeGraceMs).unref?.();\n          }\n        }, this.maxConnectionAgeMs + jitter).unref?.();\n      }\n      const keeapliveTimeTimer: NodeJS.Timer | null = setInterval(() => {\n        const timeoutTImer = setTimeout(() => {\n          sessionClosedByServer = true;\n          if (this.channelzEnabled) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by keepalive timeout from ' + clientAddress);\n          }\n          session.close();\n        }, this.keepaliveTimeoutMs).unref?.();\n        try {\n          session.ping((err: Error | null, duration: number, payload: Buffer) => {\n            clearTimeout(timeoutTImer);\n          });\n        } catch (e) {\n          // The ping can't be sent because the session is already closed\n          session.destroy();\n        }\n      }, this.keepaliveTimeMs).unref?.();\n      session.on('close', () => {\n        if (this.channelzEnabled) {\n          if (!sessionClosedByServer) {\n            this.channelzTrace.addTrace('CT_INFO', 'Connection dropped by client ' + clientAddress);\n          }\n          this.sessionChildrenTracker.unrefChild(channelzRef);\n          unregisterChannelzRef(channelzRef);\n        }\n        if (connectionAgeTimer) {\n          clearTimeout(connectionAgeTimer);\n        }\n        if (connectionAgeGraceTimer) {\n          clearTimeout(connectionAgeGraceTimer);\n        }\n        if (keeapliveTimeTimer) {\n          clearTimeout(keeapliveTimeTimer);\n        }\n        this.sessions.delete(session);\n      });\n    });\n  }\n}\n\nfunction handleUnary<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: UnaryHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err)\n      return\n    }\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const emitter = new ServerUnaryCallImpl<RequestType, ResponseType>(\n      call,\n      metadata,\n      request\n    );\n\n    handler.func(\n      emitter,\n      (\n        err: ServerErrorResponse | ServerStatusResponse | null,\n        value?: ResponseType | null,\n        trailer?: Metadata,\n        flags?: number\n      ) => {\n        call.sendUnaryMessage(err, value, trailer, flags);\n      }\n    );\n  });\n}\n\nfunction handleClientStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ClientStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerReadableStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.deserialize,\n    encoding\n  );\n\n  function respond(\n    err: ServerErrorResponse | ServerStatusResponse | null,\n    value?: ResponseType | null,\n    trailer?: Metadata,\n    flags?: number\n  ) {\n    stream.destroy();\n    call.sendUnaryMessage(err, value, trailer, flags);\n  }\n\n  if (call.cancelled) {\n    return;\n  }\n\n  stream.on('error', respond);\n  handler.func(stream, respond);\n}\n\nfunction handleServerStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: ServerStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  call.receiveUnaryMessage(encoding, (err, request) => {\n    if (err) {\n      call.sendError(err)\n      return\n    }\n\n    if (request === undefined || call.cancelled) {\n      return;\n    }\n\n    const stream = new ServerWritableStreamImpl<RequestType, ResponseType>(\n      call,\n      metadata,\n      handler.serialize,\n      request\n    );\n\n    handler.func(stream);\n  });\n}\n\nfunction handleBidiStreaming<RequestType, ResponseType>(\n  call: Http2ServerCallStream<RequestType, ResponseType>,\n  handler: BidiStreamingHandler<RequestType, ResponseType>,\n  metadata: Metadata,\n  encoding: string\n): void {\n  const stream = new ServerDuplexStreamImpl<RequestType, ResponseType>(\n    call,\n    metadata,\n    handler.serialize,\n    handler.deserialize,\n    encoding\n  );\n\n  if (call.cancelled) {\n    return;\n  }\n\n  handler.func(stream);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}